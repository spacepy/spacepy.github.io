
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spacepy.pycdf &#8212; SpacePy v0.2.2 Manual</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/copybutton.js"></script>
    
    <link rel="shortcut icon" href="../../_static/spacepy_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/spacepy_logo.jpg" border="0" alt="spacepy_logo"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="https://spacepy.github.io/"">homepage</a>|&nbsp;</li>
        <li><a href="https://github.com/spacepy/spacepy">development</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>
       <li><a href="../../index.html">documentation </a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../spacepy.html" accesskey="U">spacepy</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spacepy.pycdf</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spacepy.pycdf</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This package provides a Python interface to the Common Data Format (CDF)</span>
<span class="sd">library used for many NASA missions, available at http://cdf.gsfc.nasa.gov/.</span>
<span class="sd">It is targeted at Python 2.6+ and should work without change on either</span>
<span class="sd">Python 2 or Python 3.</span>

<span class="sd">The interface is intended to be &#39;pythonic&#39; rather than reproducing the</span>
<span class="sd">C interface. To open or close a CDF and access its variables, see the :class:`CDF`</span>
<span class="sd">class. Accessing data within the variables is via the :class:`Var`</span>
<span class="sd">class. The :data:`lib` object provides access to some routines</span>
<span class="sd">that affect the functionality of the library in general. The</span>
<span class="sd">:mod:`~spacepy.pycdf.const` module contains constants useful for accessing</span>
<span class="sd">the underlying library.</span>


<span class="sd">The CDF C library must be properly installed in order to use this package.</span>
<span class="sd">The CDF distribution provides scripts meant to be called in a user&#39;s</span>
<span class="sd">login scripts, ``definitions.B`` for bash and ``definitions.C`` for C-shell</span>
<span class="sd">derivatives. (See the installation instructions which come with the CDF library.)</span>
<span class="sd">These will set environment variables specifying the location</span>
<span class="sd">of the library; pycdf will respect these variables if they are set. Otherwise</span>
<span class="sd">it will search the standard system library path and the default installation</span>
<span class="sd">locations for the CDF library.</span>

<span class="sd">If pycdf has trouble finding the library, try setting ``CDF_LIB`` before importing</span>
<span class="sd">the module, e.g. if the library is in ``CDF/lib`` in the user&#39;s home directory:</span>
<span class="sd">    </span>
<span class="sd">&gt;&gt;&gt; import os</span>
<span class="sd">&gt;&gt;&gt; os.environ[&quot;CDF_LIB&quot;] = &quot;~/CDF/lib&quot;</span>
<span class="sd">&gt;&gt;&gt; from spacepy import pycdf</span>
<span class="sd">    </span>
<span class="sd">If this works, make the environment setting permanent. Note that on OSX,</span>
<span class="sd">using plists to set the environment may not carry over to Python terminal</span>
<span class="sd">sessions; use ``.cshrc`` or ``.bashrc`` instead.</span>

<span class="sd">Authors: Jon Niehof</span>

<span class="sd">Institution: University of New Hampshire</span>

<span class="sd">Contact: Jonathan.Niehof@unh.edu</span>


<span class="sd">Copyright 2010-2015 Los Alamos National Security, LLC.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__contact__</span> <span class="o">=</span> <span class="s1">&#39;Jon Niehof, Jonathan.Niehof@unh.edu&#39;</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">MutableSequence</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">MutableSequence</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">ctypes.util</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span>
<span class="kn">import</span> <span class="nn">spacepy.datamodel</span>
<span class="kn">import</span> <span class="nn">spacepy.time</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.dates</span>
    <span class="n">HAVE_MATPLOTLIB</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">HAVE_MATPLOTLIB</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1">#Import const AFTER library loaded, so failed load doesn&#39;t leave half-imported</span>
<span class="c1">#from . import const</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">str_classes</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">str_classes</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>


<div class="viewcode-block" id="Library"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library">[docs]</a><span class="k">class</span> <span class="nc">Library</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstraction of the base CDF C library and its state.</span>

<span class="sd">    Not normally intended for end-user use. An instance of this class</span>
<span class="sd">    is created at package load time as the :data:`~spacepy.pycdf.lib` variable, providing</span>
<span class="sd">    access to the underlying C library if necessary. The CDF library itself</span>
<span class="sd">    is described in section 2.1 of the CDF user&#39;s guide, as well as the CDF</span>
<span class="sd">    C reference manual.</span>

<span class="sd">    Calling the C library directly requires knowledge of</span>
<span class="sd">    :mod:`ctypes`.</span>

<span class="sd">    Instantiating this object loads the C library, see :doc:`/pycdf` docs</span>
<span class="sd">    for details.</span>

<span class="sd">    .. autosummary::</span>

<span class="sd">        ~Library.call</span>
<span class="sd">        ~Library.check_status</span>
<span class="sd">        ~Library.datetime_to_epoch</span>
<span class="sd">        ~Library.datetime_to_epoch16</span>
<span class="sd">        ~Library.datetime_to_tt2000</span>
<span class="sd">        ~Library.epoch_to_datetime</span>
<span class="sd">        ~Library.epoch_to_epoch16</span>
<span class="sd">        ~Library.epoch_to_num</span>
<span class="sd">        ~Library.epoch_to_tt2000</span>
<span class="sd">        ~Library.epoch16_to_datetime</span>
<span class="sd">        ~Library.epoch16_to_epoch</span>
<span class="sd">        ~Library.epoch16_to_tt2000</span>
<span class="sd">        ~Library.get_minmax</span>
<span class="sd">        ~Library.set_backward</span>
<span class="sd">        supports_int8</span>
<span class="sd">        ~Library.tt2000_to_datetime</span>
<span class="sd">        ~Library.tt2000_to_epoch</span>
<span class="sd">        ~Library.tt2000_to_epoch16</span>
<span class="sd">        v_datetime_to_epoch</span>
<span class="sd">        v_datetime_to_epoch16</span>
<span class="sd">        v_datetime_to_tt2000</span>
<span class="sd">        v_epoch_to_datetime</span>
<span class="sd">        v_epoch_to_tt2000</span>
<span class="sd">        v_epoch16_to_datetime</span>
<span class="sd">        v_epoch16_to_tt2000</span>
<span class="sd">        v_tt2000_to_datetime</span>
<span class="sd">        v_tt2000_to_epoch</span>
<span class="sd">        v_tt2000_to_epoch16</span>
<span class="sd">        libpath</span>
<span class="sd">        version</span>

<span class="sd">    .. automethod:: call</span>
<span class="sd">    .. automethod:: check_status</span>
<span class="sd">    .. automethod:: datetime_to_epoch</span>
<span class="sd">    .. automethod:: datetime_to_epoch16</span>
<span class="sd">    .. automethod:: datetime_to_tt2000</span>
<span class="sd">    .. automethod:: epoch_to_datetime</span>
<span class="sd">    .. automethod:: epoch_to_epoch16</span>
<span class="sd">    .. automethod:: epoch_to_num</span>
<span class="sd">    .. automethod:: epoch_to_tt2000</span>
<span class="sd">    .. automethod:: epoch16_to_datetime</span>
<span class="sd">    .. automethod:: epoch16_to_epoch</span>
<span class="sd">    .. automethod:: epoch16_to_tt2000</span>
<span class="sd">    .. automethod:: get_minmax</span>
<span class="sd">    .. automethod:: set_backward</span>

<span class="sd">    .. attribute:: supports_int8</span>

<span class="sd">       True if this library supports INT8 and TIME_TT2000 types; else False.</span>

<span class="sd">    .. automethod:: tt2000_to_datetime</span>
<span class="sd">    .. automethod:: tt2000_to_epoch</span>
<span class="sd">    .. automethod:: tt2000_to_epoch16</span>

<span class="sd">    .. method:: v_datetime_to_epoch(datetime)</span>
<span class="sd">    </span>
<span class="sd">        A vectorized version of :meth:`datetime_to_epoch` which takes a</span>
<span class="sd">        numpy array of datetimes as input and returns an array of epochs.</span>

<span class="sd">    .. method:: v_datetime_to_epoch16(datetime)</span>
<span class="sd">    </span>
<span class="sd">        A vectorized version of :meth:`datetime_to_epoch16` which takes a</span>
<span class="sd">        numpy array of datetimes as input and returns an array of epoch16.</span>

<span class="sd">    .. method:: v_datetime_to_tt2000(datetime)</span>
<span class="sd">    </span>
<span class="sd">        A vectorized version of :meth:`datetime_to_tt2000` which takes a</span>
<span class="sd">        numpy array of datetimes as input and returns an array of TT2000.</span>

<span class="sd">    .. method:: v_epoch_to_datetime(epoch)</span>
<span class="sd">    </span>
<span class="sd">        A vectorized version of :meth:`epoch_to_datetime` which takes a</span>
<span class="sd">        numpy array of epochs as input and returns an array of datetimes.</span>

<span class="sd">    .. method:: v_epoch_to_tt2000(epoch)</span>
<span class="sd">    </span>
<span class="sd">        A vectorized version of :meth:`epoch_to_tt2000` which takes a</span>
<span class="sd">        numpy array of epochs as input and returns an array of tt2000s.</span>

<span class="sd">    .. method:: v_epoch16_to_datetime(epoch0, epoch1)</span>
<span class="sd">    </span>
<span class="sd">        A vectorized version of :meth:`epoch16_to_datetime` which takes</span>
<span class="sd">        a numpy array of epoch16 as input and returns an array of datetimes.</span>
<span class="sd">        An epoch16 is a pair of doubles; the input array&#39;s last dimension</span>
<span class="sd">        must be two (and the returned array will have one fewer dimension).</span>

<span class="sd">    .. method:: v_epoch16_to_tt2000(epoch16)</span>
<span class="sd">    </span>
<span class="sd">        A vectorized version of :meth:`epoch16_to_tt2000` which takes</span>
<span class="sd">        a numpy array of epoch16 as input and returns an array of tt2000s.</span>
<span class="sd">        An epoch16 is a pair of doubles; the input array&#39;s last dimension</span>
<span class="sd">        must be two (and the returned array will have one fewer dimension).</span>

<span class="sd">    .. method:: v_tt2000_to_datetime(tt2000)</span>
<span class="sd">    </span>
<span class="sd">        A vectorized version of :meth:`tt2000_to_datetime` which takes</span>
<span class="sd">        a numpy array of tt2000 as input and returns an array of datetimes.</span>

<span class="sd">    .. method:: v_tt2000_to_epoch(tt2000)</span>
<span class="sd">    </span>
<span class="sd">        A vectorized version of :meth:`tt2000_to_epoch` which takes</span>
<span class="sd">        a numpy array of tt2000 as input and returns an array of epochs.</span>

<span class="sd">    .. method:: v_tt2000_to_epoch16(tt2000)</span>
<span class="sd">    </span>
<span class="sd">        A vectorized version of :meth:`tt2000_to_epoch16` which takes</span>
<span class="sd">        a numpy array of tt2000 as input and returns an array of epoch16.</span>

<span class="sd">    .. attribute:: libpath</span>

<span class="sd">       The path where pycdf found the CDF C library, potentially useful in</span>
<span class="sd">       debugging. If this contains just the name of a file (with no path</span>
<span class="sd">       information), then the system linker found the library for pycdf.</span>
<span class="sd">       On Linux, ``ldconfig -p`` may be useful for displaying the system&#39;s</span>
<span class="sd">       library resolution.</span>

<span class="sd">    .. attribute:: version</span>

<span class="sd">       Version of the CDF library, (version, release, increment, subincrement)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">libpath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">library</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the CDF C library.</span>

<span class="sd">        Searches for the library in the order:</span>
<span class="sd">            1. Appropriately-named file in CDF_LIB</span>
<span class="sd">            2. Appropriately-named file in CDF_BASE</span>
<span class="sd">            3. Standard library search path</span>
<span class="sd">        @raise CDFError: BAD_DATA_TYPE if can&#39;t map types properly</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;CDF_TMP&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;CDF_TMP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">library</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">libpath</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">libpath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_lib</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">((</span>
                        <span class="s1">&#39;Cannot load CDF C library; checked </span><span class="si">{0}</span><span class="s1">. &#39;</span>
                        <span class="s1">&#39;Try </span><span class="se">\&#39;</span><span class="s1">os.environ[&quot;CDF_LIB&quot;] = library_directory</span><span class="se">\&#39;</span><span class="s1"> &#39;</span>
                        <span class="s1">&#39;before import.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">libpath</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_library</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="n">libpath</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">libpath</span> <span class="o">=</span> <span class="n">libpath</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span> <span class="o">=</span> <span class="n">library</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">libpath</span> <span class="o">=</span> <span class="n">libpath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFlib</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="c1">#commonly used, so set it up here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">EPOCHbreakdown</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">]</span> <span class="o">*</span> <span class="mi">7</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH16</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH16</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> \
            <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDFsetFileBackward&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFsetFileBackward</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFsetFileBackward</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">]</span>
        <span class="c1">#Map old name to the 3.7.1+ name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;computeTT2000&#39;</span><span class="p">)</span> \
           <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_from_UTC_parts&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeTT2000</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_parts</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;computeTT2000&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeTT2000</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeTT2000</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">]</span> <span class="o">*</span><span class="mi">9</span>
        <span class="c1">#Map old name to the 3.7.1+ name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;breakdownTT2000&#39;</span><span class="p">)</span> \
           <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_to_UTC_parts&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">breakdownTT2000</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_parts</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;breakdownTT2000&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">breakdownTT2000</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">breakdownTT2000</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">9</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_to_UTC_EPOCH&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_from_UTC_EPOCH&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_to_UTC_EPOCH16&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH16</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH16</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_from_UTC_EPOCH16&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH16</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> \
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH16</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="c1">#Get CDF version information</span>
        <span class="n">ver</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_char</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">LIB_VERSION_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">ver</span><span class="p">),</span>
                  <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">LIB_RELEASE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">rel</span><span class="p">),</span>
                  <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">LIB_INCREMENT_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">inc</span><span class="p">),</span>
                  <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">LIB_subINCREMENT_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">sub</span><span class="p">))</span>
        <span class="n">ver</span> <span class="o">=</span> <span class="n">ver</span><span class="o">.</span><span class="n">value</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">value</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">inc</span><span class="o">.</span><span class="n">value</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="p">(</span><span class="n">ver</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_del_middle_rec_bug</span> <span class="o">=</span> <span class="n">ver</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ver</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span>
                                               <span class="p">(</span><span class="n">rel</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">or</span>
                                                <span class="p">(</span><span class="n">rel</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">inc</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">supports_int8</span> <span class="o">=</span> <span class="p">(</span><span class="n">ver</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ver</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">rel</span> <span class="o">&gt;=</span><span class="mi">4</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cdftypenames</span> <span class="o">=</span> <span class="p">{</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_BYTE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_BYTE&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_CHAR&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT1</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_INT1&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_UCHAR&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT1</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_UINT1&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT2</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_INT2&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT2</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_UINT2&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_INT4&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_UINT4&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_INT8&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_FLOAT&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_REAL4&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_DOUBLE&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_REAL8&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_EPOCH&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_EPOCH16&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_TIME_TT2000&#39;</span><span class="p">,</span>
                             <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numpytypedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_BYTE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT1</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT1</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT2</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT2</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                              <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
                              <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timetypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                          <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                          <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">supports_int8</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;linux&#39;</span><span class="p">)</span> \
             <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">uname</span><span class="p">()[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;arm&#39;</span><span class="p">)</span> \
             <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;computeTT2000&#39;</span><span class="p">)</span> \
             <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeTT2000</span><span class="p">(</span>
                 <span class="mi">2010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">315576066184000000</span><span class="p">:</span>
            <span class="c1">#TT2000 call failed, so probably need to type-pun</span>
            <span class="c1">#double arguments to variadic functions.</span>
            <span class="c1">#Calling convention for non-variadic functions with floats</span>
            <span class="c1">#is unique, but convention for ints is same as variadic.</span>
            <span class="c1">#So type-pun arguments to integers to force that calling</span>
            <span class="c1">#convention.</span>
            <span class="k">if</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">)</span> <span class="o">!=</span> \
               <span class="n">ctypes</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;ARM with unknown type sizes; &#39;</span>
                              <span class="s1">&#39;TT2000 functions will not work.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeTT2000</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> \
                    <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">]</span> <span class="o">*</span> <span class="mi">9</span>
                <span class="n">c_ll_p</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeTT2000</span><span class="p">(</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="mi">2010</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="mi">1</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="mi">1</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">315576066184000000</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;ARM with unknown calling convention; &#39;</span>
                                  <span class="s1">&#39;TT2000 functions will not work.&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">datetime_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_datetime_to_tt2000_typepunned</span>

        <span class="n">v_epoch16_to_datetime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch16_to_datetime</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch16_to_datetime</span> <span class="o">=</span> \
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">v_epoch16_to_datetime</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch_to_datetime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch_to_datetime</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_datetime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_datetime</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_datetime_to_epoch</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datetime_to_epoch</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
        <span class="n">v_datetime_to_epoch16</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datetime_to_epoch16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1">#frompyfunc returns a TUPLE of the returned values,</span>
        <span class="c1">#implicitly the 0th dimension. We want everything from one</span>
        <span class="c1">#call paired, so this rolls the 0th dimension to the last</span>
        <span class="c1">#(via the second-to-last)</span>
        <span class="k">def</span> <span class="nf">_v_datetime_to_epoch16</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">v_datetime_to_epoch16</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                                      <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">retval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">retval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_datetime_to_epoch16</span> <span class="o">=</span> <span class="n">_v_datetime_to_epoch16</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_datetime_to_tt2000</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datetime_to_tt2000</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch_to_tt2000</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch_to_tt2000</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_epoch</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_epoch</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
        <span class="n">v_epoch16_to_tt2000</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch16_to_tt2000</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch16_to_tt2000</span> <span class="o">=</span> \
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">v_epoch16_to_tt2000</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">v_tt2000_to_epoch16</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_epoch16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1">#frompyfunc returns a TUPLE of the returned values,</span>
        <span class="c1">#implicitly the 0th dimension. We want everything from one</span>
        <span class="c1">#call paired, so this rolls the 0th dimension to the last</span>
        <span class="c1">#(via the second-to-last)</span>
        <span class="k">def</span> <span class="nf">_v_tt2000_to_epoch16</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">v_tt2000_to_epoch16</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                                      <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">retval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">retval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_epoch16</span> <span class="o">=</span> <span class="n">_v_tt2000_to_epoch16</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">supports_int8</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datetime_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_datetime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_datetime_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_datetime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch_16_to_tt2000</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch16_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_epoch16</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_epoch16</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>

        <span class="c1">#Default to V2 CDF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_backward</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># User has not explicitly called set_backward</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_explicit_backward</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_lib</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for the CDF library</span>

<span class="sd">        Searches in likely locations for CDF libraries and attempts to load</span>
<span class="sd">        them. Stops at first successful load and, if fails, reports all</span>
<span class="sd">        the files that were tried as libraries.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : tuple</span>
<span class="sd">             This is either (path to library, loaded library)</span>
<span class="sd">             or, in the event of failure, (None, list of libraries tried)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">libpath</span> <span class="ow">in</span> <span class="n">Library</span><span class="o">.</span><span class="n">_lib_paths</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lib</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="n">libpath</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">libpath</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">libpath</span><span class="p">,</span> <span class="n">lib</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">failed</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_lib_paths</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Find candidate paths for the CDF library</span>

<span class="sd">        Does not check that the library is actually in any particular directory,</span>
<span class="sd">        just returns a list of possible locations, in priority order.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : generator of str</span>
<span class="sd">            paths that look like the CDF library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#What the library might be named</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;dllcdf.dll&#39;</span><span class="p">],</span>
                  <span class="s1">&#39;darwin&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;libcdf.dylib&#39;</span><span class="p">,</span> <span class="s1">&#39;cdf.dylib&#39;</span><span class="p">,</span> <span class="s1">&#39;libcdf.so&#39;</span><span class="p">],</span>
                  <span class="s1">&#39;linux2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;libcdf.so&#39;</span><span class="p">],</span>
                  <span class="s1">&#39;linux&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;libcdf.so&#39;</span><span class="p">],</span>
                  <span class="p">}</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;libcdf.so&#39;</span><span class="p">])</span>
        <span class="c1">#All existing CDF-library-like paths within a directory</span>
        <span class="n">search_dir</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> \
            <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">names</span>
             <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fname</span><span class="p">))]</span>
        <span class="c1">#Search the environment-specified places first</span>
        <span class="k">if</span> <span class="s1">&#39;CDF_LIB&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">search_dir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;CDF_LIB&#39;</span><span class="p">]):</span>
                <span class="k">yield</span> <span class="n">p</span>
        <span class="k">if</span> <span class="s1">&#39;CDF_BASE&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">search_dir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;CDF_BASE&#39;</span><span class="p">],</span> <span class="s1">&#39;lib&#39;</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="n">p</span>
        <span class="n">ctypespath</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_library</span><span class="p">(</span>
            <span class="s1">&#39;dllcdf.dll&#39;</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;win32&#39;</span> <span class="k">else</span> <span class="s1">&#39;cdf&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ctypespath</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">ctypespath</span>
        <span class="c1">#LD_LIBRARY_PATH specifies runtime library search paths</span>
        <span class="k">if</span> <span class="s1">&#39;LD_LIBRARY_PATH&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LD_LIBRARY_PATH&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">pathsep</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">search_dir</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">p</span>
        <span class="c1">#Finally, defaults places CDF gets installed uner</span>
        <span class="c1">#CDF_BASE is usually a subdir of these (with &quot;cdf&quot; in the name)</span>
        <span class="c1">#Searched in order given here!</span>
        <span class="n">cdfdists</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c:</span><span class="se">\\</span><span class="s1">CDF Distribution</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;c:</span><span class="se">\\</span><span class="s1">CDF_Distribution</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;darwin&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;/Applications/&#39;</span><span class="p">,</span> <span class="s1">&#39;/usr/local/&#39;</span><span class="p">,</span>
                               <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)],</span>
                    <span class="s1">&#39;linux2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;/usr/local/&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)],</span>
                    <span class="s1">&#39;linux&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;/usr/local/&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)],</span>
                    <span class="p">}</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="ow">in</span> <span class="n">cdfdists</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cdfdist</span> <span class="ow">in</span> <span class="n">cdfdists</span><span class="p">[</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">cdfdist</span><span class="p">):</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">cdfdist</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;cdf&#39;</span><span class="p">:</span>
                            <span class="c1">#checking src in case BUILT but not INSTALLED</span>
                            <span class="k">for</span> <span class="n">subdir</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lib&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;src&#39;</span><span class="p">,</span> <span class="s1">&#39;lib&#39;</span><span class="p">)]:</span>
                                <span class="n">libdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cdfdist</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">subdir</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">libdir</span><span class="p">):</span>
                                    <span class="n">cand</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">libdir</span><span class="p">)</span>
                    <span class="c1">#Sort reverse, so new versions are first FOR THIS cdfdist</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cand</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">search_dir</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                            <span class="k">yield</span> <span class="n">p</span>

<div class="viewcode-block" id="Library.check_status"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.check_status">[docs]</a>    <span class="k">def</span> <span class="nf">check_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise exception or warning based on return status of CDF call</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        status : int</span>
<span class="sd">            status returned by the C library</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        ignore : sequence of ctypes.c_long</span>
<span class="sd">            CDF statuses to ignore. If any of these is returned by CDF library,</span>
<span class="sd">            any related warnings or exceptions will *not* be raised.</span>
<span class="sd">            (Default none).</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if status &lt; CDF_WARN, indicating an error</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        CDFWarning : if CDF_WARN &lt;= status &lt; CDF_OK, indicating a warning.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            status (unchanged)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_OK</span> <span class="ow">or</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">status</span>
        <span class="k">if</span> <span class="n">status</span> <span class="o">&lt;</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_WARN</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warning</span> <span class="o">=</span> <span class="n">CDFWarning</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
            <span class="n">warning</span><span class="o">.</span><span class="n">warn</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">status</span></div>

<div class="viewcode-block" id="Library.call"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call the CDF internal interface</span>

<span class="sd">        Passes all parameters directly through to the CDFlib routine of the</span>
<span class="sd">        CDF library&#39;s C internal interface. Checks the return value with</span>
<span class="sd">        :meth:`check_status`.</span>

<span class="sd">        Terminal NULL is automatically added to args.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        args : various, see :mod:`ctypes`</span>
<span class="sd">            Passed directly to the CDF library interface. Useful</span>
<span class="sd">            constants are defined in the :mod:`~pycdf.const` module.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        ignore : sequence of CDF statuses</span>
<span class="sd">            sequence of CDF statuses to ignore. If any of these</span>
<span class="sd">            is returned by CDF library, any related warnings or</span>
<span class="sd">            exceptions will *not* be raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            CDF status from the library</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        CDFWarning : if CDF library reports a warning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;ignore&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFlib</span><span class="p">(</span>
                <span class="o">*</span><span class="p">(</span><span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">NULL_</span><span class="p">,</span> <span class="p">))</span>
                <span class="p">),</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ignore&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFlib</span><span class="p">(</span>
                <span class="o">*</span><span class="p">(</span><span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">NULL_</span><span class="p">,</span> <span class="p">))</span>
                <span class="p">))</span></div>

<div class="viewcode-block" id="Library.set_backward"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.set_backward">[docs]</a>    <span class="k">def</span> <span class="nf">set_backward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backward</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set backward compatibility mode for new CDFs</span>

<span class="sd">        Unless backward compatible mode is set, CDF files created by</span>
<span class="sd">        the version 3 library can not be read by V2.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        backward : boolean</span>
<span class="sd">            Set backward compatible mode if True; clear it if False.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        ValueError : if backward=False and underlying CDF library is V2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># User has explicitly chosen backward compat or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_explicit_backward</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">backward</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Cannot disable backward-compatible mode for CDF version 2.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFsetFileBackward</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BACKWARDFILEon</span> <span class="k">if</span> <span class="n">backward</span>
                                         <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">BACKWARDFILEoff</span><span class="p">)</span></div>

<div class="viewcode-block" id="Library.epoch_to_datetime"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.epoch_to_datetime">[docs]</a>    <span class="k">def</span> <span class="nf">epoch_to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF epoch value to a datetime</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch : float</span>
<span class="sd">            epoch value from CDF</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :class:`datetime.datetime`</span>
<span class="sd">            date and time corresponding to epoch. Invalid values are set to</span>
<span class="sd">            usual epoch invalid value, i.e. last moment of year 9999.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_epoch_to_datetime</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yyyy</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hh</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">msec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">EPOCHbreakdown</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">epoch</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">yyyy</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">dd</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hh</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="nb">min</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">sec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">msec</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">yyyy</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999000</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">sec</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">msec</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span></div>

<div class="viewcode-block" id="Library.datetime_to_epoch"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.datetime_to_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">datetime_to_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a Python datetime to a CDF Epoch value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        dt : :class:`datetime.datetime`</span>
<span class="sd">            date and time to convert</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : float</span>
<span class="sd">            epoch corresponding to dt</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_datetime_to_epoch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">tzinfo</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span>
        <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">micro</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">%</span> <span class="mi">1000</span>
        <span class="k">if</span> <span class="n">micro</span> <span class="o">&gt;=</span> <span class="mi">500</span> <span class="ow">and</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">&lt;</span> <span class="mi">9999</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">+=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span>
                                          <span class="n">dt</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">second</span><span class="p">,</span>
                                          <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">))</span></div>

<div class="viewcode-block" id="Library.epoch16_to_datetime"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.epoch16_to_datetime">[docs]</a>    <span class="k">def</span> <span class="nf">epoch16_to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch0</span><span class="p">,</span> <span class="n">epoch1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF epoch16 value to a datetime</span>

<span class="sd">        .. note::</span>
<span class="sd">            The call signature has changed since SpacePy 0.1.2. Formerly</span>
<span class="sd">            this method took a single argument with two values; now it</span>
<span class="sd">            requires two arguments (one for each value). To convert existing</span>
<span class="sd">            code, replace ``epoch16_to_datetime(epoch)`` with</span>
<span class="sd">            ``epoch16_to_datetime(*epoch)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch0 : float</span>
<span class="sd">            epoch16 value from CDF, first half</span>
<span class="sd">        epoch1 : float</span>
<span class="sd">            epoch16 value from CDF, second half</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        EpochError : if input invalid</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :class:`datetime.datetime`</span>
<span class="sd">            date and time corresponding to epoch. Invalid values are set to</span>
<span class="sd">            usual epoch invalid value, i.e. last moment of year 9999.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_epoch16_to_datetime</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yyyy</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hh</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">msec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">usec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nsec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">psec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">EPOCH16breakdown</span><span class="p">((</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)(</span><span class="n">epoch0</span><span class="p">,</span> <span class="n">epoch1</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">yyyy</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">dd</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hh</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="nb">min</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">sec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">msec</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">usec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">nsec</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">psec</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">yyyy</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
        <span class="n">micro</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">msec</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">usec</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">nsec</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">psec</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e6</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">micro</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">sec</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">micro</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">add_sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">micro</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                         <span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">sec</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                         <span class="n">micro</span> <span class="o">-</span> <span class="n">add_sec</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">+</span> \
                                         <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">add_sec</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">MAXYEAR</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span>
                                         <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span>
                                         <span class="mi">999999</span><span class="p">)</span></div>

<div class="viewcode-block" id="Library.datetime_to_epoch16"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.datetime_to_epoch16">[docs]</a>    <span class="k">def</span> <span class="nf">datetime_to_epoch16</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a Python datetime to a CDF Epoch16 value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        dt :  :class:`datetime.datetime`</span>
<span class="sd">            date and time to convert</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : list of float</span>
<span class="sd">            epoch16 corresponding to dt</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_datetime_to_epoch16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">tzinfo</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span>
        <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1">#Default to &quot;illegal epoch&quot;</span>
        <span class="n">epoch16</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH16</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span>
                                        <span class="n">dt</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">second</span><span class="p">,</span>
                                        <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">),</span>
                                        <span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="n">epoch16</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span> <span class="c1">#Failure, so illegal epoch</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">epoch16</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">epoch16</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Library.epoch_to_epoch16"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.epoch_to_epoch16">[docs]</a>    <span class="k">def</span> <span class="nf">epoch_to_epoch16</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF EPOCH to a CDF EPOCH16 value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch : double</span>
<span class="sd">            EPOCH to convert. Lists and numpy arrays are acceptable.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : (double, double)</span>
<span class="sd">            EPOCH16 corresponding to epoch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">e</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)</span>
        <span class="c1">#ugly numpy stuff, probably a better way....</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">newshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">newshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Library.epoch_to_num"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.epoch_to_num">[docs]</a>    <span class="k">def</span> <span class="nf">epoch_to_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert CDF EPOCH to matplotlib number.</span>

<span class="sd">        Same output as :func:`~matplotlib.dates.date2num` and useful for</span>
<span class="sd">        plotting large data sets without converting the times through datetime.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch : double</span>
<span class="sd">            EPOCH to convert. Lists and numpy arrays are acceptable.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : double</span>
<span class="sd">            Floating point number representing days since matplotlib</span>
<span class="sd">            epoch (usually 0001-01-01 as day 1, or 1970-01-01 as day 0).</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        matplotlib.dates.date2num, matplotlib.dates.num2date</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>
<span class="sd">        This number is not portable between versions of matplotlib. The</span>
<span class="sd">        returned value is for the installed version of matplotlib. If</span>
<span class="sd">        matplotlib is not found, the returned value is for matplotlib 3.2</span>
<span class="sd">        and earlier.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#date2num day 1 is 1/1/1 00UT</span>
        <span class="c1">#epoch 1/1/1 00UT is 31622400000.0 (millisecond)</span>
        <span class="c1"># So day 0 is 31536000000.0</span>
        <span class="n">baseepoch</span> <span class="o">=</span> <span class="mf">31536000000.0</span>
        <span class="k">if</span> <span class="n">HAVE_MATPLOTLIB</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">dates</span><span class="p">,</span> <span class="s1">&#39;get_epoch&#39;</span><span class="p">):</span>
            <span class="c1"># Different day 0</span>
            <span class="n">baseepoch</span> <span class="o">=</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Ticktock</span><span class="p">(</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">dates</span><span class="o">.</span><span class="n">get_epoch</span><span class="p">())</span>\
                                    <span class="o">.</span><span class="n">CDF</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">-</span> <span class="n">baseepoch</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Library.epoch16_to_epoch"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.epoch16_to_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">epoch16_to_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch16</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF EPOCH16 to a CDF EPOCH value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch16 : (double, double)</span>
<span class="sd">            EPOCH16 to convert. Lists and numpy arrays are acceptable.</span>
<span class="sd">            LAST dimension should be 2: the two pairs of EPOCH16</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : double</span>
<span class="sd">            EPOCH corresponding to epoch16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">epoch16</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">)</span></div>

<div class="viewcode-block" id="Library.tt2000_to_datetime"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.tt2000_to_datetime">[docs]</a>    <span class="k">def</span> <span class="nf">tt2000_to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tt2000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF TT2000 value to a datetime</span>

<span class="sd">        .. note::</span>
<span class="sd">            Although TT2000 values support leapseconds, Python&#39;s datetime</span>
<span class="sd">            object does not. Any times after 23:59:59.999999 will</span>
<span class="sd">            be truncated to 23:59:59.999999.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        tt2000 : int</span>
<span class="sd">            TT2000 value from CDF</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        EpochError : if input invalid</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :class:`datetime.datetime`</span>
<span class="sd">            date and time corresponding to epoch. Invalid values are set to</span>
<span class="sd">            usual epoch invalid value, i.e. last moment of year 9999.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_tt2000_to_datetime</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yyyy</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hh</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">msec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">usec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nsec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">breakdownTT2000</span><span class="p">(</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">(</span><span class="n">tt2000</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">yyyy</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">dd</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hh</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="nb">min</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">sec</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">msec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">usec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">nsec</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">yyyy</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
        <span class="n">sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sec</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sec</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
        <span class="n">micro</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">msec</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="n">usec</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">nsec</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">micro</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">sec</span><span class="p">,</span> <span class="n">micro</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">add_sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">micro</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">sec</span><span class="p">,</span>
                    <span class="n">micro</span> <span class="o">-</span> <span class="n">add_sec</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">add_sec</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">MAXYEAR</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span>
                                         <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span></div>

<div class="viewcode-block" id="Library.datetime_to_tt2000"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.datetime_to_tt2000">[docs]</a>    <span class="k">def</span> <span class="nf">datetime_to_tt2000</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a Python datetime to a CDF TT2000 value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        dt :  :class:`datetime.datetime`</span>
<span class="sd">            date and time to convert</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            tt2000 corresponding to dt</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_datetime_to_tt2000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">tzinfo</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dt</span>  <span class="o">==</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">63</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeTT2000</span><span class="p">(</span>
            <span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span>
            <span class="n">dt</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">second</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">),</span>
            <span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_datetime_to_tt2000_typepunned</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a Python datetime to a CDF TT2000 value</span>

<span class="sd">        Typepunned version that passes doubles as longlongs, to get around</span>
<span class="sd">        ARM calling convention oddness.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        dt :  :class:`datetime.datetime`</span>
<span class="sd">            date and time to convert</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            tt2000 corresponding to dt</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_datetime_to_tt2000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c_ll_p</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">tzinfo</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dt</span>  <span class="o">==</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">63</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeTT2000</span><span class="p">(</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="n">dt</span><span class="o">.</span><span class="n">day</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="n">dt</span><span class="o">.</span><span class="n">hour</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="n">dt</span><span class="o">.</span><span class="n">minute</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="n">dt</span><span class="o">.</span><span class="n">second</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">//</span> <span class="mi">1000</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">)),</span> <span class="n">c_ll_p</span><span class="p">)</span><span class="o">.</span><span class="n">contents</span><span class="p">)</span>

<div class="viewcode-block" id="Library.epoch_to_tt2000"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.epoch_to_tt2000">[docs]</a>    <span class="k">def</span> <span class="nf">epoch_to_tt2000</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF EPOCH to a CDF TT2000 value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch : double</span>
<span class="sd">            EPOCH to convert</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            tt2000 corresponding to epoch</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_epoch_to_tt2000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span></div>

<div class="viewcode-block" id="Library.tt2000_to_epoch"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.tt2000_to_epoch">[docs]</a>    <span class="k">def</span> <span class="nf">tt2000_to_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tt2000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF TT2000 value to a CDF EPOCH</span>

<span class="sd">        .. note::</span>
<span class="sd">            Although TT2000 values support leapseconds, CDF EPOCH values</span>
<span class="sd">            do not. Times during leapseconds are rounded up to beginning</span>
<span class="sd">            of the next day.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        tt2000 : int</span>
<span class="sd">            TT2000 value from CDF</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        EpochError : if input invalid</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : double</span>
<span class="sd">            EPOCH corresponding to the TT2000 input time</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_tt2000_to_epoch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH</span><span class="p">(</span><span class="n">tt2000</span><span class="p">)</span></div>

<div class="viewcode-block" id="Library.epoch16_to_tt2000"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.epoch16_to_tt2000">[docs]</a>    <span class="k">def</span> <span class="nf">epoch16_to_tt2000</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch0</span><span class="p">,</span> <span class="n">epoch1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF epoch16 value to TT2000</span>

<span class="sd">        .. note::</span>
<span class="sd">            Because TT2000 does not support picoseconds, the picoseconds</span>
<span class="sd">            value in epoch is ignored (i.e., truncated.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch0 : float</span>
<span class="sd">            epoch16 value from CDF, first half</span>
<span class="sd">        epoch1 : float</span>
<span class="sd">            epoch16 value from CDF, second half</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        EpochError : if input invalid</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : long</span>
<span class="sd">            TT2000 corresponding to epoch.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_epoch16_to_tt2000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH16</span><span class="p">(</span>
            <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)(</span><span class="n">epoch0</span><span class="p">,</span> <span class="n">epoch1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Library.tt2000_to_epoch16"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.tt2000_to_epoch16">[docs]</a>    <span class="k">def</span> <span class="nf">tt2000_to_epoch16</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tt2000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF TT2000 value to a CDF EPOCH16</span>

<span class="sd">        .. note::</span>
<span class="sd">            Although TT2000 values support leapseconds, CDF EPOCH16 values</span>
<span class="sd">            do not. Times during leapseconds are rounded up to beginning</span>
<span class="sd">            of the next day.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        tt2000 : int</span>
<span class="sd">            TT2000 value from CDF</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        EpochError : if input invalid</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : double, double</span>
<span class="sd">            EPOCH16 corresponding to the TT2000 input time</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_tt2000_to_epoch16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Default to &quot;illegal epoch&quot; if isn&#39;t populated</span>
        <span class="n">epoch16</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH16</span><span class="p">(</span><span class="n">tt2000</span><span class="p">,</span> <span class="n">epoch16</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span> <span class="c1">#Failure; illegal epoch</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">epoch16</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">epoch16</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_bad_tt2000</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenience function for complaining that TT2000 not supported&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;TT2000 functions require CDF library 3.4.0 or later&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Library.get_minmax"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Library.html#spacepy.pycdf.Library.get_minmax">[docs]</a>    <span class="k">def</span> <span class="nf">get_minmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdftype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find minimum, maximum possible value based on CDF type.</span>

<span class="sd">        This returns the processed value (e.g. datetimes for Epoch</span>
<span class="sd">        types) because comparisons to EPOCH16s are otherwise</span>
<span class="sd">        difficult.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        cdftype : int</span>
<span class="sd">            CDF type number from :mod:`~spacepy.pycdf.const`</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        ValueError : if can&#39;t match the type</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : tuple</span>
<span class="sd">            minimum, maximum value supported by type (of type matching the</span>
<span class="sd">            CDF type).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cdftype</span> <span class="o">=</span> <span class="n">cdftype</span><span class="o">.</span><span class="n">value</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">pycdf</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="c1">#Can get asymptotically closer, but why bother</span>
                <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">pycdf</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">pycdf</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">inf</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="c1">#Using actual min results in invalid/fill value</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_datetime</span><span class="p">(</span><span class="n">inf</span><span class="o">.</span><span class="n">min</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_datetime</span><span class="p">(</span><span class="n">inf</span><span class="o">.</span><span class="n">max</span><span class="p">))</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">pycdf</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cdftype</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown data type: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cdftype</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">inf</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
            <span class="n">inf</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown data type: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cdftype</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">inf</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">inf</span><span class="o">.</span><span class="n">max</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">download_library</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Download and install the CDF library&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;CDF library install only supported on Windows&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">html.parser</span> <span class="k">as</span> <span class="nn">HTMLParser</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">HTMLParser</span>
    <span class="c1">#https://stackoverflow.com/questions/1713038/super-fails-with-error-typeerror-argument-1-must-be-type-not-classobj</span>
    <span class="k">class</span> <span class="nc">LinkParser</span><span class="p">(</span><span class="n">HTMLParser</span><span class="o">.</span><span class="n">HTMLParser</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_found</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">LinkParser</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">handle_starttag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="o">!=</span> <span class="s1">&#39;a&#39;</span> <span class="ow">or</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;href&#39;</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="kn">import</span> <span class="nn">re</span>
    <span class="kn">import</span> <span class="nn">subprocess</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">urllib.request</span> <span class="k">as</span> <span class="nn">u</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">urllib</span> <span class="k">as</span> <span class="nn">u</span>
    <span class="kn">import</span> <span class="nn">spacepy</span>
    <span class="k">if</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;user_agent&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">class</span> <span class="nc">AppURLopener</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">):</span>
            <span class="n">version</span> <span class="o">=</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;user_agent&#39;</span><span class="p">]</span>
        <span class="n">u</span><span class="o">.</span><span class="n">_urlopener</span> <span class="o">=</span> <span class="n">AppURLopener</span><span class="p">()</span>
    <span class="n">baseurl</span> <span class="o">=</span> <span class="s1">&#39;https://spdf.sci.gsfc.nasa.gov/pub/software/cdf/dist/&#39;</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">baseurl</span><span class="p">)</span>
    <span class="n">listing</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">url</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">LinkParser</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="n">listing</span><span class="p">)</span>
    <span class="n">cdfdist</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">links_found</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;^cdf3\d_\d(?:_\d)?/$&#39;</span><span class="p">,</span> <span class="n">l</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cdfdist</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;Couldn&#39;t find CDF distribution directory to download&quot;</span><span class="p">)</span>
    <span class="n">cdfdist</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">))</span>
    <span class="n">cdfverbase</span> <span class="o">=</span> <span class="n">cdfdist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">instfname</span> <span class="o">=</span> <span class="n">cdfverbase</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;_0&#39;</span> <span class="k">if</span> <span class="n">cdfverbase</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> \
                <span class="s1">&#39;-setup-</span><span class="si">{0}</span><span class="s1">.exe&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">insturl</span> <span class="o">=</span> <span class="n">baseurl</span> <span class="o">+</span> <span class="n">cdfverbase</span> <span class="o">+</span> <span class="s1">&#39;/windows/&#39;</span> <span class="o">+</span> <span class="n">instfname</span>
    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">fname</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="n">insturl</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span> <span class="n">instfname</span><span class="p">))</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">check_call</span><span class="p">([</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;/install&#39;</span><span class="p">,</span> <span class="s1">&#39;/q1&#39;</span><span class="p">],</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>

<span class="n">_libpath</span><span class="p">,</span> <span class="n">_library</span> <span class="o">=</span> <span class="n">Library</span><span class="o">.</span><span class="n">_find_lib</span><span class="p">()</span>
<span class="k">if</span> <span class="n">_library</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">((</span><span class="s1">&#39;Cannot load CDF C library; checked </span><span class="si">{0}</span><span class="s1">. &#39;</span>
                     <span class="s1">&#39;Try </span><span class="se">\&#39;</span><span class="s1">os.environ[&quot;CDF_LIB&quot;] = library_directory</span><span class="se">\&#39;</span><span class="s1"> &#39;</span>
                     <span class="s1">&#39;before import.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_libpath</span><span class="p">)))</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">const</span>
<span class="n">lib</span> <span class="o">=</span> <span class="n">Library</span><span class="p">(</span><span class="n">_libpath</span><span class="p">,</span> <span class="n">_library</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Module global library object.</span>

<span class="sd">Initalized at module load time so all classes have ready</span>
<span class="sd">access to the CDF library and a common state. E.g:</span>
<span class="sd">    &gt;&gt;&gt; from spacepy import pycdf</span>
<span class="sd">    &gt;&gt;&gt; pycdf.lib.version</span>
<span class="sd">        (3, 3, 0, &#39; &#39;)</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="CDFException"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDFException.html#spacepy.pycdf.CDFException">[docs]</a><span class="k">class</span> <span class="nc">CDFException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for errors or warnings in the CDF library.</span>

<span class="sd">    Not normally used directly, but in subclasses :class:`CDFError`</span>
<span class="sd">    and :class:`CDFWarning`.</span>

<span class="sd">    Error messages provided by this class are looked up from the underlying</span>
<span class="sd">    C library.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a CDF Exception</span>

<span class="sd">        Uses CDF C library to look up an appropriate error message.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        status : ctypes.c_long</span>
<span class="sd">            CDF status</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;CDF error &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, unable to get details.&#39;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_STATUSTEXT_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFlib</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_STATUS_</span><span class="p">,</span>
                                         <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">status</span><span class="p">),</span>
                                         <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">STATUS_TEXT_</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span>
                                         <span class="n">const</span><span class="o">.</span><span class="n">NULL_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">retval</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_OK</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">value</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Error string associated with the library error.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : str</span>
<span class="sd">            Error message from the CDF library.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span></div>


<div class="viewcode-block" id="CDFError"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDFError.html#spacepy.pycdf.CDFError">[docs]</a><span class="k">class</span> <span class="nc">CDFError</span><span class="p">(</span><span class="n">CDFException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised for an error in the CDF library.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="CDFWarning"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDFWarning.html#spacepy.pycdf.CDFWarning">[docs]</a><span class="k">class</span> <span class="nc">CDFWarning</span><span class="p">(</span><span class="n">CDFException</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used for a warning in the CDF library.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">warn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Issues a warning based on the information stored in my exception</span>

<span class="sd">        Intended for use in check_status or similar wrapper function.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        level : int</span>
<span class="sd">            optional (default 3), how far up the stack the warning should</span>
<span class="sd">            be reported. Passed directly to :class:`warnings.warn`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span></div>


<div class="viewcode-block" id="EpochError"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.EpochError.html#spacepy.pycdf.EpochError">[docs]</a><span class="k">class</span> <span class="nc">EpochError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used for errors in epoch routines&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="k">def</span> <span class="nf">_compress</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">comptype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set or check the compression of a :py:class:`pycdf.CDF` or :py:class:`pycdf.Var`</span>

<span class="sd">    @param obj: object on which to set or check compression</span>
<span class="sd">    @type obj: :py:class:`pycdf.CDF` or :py:class:`pycdf.Var`</span>
<span class="sd">    @param comptype: type of compression to change to, see CDF C reference</span>
<span class="sd">                     manual section 4.10. Constants for this parameter</span>
<span class="sd">                     are in :py:mod:`pycdf.const`. If not specified, will not change</span>
<span class="sd">                     compression.</span>
<span class="sd">    @type comptype: ctypes.c_long</span>
<span class="sd">    @param param: Compression parameter, see CDF CRM 4.10 and :py:mod:`pycdf.const`.</span>
<span class="sd">                  If not specified, will choose reasonable default (5 for</span>
<span class="sd">                  gzip; other types have only one possible parameter.)</span>
<span class="sd">    @type param: ctypes.c_long</span>
<span class="sd">    @return: (comptype, param) currently in effect</span>
<span class="sd">    @rtype: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">CDF</span><span class="p">):</span>
        <span class="n">COMPRESSION_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_COMPRESSION_</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
        <span class="n">COMPRESSION_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_COMPRESSION_</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must specify a CDF or Var type.&#39;</span><span class="p">)</span>

    <span class="n">validparams</span> <span class="o">=</span> <span class="p">{</span><span class="n">const</span><span class="o">.</span><span class="n">NO_COMPRESSION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">RLE_COMPRESSION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">RLE_OF_ZEROs</span><span class="p">],</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">HUFF_COMPRESSION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                       <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">OPTIMAL_ENCODING_TREES</span><span class="p">],</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">AHUFF_COMPRESSION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                       <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">OPTIMAL_ENCODING_TREES</span><span class="p">],</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">GZIP_COMPRESSION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span>
                                                  <span class="p">],</span>
                   <span class="p">}</span>
    <span class="n">comptypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">NO_COMPRESSION</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">RLE_COMPRESSION</span><span class="p">,</span>
                 <span class="n">const</span><span class="o">.</span><span class="n">HUFF_COMPRESSION</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">AHUFF_COMPRESSION</span><span class="p">,</span>
                 <span class="n">const</span><span class="o">.</span><span class="n">GZIP_COMPRESSION</span><span class="p">]</span>
    <span class="n">comptypevalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comptypes</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">comptype</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">comptype</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">):</span>
            <span class="n">comptype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">comptype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">comptype</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">validparams</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_COMPRESSION</span><span class="p">)</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">validparams</span><span class="p">[</span><span class="n">comptype</span><span class="o">.</span><span class="n">value</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">paramlist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)(</span><span class="n">param</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">COMPRESSION_</span><span class="p">,</span>
                   <span class="n">comptype</span><span class="p">,</span> <span class="n">paramlist</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span>
              <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAX_PARMS</span><span class="p">)(</span><span class="o">*</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAX_PARMS</span><span class="p">))</span>
    <span class="n">comptype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">percent</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">COMPRESSION_</span><span class="p">,</span>
               <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">comptype</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">params</span><span class="p">),</span>
               <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">percent</span><span class="p">))</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">comptype</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">comptypevalues</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_COMPRESSION</span><span class="p">)</span>
    <span class="n">validparamvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">validparams</span><span class="p">[</span><span class="n">comptype</span><span class="o">.</span><span class="n">value</span><span class="p">]]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">validparamvalues</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_COMPRESSION_PARM</span><span class="p">)</span>
    <span class="n">comptype</span> <span class="o">=</span> <span class="n">comptypes</span><span class="p">[</span><span class="n">comptypevalues</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">comptype</span><span class="o">.</span><span class="n">value</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">comptype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">RLE_COMPRESSION</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">HUFF_COMPRESSION</span><span class="p">,</span>
                    <span class="n">const</span><span class="o">.</span><span class="n">AHUFF_COMPRESSION</span><span class="p">):</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">validparams</span><span class="p">[</span><span class="n">comptype</span><span class="o">.</span><span class="n">value</span><span class="p">][</span><span class="n">validparamvalues</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">param</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">comptype</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>


<div class="viewcode-block" id="CDF"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF">[docs]</a><span class="k">class</span> <span class="nc">CDF</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">,</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">datamodel</span><span class="o">.</span><span class="n">MetaMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Python object representing a CDF file.</span>

<span class="sd">    Open or create a CDF file by creating an object of this class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    pathname : string</span>
<span class="sd">        name of the file to open or create</span>
<span class="sd">    masterpath : string</span>
<span class="sd">        name of the master CDF file to use in creating</span>
<span class="sd">        a new file. If not provided, an existing file is</span>
<span class="sd">        opened; if provided but evaluates to ``False``</span>
<span class="sd">        (e.g., ``&#39;&#39;``), an empty new CDF is created.</span>
<span class="sd">    create : bool</span>
<span class="sd">        Create a new CDF even if masterpath isn&#39;t provided</span>
<span class="sd">    readonly : bool</span>
<span class="sd">        Open the CDF read-only. Default True if opening an</span>
<span class="sd">        existing CDF; False if creating a new one. A readonly</span>
<span class="sd">        CDF with many variables may be slow to close. See</span>
<span class="sd">        :meth:`readonly`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ======</span>
<span class="sd">    CDFError</span>
<span class="sd">        if CDF library reports an error</span>

<span class="sd">    Warns</span>
<span class="sd">    =====</span>
<span class="sd">    CDFWarning</span>
<span class="sd">        if CDF library reports a warning and interpreter</span>
<span class="sd">        is set to error on warnings.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>
<span class="sd">    Open a CDF by creating a CDF object, e.g.:</span>

<span class="sd">        &gt;&gt;&gt; cdffile = pycdf.CDF(&#39;cdf_filename.cdf&#39;)</span>

<span class="sd">    Be sure to :meth:`close` or :meth:`save` when</span>
<span class="sd">    done.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Existing CDF files are opened read-only by default, see</span>
<span class="sd">        :meth:`readonly` to change.</span>

<span class="sd">    CDF supports the `with</span>
<span class="sd">    &lt;http://docs.python.org/tutorial/inputoutput.html#methods-of-file-objects&gt;`_</span>
<span class="sd">    keyword, like other file objects, so:</span>

<span class="sd">        &gt;&gt;&gt; with pycdf.CDF(&#39;cdf_filename.cdf&#39;) as cdffile:</span>
<span class="sd">        ...     #do brilliant things with the CDF</span>

<span class="sd">    will open the CDF, execute the indented statements, and close the CDF when</span>
<span class="sd">    finished or when an error occurs. The `python docs</span>
<span class="sd">    &lt;http://docs.python.org/reference/compound_stmts.html#with&gt;`_ include more</span>
<span class="sd">    detail on this &#39;context manager&#39; ability.</span>

<span class="sd">    CDF objects behave like a python `dictionary</span>
<span class="sd">    &lt;http://docs.python.org/tutorial/datastructures.html#dictionaries&gt;`_,</span>
<span class="sd">    where the keys are names of variables in the CDF, and the values,</span>
<span class="sd">    :class:`Var` objects. As a dictionary, they are also `iterable</span>
<span class="sd">    &lt;http://docs.python.org/tutorial/classes.html#iterators&gt;`_ and it is easy</span>
<span class="sd">    to loop over all of the variables in a file. Some examples:</span>

<span class="sd">        #. List the names of all variables in the open CDF ``cdffile``:</span>

<span class="sd">               &gt;&gt;&gt; cdffile.keys()</span>
<span class="sd">               &gt;&gt;&gt; for k in cdffile: #Alternate</span>
<span class="sd">               ...     print(k)</span>

<span class="sd">        #. Get a :class:`Var` object for the variable named ``Epoch``:</span>

<span class="sd">               &gt;&gt;&gt; epoch = cdffile[&#39;Epoch&#39;]</span>

<span class="sd">        #. Determine if a CDF contains a variable named ``B_GSE``:</span>

<span class="sd">               &gt;&gt;&gt; if &#39;B_GSE&#39; in cdffile:</span>
<span class="sd">               ...     print(&#39;B_GSE is in the file&#39;)</span>
<span class="sd">               ... else:</span>
<span class="sd">               ...     print(&#39;B_GSE is not in the file&#39;)</span>

<span class="sd">        #. Find how many variables are in the file:</span>

<span class="sd">               &gt;&gt;&gt; print(len(cdffile))</span>

<span class="sd">        #. Delete the variable ``Epoch`` from the open CDF file ``cdffile``:</span>

<span class="sd">              &gt;&gt;&gt; del cdffile[&#39;Epoch&#39;]</span>

<span class="sd">        #. Display a summary of variables and types in open CDF file ``cdffile``:</span>

<span class="sd">              &gt;&gt;&gt; print(cdffile)</span>

<span class="sd">        #. Open the CDF named ``cdf_filename.cdf``, read *all* the data from</span>
<span class="sd">           all variables into dictionary ``data``, and close it when done or</span>
<span class="sd">           if an error occurs:</span>

<span class="sd">               &gt;&gt;&gt; with pycdf.CDF(&#39;cdf_filename.cdf&#39;) as cdffile:</span>
<span class="sd">               ...     data = cdffile.copy()</span>


<span class="sd">    This last example can be very inefficient as it reads the entire CDF.</span>
<span class="sd">    Normally it&#39;s better to treat the CDF as a dictionary and access only</span>
<span class="sd">    the data needed, which will be pulled transparently from disc. See</span>
<span class="sd">    :class:`Var` for more subtle examples.</span>

<span class="sd">    Potentially useful dictionary methods and related functions:</span>

<span class="sd">      - `in &lt;http://docs.python.org/reference/expressions.html#in&gt;`_</span>
<span class="sd">      - `keys &lt;http://docs.python.org/tutorial/datastructures.html#dictionaries&gt;`_</span>
<span class="sd">      - :py:func:`len`</span>
<span class="sd">      - `list comprehensions</span>
<span class="sd">        &lt;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&gt;`_</span>
<span class="sd">      - :py:func:`sorted`</span>
<span class="sd">      - :py:func:`~spacepy.toolbox.dictree`</span>

<span class="sd">    The CDF user&#39;s guide section 2.2 has more background information on CDF</span>
<span class="sd">    files.</span>

<span class="sd">    The :attr:`~CDF.attrs` Python attribute acts as a dictionary</span>
<span class="sd">    referencing CDF attributes (do not confuse the two); all the</span>
<span class="sd">    dictionary methods above also work on the attribute dictionary.</span>
<span class="sd">    See :class:`gAttrList` for more on the dictionary of global</span>
<span class="sd">    attributes.</span>

<span class="sd">    Creating a new CDF from a master (skeleton) CDF has similar syntax to</span>
<span class="sd">    opening one:</span>

<span class="sd">        &gt;&gt;&gt; cdffile = pycdf.CDF(&#39;cdf_filename.cdf&#39;, &#39;master_cdf_filename.cdf&#39;)</span>

<span class="sd">    This creates and opens ``cdf_filename.cdf`` as a copy of</span>
<span class="sd">    ``master_cdf_filename.cdf``.</span>

<span class="sd">    Using a skeleton CDF is recommended over making a CDF entirely from</span>
<span class="sd">    scratch, but this is possible by specifying a blank master:</span>

<span class="sd">        &gt;&gt;&gt; cdffile = pycdf.CDF(&#39;cdf_filename.cdf&#39;, &#39;&#39;)</span>

<span class="sd">    When CDFs are created in this way, they are opened read-write, see</span>
<span class="sd">    :py:meth:`readonly` to change.</span>

<span class="sd">    By default, new CDFs (without a master) are created in version 2</span>
<span class="sd">    (backward-compatible) format. To create a version 3 CDF, use</span>
<span class="sd">    :meth:`Library.set_backward`:</span>

<span class="sd">        &gt;&gt;&gt; pycdf.lib.set_backward(False)</span>
<span class="sd">        &gt;&gt;&gt; cdffile = pycdf.CDF(&#39;cdf_filename.cdf&#39;, &#39;&#39;)</span>

<span class="sd">    Add variables by direct assignment, which will automatically set type</span>
<span class="sd">    and dimension based on the data provided:</span>

<span class="sd">        &gt;&gt;&gt; cdffile[&#39;new_variable_name&#39;] = [1, 2, 3, 4]</span>

<span class="sd">    or, if more control is needed over the type and dimensions, use</span>
<span class="sd">    :py:meth:`new`.</span>

<span class="sd">    Although it is supported to assign Var objects to Python variables</span>
<span class="sd">    for convenience, there are some minor pitfalls that can arise when</span>
<span class="sd">    changing a CDF that will not affect most users. This is only a</span>
<span class="sd">    concern when assigning a zVar object to a Python variable, changing the</span>
<span class="sd">    CDF through some other variable, and then trying to use the zVar</span>
<span class="sd">    object via the originally assigned variable.</span>

<span class="sd">    Deleting a variable:</span>

<span class="sd">        &gt;&gt;&gt; var = cdffile[&#39;Var1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; del cdffile[&#39;Var1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; var[0] #fail, no such variable</span>

<span class="sd">    Renaming a variable:</span>

<span class="sd">        &gt;&gt;&gt; var = cdffile[&#39;Var1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; cdffile[&#39;Var1&#39;].rename(&#39;Var2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; var[0] #fail, no such variable</span>

<span class="sd">    Renaming via the same variable works:</span>

<span class="sd">        &gt;&gt;&gt; var = cdffile[&#39;Var1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; var.rename(&#39;Var2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; var[0] #succeeds, aware of new name</span>

<span class="sd">    Deleting a variable and then creating another variable with the same name</span>
<span class="sd">    may lead to some surprises:</span>

<span class="sd">        &gt;&gt;&gt; var = cdffile[&#39;Var1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; var[...] = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; del cdffile[&#39;Var1&#39;]</span>
<span class="sd">        &gt;&gt;&gt; cdffile.new(&#39;Var1&#39;, data=[5, 6, 7, 8]</span>
<span class="sd">        &gt;&gt;&gt; var[...]</span>
<span class="sd">        [5, 6, 7, 8]</span>

<span class="sd">    .. autosummary::</span>

<span class="sd">        ~CDF.attr_num</span>
<span class="sd">        ~CDF.attrs</span>
<span class="sd">        ~CDF.add_attr_to_cache</span>
<span class="sd">        ~CDF.add_to_cache</span>
<span class="sd">        ~CDF.backward</span>
<span class="sd">        ~CDF.checksum</span>
<span class="sd">        ~CDF.clear_attr_from_cache</span>
<span class="sd">        ~CDF.clear_from_cache</span>
<span class="sd">        ~CDF.clone</span>
<span class="sd">        ~CDF.close</span>
<span class="sd">        ~CDF.col_major</span>
<span class="sd">        ~CDF.compress</span>
<span class="sd">        ~CDF.copy</span>
<span class="sd">        ~CDF.from_data</span>
<span class="sd">        ~CDF.new</span>
<span class="sd">        ~CDF.raw_var</span>
<span class="sd">        ~CDF.readonly</span>
<span class="sd">        ~CDF.save</span>
<span class="sd">        ~CDF.var_num</span>
<span class="sd">        ~CDF.version</span>

<span class="sd">    .. attribute:: CDF.attrs</span>

<span class="sd">       Global attributes for this CDF in a dict-like format.</span>
<span class="sd">       See :class:`gAttrList` for details.</span>

<span class="sd">    .. attribute:: CDF.backward</span>

<span class="sd">       True if this CDF was created in backward-compatible mode</span>
<span class="sd">       (for opening with CDF library before 3.x)</span>

<span class="sd">    .. automethod:: add_to_cache</span>
<span class="sd">    .. automethod:: add_attr_to_cache</span>
<span class="sd">    .. automethod:: attr_num</span>
<span class="sd">    .. automethod:: checksum</span>
<span class="sd">    .. automethod:: clear_from_cache</span>
<span class="sd">    .. automethod:: clear_attr_from_cache</span>
<span class="sd">    .. automethod:: clone</span>
<span class="sd">    .. automethod:: close</span>
<span class="sd">    .. automethod:: col_major</span>
<span class="sd">    .. automethod:: compress</span>
<span class="sd">    .. automethod:: copy</span>
<span class="sd">    .. automethod:: from_data</span>
<span class="sd">    .. automethod:: new</span>
<span class="sd">    .. automethod:: raw_var</span>
<span class="sd">    .. automethod:: readonly</span>
<span class="sd">    .. automethod:: save</span>
<span class="sd">    .. automethod:: var_num</span>
<span class="sd">    .. automethod:: version</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">masterpath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open or create a CDF file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        pathname : string</span>
<span class="sd">            name of the file to open or create</span>
<span class="sd">        masterpath : string</span>
<span class="sd">            name of the master CDF file to use in creating</span>
<span class="sd">            a new file. If not provided, an existing file is</span>
<span class="sd">            opened; if provided but evaluates to ``False``</span>
<span class="sd">            (e.g., ``&#39;&#39;``), an empty new CDF is created.</span>
<span class="sd">        create : bool</span>
<span class="sd">            Create a new CDF even if masterpath isn&#39;t provided</span>
<span class="sd">        readonly : bool</span>
<span class="sd">            Open the CDF read-only. Default True if opening an</span>
<span class="sd">            existing CDF; False if creating a new one.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError</span>
<span class="sd">            if CDF library reports an error</span>
<span class="sd">        CDFWarning</span>
<span class="sd">            if CDF library reports a warning and interpreter</span>
<span class="sd">            is set to error on warnings.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        Open a CDF by creating a CDF object, e.g.:</span>
<span class="sd">            &gt;&gt;&gt; cdffile = pycdf.CDF(&#39;cdf_filename.cdf&#39;)</span>
<span class="sd">        Be sure to :py:meth:`pycdf.CDF.close` or :py:meth:`pycdf.CDF.save`</span>
<span class="sd">        when done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">masterpath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#Looks like we want to create</span>
            <span class="k">if</span> <span class="n">create</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot specify a master CDF without creating a CDF&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">readonly</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot create a CDF in readonly mode&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">create</span> <span class="ow">and</span> <span class="n">readonly</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot create a CDF in readonly mode&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="o">=</span> <span class="n">pathname</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;pathname must be string-like: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pathname</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">masterpath</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">create</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">(</span><span class="kc">True</span> <span class="k">if</span> <span class="n">readonly</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">readonly</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">masterpath</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_master</span><span class="p">(</span><span class="n">masterpath</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create</span><span class="p">()</span>
        <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_zMODE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">gAttrList</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_nums</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;Cache of name-to-number mappings for variables in this CDF&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attr_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;Cache of name-to-(number, global) mappings for attributes</span>
<span class="sd">        in this CDF&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Destructor; called when CDF object is destroyed.</span>

<span class="sd">        Close CDF file if there is still a valid handle.</span>
<span class="sd">        .. note::</span>
<span class="sd">            To avoid data loss, explicitly call :py:meth:`pycdf.CDF.close` </span>
<span class="sd">            or :py:meth:`pycdf.CDF.save`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a zVariable in this CDF, by name or number</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        name : string or int</span>
<span class="sd">            Name or number of the CDF variable</span>
<span class="sd">        .. note:</span>
<span class="sd">            Variable numbers may change if variables are added or removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        Delete the variable ``Epoch`` from the open CDF file ``cdffile``.</span>
<span class="sd">            &gt;&gt;&gt; del cdffile[&#39;Epoch&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_delete</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Context manager entrance function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Context manager exit function.</span>

<span class="sd">        Close CDF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets a zVariable in this CDF, by name or number</span>

<span class="sd">        The CDF acts like a dict</span>

<span class="sd">        @param name: Name or number of the CDF variable</span>
<span class="sd">        @type name: string or int</span>
<span class="sd">        @return: CDF variable named or numbered L{name}</span>
<span class="sd">        @rtype: :py:class:`pycdf.Var`</span>
<span class="sd">        @raise KeyError: for pretty much any problem in lookup</span>
<span class="sd">        @note: variable numbers may change if variables are added or removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CDFException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes data to a zVariable in this CDF</span>

<span class="sd">        If the zVariable does not exist, will create one matching</span>
<span class="sd">        L{data}. If it does exist, will attempt to write L{data}</span>
<span class="sd">        to it without changing the type or dimensions.</span>

<span class="sd">        @param name: name or number of the variable to write</span>
<span class="sd">        @type name: str or int</span>
<span class="sd">        @param data: data to write, or a :py:class:`pycdf.Var` to copy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;attrs&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterates over zVars in CDF</span>

<span class="sd">        Iterators for dicts return keys</span>
<span class="sd">        @note: Returned in variable-number order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span><span class="p">():</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">_num</span><span class="p">()</span>
                <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements &#39;length&#39; of CDF (number of zVars)</span>

<span class="sd">        @return: number of zVars in the CDF</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_NUMzVARS_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines whether a particular variable name is in the CDF</span>

<span class="sd">        @note: Essentially an efficiency function; L{__iter__} is called</span>
<span class="sd">               if this isn&#39;t defined</span>
<span class="sd">        @param key: key/variable name to check</span>
<span class="sd">        @type key: string</span>
<span class="sd">        @return: True if L{key} is the name of a variable in CDF, else False</span>
<span class="sd">        @rtype: Boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">str</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bytes</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_nums</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CONFIRM_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_EXISTENCE_</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                            <span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_VAR</span><span class="p">,))</span>
        <span class="k">return</span> <span class="n">status</span> <span class="o">!=</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_VAR</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns representation of CDF</span>

<span class="sd">        Cannot return anything that can be eval&#39;d to create a copy of the</span>
<span class="sd">        CDF, so just wrap the informal representation in angle brackets.</span>
<span class="sd">        @return: all the data in this list of attributes</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;CDF:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string representation of the CDF</span>

<span class="sd">        This is an &#39;informal&#39; representation in that it cannot be evaluated</span>
<span class="sd">        directly to create a :py:class:`pycdf.CDF`, just the names, types, and sizes of all</span>
<span class="sd">        variables. (Attributes are not listed.)</span>

<span class="sd">        @return: description of the variables in the CDF</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                              <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>
            <span class="c1">#can get away with this sort because second value in tuple isn&#39;t</span>
            <span class="c1">#compared unless first are different, and variable name is unique.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;Closed CDF </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Closed CDF </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Opens the CDF file (called on init)</span>

<span class="sd">        Will open an existing CDF file read/write.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>
<span class="sd">        CDFWarning : if CDF library reports a warning and interpreter</span>
<span class="sd">                     is set to error on warnings.</span>
<span class="sd">        .. note:</span>
<span class="sd">            Not intended for direct call; pass parameters to</span>
<span class="sd">            :py:class:`pycdf.CDF` constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">OPEN_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">readonly</span><span class="p">:</span> <span class="c1">#Default is RW</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">readonly</span><span class="p">(</span><span class="n">readonly</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates (and opens) a new CDF file</span>

<span class="sd">        Created at ``pathname``.</span>
<span class="sd">        Assumes zero-dimension r variables</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>
<span class="sd">        CDFWarning : if CDF library reports a warning and interpreter</span>
<span class="sd">                     is set to error on warnings.</span>
<span class="sd">        .. note:</span>
<span class="sd">            Not intended for direct call; pass parameters to</span>
<span class="sd">            :py:class:`pycdf.CDF` constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">_explicit_backward</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;spacepy.pycdf.lib.set_backward not called;&#39;</span>
                <span class="s1">&#39; making backward-compatible CDF.&#39;</span>
                <span class="s1">&#39; This default will change in the future.&#39;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CREATE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                              <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)(</span><span class="mi">0</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_from_master</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new CDF from a master CDF file</span>

<span class="sd">        ``master_path`` is copied to ``pathname`` and opened.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        master_path : string</span>
<span class="sd">            location of the master CDF file</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>
<span class="sd">        CDFWarning : if CDF library reports a warning and interpreter</span>
<span class="sd">                     is set to error on warnings.</span>
<span class="sd">        .. note:</span>
<span class="sd">            Not intended for direct call; pass parameters to</span>
<span class="sd">            :py:class:`pycdf.CDF` constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EXISTS</span><span class="p">)</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">copy2</span><span class="p">(</span><span class="n">master_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="CDF.from_data"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.from_data">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">sd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new CDF file from a SpaceData object or similar</span>

<span class="sd">        The CDF named ``filename`` is created, opened, filled with the</span>
<span class="sd">        contents of ``sd`` (including attributes), and closed.</span>

<span class="sd">        ``sd`` should be a dictionary-like object; each key will be made</span>
<span class="sd">        into a variable name. An attribute called ``attrs``, if it exists,</span>
<span class="sd">        will be made into global attributes for the CDF.</span>

<span class="sd">        Each value of ``sd`` should be array-like and will be used as</span>
<span class="sd">        the contents of the variable; an attribute called ``attrs``, if</span>
<span class="sd">        it exists, will be made into attributes for that variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">            name of the file to create</span>
<span class="sd">        sd : spacepy.datamodel.SpaceData</span>
<span class="sd">            data to put in the CDF. This structure cannot be nested,</span>
<span class="sd">            i.e., it must contain only :class:`~spacepy.datamodel.dmarray`</span>
<span class="sd">            and no :class:`~spacepy.datamodel.Spacedata` objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">cls</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cdffile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sd</span><span class="p">:</span>
                <span class="n">cdffile</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">cdffile</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select this CDF as current and call the CDF internal interface</span>

<span class="sd">        Adds call to select this CDF to L{args} and passes all parameters</span>
<span class="sd">        directly through to the CDFlib routine of the CDF library&#39;s C internal</span>
<span class="sd">        interface. Checks the return value with L{Library.check_status}.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        args : various, see :py:mod:`ctypes`.</span>
<span class="sd">            Passed directly to the CDF library interface. Useful</span>
<span class="sd">            constants are defined in the :doc:`const &lt;pycdf_const&gt;`</span>
<span class="sd">            module of this package.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : ctypes.c_long</span>
<span class="sd">            CDF status from the library</span>

<span class="sd">        .. note:</span>
<span class="sd">            Terminal NULL_ is automatically added to ``args``.</span>
<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>
<span class="sd">        CDFWarning : if CDF library reports a warning and interpreter</span>
<span class="sd">                     is set to error on warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="CDF.clone"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zVar</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clone a zVariable (from another CDF or this) into this CDF</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        zVar : :py:class:`Var`</span>
<span class="sd">            variable to clone</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the new variable (default: name of the original)</span>
<span class="sd">        data : boolean (optional)</span>
<span class="sd">            Copy data, or only type, dimensions, variance, attributes?</span>
<span class="sd">            (default: True, copy data as well)</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :py:class:`Var`</span>
<span class="sd">            The newly-created zVar in this CDF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">zVar</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">zVar</span><span class="o">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">recVary</span><span class="o">=</span><span class="n">zVar</span><span class="o">.</span><span class="n">rv</span><span class="p">(),</span>
                 <span class="n">dimVarys</span><span class="o">=</span><span class="n">zVar</span><span class="o">.</span><span class="n">dv</span><span class="p">(),</span> <span class="n">dims</span><span class="o">=</span><span class="n">zVar</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">(),</span>
                 <span class="n">n_elements</span><span class="o">=</span><span class="n">zVar</span><span class="o">.</span><span class="n">nelems</span><span class="p">())</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="o">*</span><span class="n">zVar</span><span class="o">.</span><span class="n">compress</span><span class="p">())</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">zVar</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">zVar</span><span class="o">.</span><span class="n">_raw</span>
            <span class="n">zVar</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_var</span><span class="p">(</span><span class="n">name</span><span class="p">)[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">zVar</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
            <span class="n">zVar</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">return</span> <span class="n">zVar</span></div>

<div class="viewcode-block" id="CDF.col_major"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.col_major">[docs]</a>    <span class="k">def</span> <span class="nf">col_major</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_col</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the majority of this CDF file</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        new_col : boolean</span>
<span class="sd">            Specify True to change to column-major, False to change to</span>
<span class="sd">            row major, or do not specify to check the majority</span>
<span class="sd">            rather than changing it.</span>
<span class="sd">            (default is check only)</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : boolean</span>
<span class="sd">            True if column-major, false if row-major</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_col</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_maj</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">COLUMN_MAJOR</span> <span class="k">if</span> <span class="n">new_col</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">ROW_MAJOR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAJORITY_</span><span class="p">,</span> <span class="n">new_maj</span><span class="p">)</span>
        <span class="n">maj</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAJORITY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">maj</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">maj</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">ROW_MAJOR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">COLUMN_MAJOR</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_MAJORITY</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">maj</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">COLUMN_MAJOR</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="CDF.readonly"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.readonly">[docs]</a>    <span class="k">def</span> <span class="nf">readonly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ro</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets or check the readonly status of this CDF</span>

<span class="sd">        If the CDF has been changed since opening, setting readonly mode</span>
<span class="sd">        will have no effect.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Closing a CDF that has been opened readonly, or setting readonly</span>
<span class="sd">            False, may take a substantial amount of time if there are many</span>
<span class="sd">            variables in the CDF, as a (potentially large) cache needs to</span>
<span class="sd">            be cleared. Consider specifying ``readonly=False`` when opening</span>
<span class="sd">            the file if this is an issue. However, this may make some reading</span>
<span class="sd">            operations slower.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        ro : Boolean</span>
<span class="sd">            True to set the CDF readonly, False to set it read/write,</span>
<span class="sd">            or leave out to check only.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : Boolean</span>
<span class="sd">            True if CDF is read-only, else False</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if bad mode is set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ro</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_READONLY_MODE_</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">READONLYon</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ro</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_READONLY_MODE_</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">READONLYoff</span><span class="p">)</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CONFIRM_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_READONLY_MODE_</span><span class="p">,</span>
                   <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">READONLYon</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">READONLYoff</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_READONLY_MODE</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="CDF.checksum"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.checksum">[docs]</a>    <span class="k">def</span> <span class="nf">checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_val</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set or check the checksum status of this CDF. If checksums</span>
<span class="sd">        are enabled, the checksum will be verified every time the file</span>
<span class="sd">        is opened.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        new_val : boolean</span>
<span class="sd">            True to enable checksum, False to disable, or leave out</span>
<span class="sd">            to simply check.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : boolean</span>
<span class="sd">            True if the checksum is enabled or False if disabled</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_val</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_CHECKSUM_</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">MD5_CHECKSUM</span> <span class="k">if</span> <span class="n">new_val</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_CHECKSUM</span><span class="p">)</span>
        <span class="n">chk</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_CHECKSUM_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">chk</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">chk</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">MD5_CHECKSUM</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">NO_CHECKSUM</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_CHECKSUM</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chk</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">MD5_CHECKSUM</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="CDF.close"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Closes the CDF file</span>

<span class="sd">        Although called on object destruction (:meth:`~CDF.__del__`),</span>
<span class="sd">        to ensure all data are saved, the user should explicitly call</span>
<span class="sd">        :meth:`~CDF.close` or :meth:`~CDF.save`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        CDFWarning : if CDF library reports a warning</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CLOSE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="CDF.compress"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.compress">[docs]</a>    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comptype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set or check the compression of this CDF</span>

<span class="sd">        Sets compression on entire *file*, not per-variable.</span>

<span class="sd">        See section 2.6 of the CDF user&#39;s guide for more information on</span>
<span class="sd">        compression.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        comptype : ctypes.c_long</span>
<span class="sd">            type of compression to change to, see CDF C reference manual</span>
<span class="sd">            section 4.10. Constants for this parameter are in</span>
<span class="sd">            :mod:`~spacepy.pycdf.const`. If not specified, will not change</span>
<span class="sd">            compression.</span>
<span class="sd">        param : ctypes.c_long</span>
<span class="sd">            Compression parameter, see CDF CRM 4.10 and</span>
<span class="sd">            :mod:`~spacepy.pycdf.const`.</span>
<span class="sd">            If not specified, will choose reasonable default (5 for gzip;</span>
<span class="sd">            other types have only one possible parameter.)</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : tuple</span>
<span class="sd">            (comptype, param) currently in effect</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        :meth:`Var.compress`</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        Set file ``cdffile`` to gzip compression, compression level 9:</span>
<span class="sd">            &gt;&gt;&gt; cdffile.compress(pycdf.const.GZIP_COMPRESSION, 9)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comptype</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span></div>

<div class="viewcode-block" id="CDF.new"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.new">[docs]</a>    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recVary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimVarys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_elements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compress_param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new zVariable in this CDF</span>

<span class="sd">        .. note::</span>
<span class="sd">            Either ``data`` or ``type`` must be specified. If type is not</span>
<span class="sd">            specified, it is guessed from ``data``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        name : str</span>
<span class="sd">            name of the new variable</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        data</span>
<span class="sd">            data to store in the new variable. If this has a an</span>
<span class="sd">            ``attrs`` attribute (e.g.,</span>
<span class="sd">            :class:`~spacepy.datamodel.dmarray`), it will be used to</span>
<span class="sd">            populate attributes of the new variable. Similarly the CDF</span>
<span class="sd">            type, record variance, etc. will, by default, be taken</span>
<span class="sd">            from `data` if it is a</span>
<span class="sd">            :class:`~spacepy.pycdf.VarCopy`. This can be overridden by</span>
<span class="sd">            specifying other keywords.</span>
<span class="sd">        type : ctypes.c_long</span>
<span class="sd">            CDF type of the variable, from :mod:`~spacepy.pycdf.const`.</span>
<span class="sd">            See section 2.5 of the CDF user&#39;s guide for more information on</span>
<span class="sd">            CDF data types.</span>
<span class="sd">        recVary : boolean</span>
<span class="sd">            record variance of the variable (default True)</span>
<span class="sd">        dimVarys : list of boolean</span>
<span class="sd">            dimension variance of each dimension, default True for all</span>
<span class="sd">            dimensions.</span>
<span class="sd">        dims : list of int</span>
<span class="sd">            size of each dimension of this variable, default zero-dimensional.</span>
<span class="sd">            Note this is the dimensionality as defined by CDF, i.e., for</span>
<span class="sd">            record-varying variables it excludes the leading record dimension.</span>
<span class="sd">            See :py:class:`Var`.</span>
<span class="sd">        n_elements : int</span>
<span class="sd">            number of elements, should be 1 except for CDF_CHAR,</span>
<span class="sd">            for which it&#39;s the length of the string.</span>
<span class="sd">        compress : ctypes.c_long</span>
<span class="sd">            Compression to apply to this variable, default None.</span>
<span class="sd">            See :py:meth:`Var.compress`.</span>
<span class="sd">        compress_param : ctypes.c_long</span>
<span class="sd">            Compression parameter if compression used; reasonable default</span>
<span class="sd">            is chosen. See :py:meth:`Var.compress`.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :py:class:`Var`</span>
<span class="sd">            the newly-created zVariable</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        ValueError : if neither data nor sufficient typing information</span>
<span class="sd">                     is provided.</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        DeprecationWarning</span>
<span class="sd">            if no type is provided and data is datetime, warning that</span>
<span class="sd">            the default will change in the future.</span>

<span class="sd">            .. versionadded:: 0.2.2</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>
<span class="sd">        Any given data may be representable by a range of CDF types; if</span>
<span class="sd">        the type is not specified, pycdf will guess which</span>
<span class="sd">        the CDF types which can represent this data. This breaks down to:</span>

<span class="sd">            #. If input data is a numpy array, match the type of that array</span>
<span class="sd">            #. Proper kind (numerical, string, time)</span>
<span class="sd">            #. Proper range (stores highest and lowest number provided)</span>
<span class="sd">            #. Sufficient resolution (EPOCH16 required if datetime has</span>
<span class="sd">               microseconds or below.)</span>

<span class="sd">        If more than one value satisfies the requirements, types are returned</span>
<span class="sd">        in preferred order:</span>

<span class="sd">            #. Type that matches precision of data first, then</span>
<span class="sd">            #. integer type before float type, then</span>
<span class="sd">            #. Smallest type first, then</span>
<span class="sd">            #. signed type first, then</span>
<span class="sd">            #. specifically-named (CDF_BYTE) vs. generically named (CDF_INT1)</span>

<span class="sd">        So for example, EPOCH_16 is preferred over EPOCH if ``data`` specifies</span>
<span class="sd">        below the millisecond level (rule 1), but otherwise EPOCH is preferred</span>
<span class="sd">        (rule 2).</span>

<span class="sd">        In the future, CDF_TIME_TT2000 will be the preferred EPOCH type if</span>
<span class="sd">        not specified.</span>

<span class="sd">        For floats, four-byte is preferred unless eight-byte is required:</span>

<span class="sd">            #. absolute values between 0 and 3e-39</span>
<span class="sd">            #. absolute values greater than 1.7e38</span>

<span class="sd">        This will switch to an eight-byte double in some cases where four bytes</span>
<span class="sd">        would be sufficient for IEEE 754 encoding, but where DEC formats would</span>
<span class="sd">        require eight.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;compress&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">compress</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span> <span class="c1">#numpy arrays have &quot;compress&quot; and it behaves differently</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">compress</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">compress</span> <span class="o">=</span> <span class="n">c</span>
                <span class="k">if</span> <span class="n">compress_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">compress_param</span> <span class="o">=</span> <span class="n">cp</span>
        <span class="c1">#Get defaults from VarCopy if data looks like a VarCopy</span>
        <span class="k">if</span> <span class="n">recVary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">recVary</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rv</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;rv&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">True</span>
        <span class="c1">#Use dimension variance from the copy if it matches # of dims</span>
        <span class="k">if</span> <span class="n">dimVarys</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;dv&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
            <span class="n">dv</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dv</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dv</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">recVary</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="n">dimVarys</span> <span class="o">=</span> <span class="n">dv</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">backward</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use EPOCH16, INT8, or TIME_TT2000 &#39;</span>
                             <span class="s1">&#39;in backward-compatible CDF&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">supports_int8</span> <span class="ow">and</span> \
                <span class="nb">type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;INT8 and TIME_TT2000 require CDF library 3.4.0&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide either data or a CDF type.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">n_elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n_elements</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#This supports getting the type straight from a VarCopy</span>
            <span class="p">(</span><span class="n">guess_dims</span><span class="p">,</span> <span class="n">guess_types</span><span class="p">,</span> <span class="n">guess_elements</span><span class="p">)</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="o">.</span><span class="n">types</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">recVary</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">guess_dims</span> <span class="o">==</span> <span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Record-varying data cannot be scalar. &#39;</span>
                            <span class="s1">&#39;Specify NRV with CDF.new() or put data in array.&#39;</span><span class="p">)</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="n">guess_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="n">guess_dims</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">type</span> <span class="o">=</span> <span class="n">guess_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">backward</span><span class="p">:</span>
                    <span class="nb">type</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span>
                <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">timetypes</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">guess_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;No type specified for time input; assuming </span><span class="si">{}</span><span class="s1">. This&#39;</span>
                        <span class="s1">&#39; will change to TT2000 in the future, on systems&#39;</span>
                        <span class="s1">&#39; which support it.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="nb">type</span><span class="p">]),</span>
                        <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n_elements</span> <span class="o">=</span> <span class="n">guess_elements</span>
        <span class="k">if</span> <span class="n">dimVarys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimVarys</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="n">recVary</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">VARY</span> <span class="k">if</span> <span class="n">recVary</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span>
        <span class="n">dimVarys</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">VARY</span> <span class="k">if</span> <span class="n">dimVary</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span>
                    <span class="k">for</span> <span class="n">dimVary</span> <span class="ow">in</span> <span class="n">dimVarys</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">):</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">supports_int8</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;64-bit integer support require CDF library 3.4.0&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">backward</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Data requires EPOCH16, INT8, or TIME_TT2000; &#39;</span>
                             <span class="s1">&#39;incompatible with backward-compatible CDF&#39;</span><span class="p">)</span>
        <span class="n">new_var</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">n_elements</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">recVary</span><span class="p">,</span> <span class="n">dimVarys</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compress</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_var</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">compress</span><span class="p">,</span> <span class="n">compress_param</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_var</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;attrs&#39;</span><span class="p">):</span>
                <span class="n">new_var</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_var</span></div>

<div class="viewcode-block" id="CDF.raw_var"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.raw_var">[docs]</a>    <span class="k">def</span> <span class="nf">raw_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a &quot;raw&quot; :class:`Var` object.</span>

<span class="sd">        Normally a :class:`Var` will perform translation of values for</span>
<span class="sd">        certain types (to/from Unicode for CHAR variables on Py3k,</span>
<span class="sd">        and to/from datetime for all time types). A &quot;raw&quot; object</span>
<span class="sd">        does not perform this translation, on read or write.</span>

<span class="sd">        This does *not* affect the data on disk, and in fact it</span>
<span class="sd">        is possible to maintain multiple Python objects with access</span>
<span class="sd">        to the same zVariable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        name : str</span>
<span class="sd">            name or number of the zVariable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">v</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">v</span></div>

<div class="viewcode-block" id="CDF.save"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the CDF file but leaves it open.</span>

<span class="sd">        If closing the CDF, :meth:`close` is sufficient;</span>
<span class="sd">        there is no need to call</span>
<span class="sd">        :meth:`save` before :meth:`close`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Relies on an undocumented call of the CDF C library, which is</span>
<span class="sd">            also used in the Java interface.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        CDFWarning : if CDF library reports a warning</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SAVE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_</span><span class="p">)</span></div>

<div class="viewcode-block" id="CDF.copy"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of all data and attributes in this CDF</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :py:class:`CDFCopy`</span>
<span class="sd">            :class:`~spacepy.datamodel.SpaceData`-like object of all data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CDFCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="CDF.version"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.version">[docs]</a>    <span class="k">def</span> <span class="nf">version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get version of library that created this CDF</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : tuple</span>
<span class="sd">            version of CDF library, in form (version, release, increment)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ver</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_VERSION_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">ver</span><span class="p">),</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_RELEASE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">rel</span><span class="p">),</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INCREMENT_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">inc</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ver</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">rel</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">inc</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get attribute list</span>

<span class="sd">        Provide access to the CDF&#39;s attribute list without holding a</span>
<span class="sd">        strong reference, as the attribute list has a (strong)</span>
<span class="sd">        back-reference to its parent.</span>

<span class="sd">        Either deref a weak reference (to try and keep the object the same),</span>
<span class="sd">        or make a new AttrList instance and assign it to the weak reference</span>
<span class="sd">        for next time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">al</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">al</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">al</span> <span class="o">=</span> <span class="n">gAttrList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">al</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">al</span>

    <span class="k">def</span> <span class="nf">_set_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign to the attribute list</span>

<span class="sd">        Clears all elements of the attribute list and copies from value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">_get_attrs</span><span class="p">,</span> <span class="n">_set_attrs</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
        <span class="sd">&quot;&quot;&quot;Global attributes for this CDF in a dict-like format.</span>
<span class="sd">        See :class:`gAttrList` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="CDF.var_num"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.var_num">[docs]</a>    <span class="k">def</span> <span class="nf">var_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the variable number of a particular variable name</span>

<span class="sd">        This maintains a cache of name-to-number mappings for zVariables</span>
<span class="sd">        to keep from having to query the CDF library constantly. It&#39;s mostly</span>
<span class="sd">        an internal function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        varname : bytes</span>
<span class="sd">            name of the zVariable. Not this is NOT a string in Python 3!</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if variable is not found</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            Variable number of this zvariable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_nums</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#Copied from Var._get, which can hopefully be thinned</span>
            <span class="n">varNum</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NUMBER_</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span>
                       <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">varNum</span><span class="p">))</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">varNum</span><span class="o">.</span><span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_var_nums</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
        <span class="k">return</span> <span class="n">num</span></div>

<div class="viewcode-block" id="CDF.attr_num"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.attr_num">[docs]</a>    <span class="k">def</span> <span class="nf">attr_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the attribute number and scope by attribute name</span>

<span class="sd">        This maintains a cache of name-to-number mappings for attributes</span>
<span class="sd">        to keep from having to query the CDF library constantly. It&#39;s mostly</span>
<span class="sd">        an internal function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        attrname : bytes</span>
<span class="sd">            name of the attribute. Not this is NOT a string in Python 3!</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if attribute is not found</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : tuple</span>
<span class="sd">            attribute number, scope (True for global) of this attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attrname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#Copied from Var._get, which can hopefully be thinned</span>
            <span class="n">attrNum</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NUMBER_</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span>
                       <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">attrNum</span><span class="p">))</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_</span><span class="p">,</span> <span class="n">attrNum</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_SCOPE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">scope</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">scope</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">GLOBAL_SCOPE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">scope</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">scope</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">VARIABLE_SCOPE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">scope</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_SCOPE</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">attrNum</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attr_info</span><span class="p">[</span><span class="n">attrname</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="CDF.clear_attr_from_cache"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.clear_attr_from_cache">[docs]</a>    <span class="k">def</span> <span class="nf">clear_attr_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark an attribute deleted in the name-to-number cache</span>

<span class="sd">        Will remove an attribute, and all attributes with higher numbers,</span>
<span class="sd">        from the attribute cache.</span>

<span class="sd">        Does NOT delete the variable!</span>

<span class="sd">        This maintains a cache of name-to-number mappings for attributes</span>
<span class="sd">        to keep from having to query the CDF library constantly. It&#39;s mostly</span>
<span class="sd">        an internal function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        attrname : bytes</span>
<span class="sd">            name of the attribute. Not this is NOT a string in Python 3!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_num</span><span class="p">(</span><span class="n">attrname</span><span class="p">)</span>
        <span class="c1">#All numbers higher than this are renumbered</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attr_info</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_info</span><span class="p">[</span><span class="n">a</span><span class="p">]</span></div>

<div class="viewcode-block" id="CDF.clear_from_cache"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.clear_from_cache">[docs]</a>    <span class="k">def</span> <span class="nf">clear_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark a variable deleted in the name-to-number cache</span>

<span class="sd">        Will remove a variable, and all variables with higher numbers,</span>
<span class="sd">        from the variable cache.</span>

<span class="sd">        Does NOT delete the variable!</span>

<span class="sd">        This maintains a cache of name-to-number mappings for zVariables</span>
<span class="sd">        to keep from having to query the CDF library constantly. It&#39;s mostly</span>
<span class="sd">        an internal function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        varname : bytes</span>
<span class="sd">            name of the zVariable. Not this is NOT a string in Python 3!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_num</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
        <span class="c1">#All numbers higher than this are renumbered</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_nums</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_nums</span><span class="p">[</span><span class="n">v</span><span class="p">]</span></div>

<div class="viewcode-block" id="CDF.add_attr_to_cache"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.add_attr_to_cache">[docs]</a>    <span class="k">def</span> <span class="nf">add_attr_to_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an attribute to the name-to-number cache</span>

<span class="sd">        This maintains a cache of name-to-number mappings for attributes</span>
<span class="sd">        to keep from having to query the CDF library constantly. It&#39;s mostly</span>
<span class="sd">        an internal function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        varname : bytes</span>
<span class="sd">            name of the zVariable. Not this is NOT a string in Python 3!</span>
<span class="sd">        num : int</span>
<span class="sd">            number of the variable</span>
<span class="sd">        scope : bool</span>
<span class="sd">            True if global scope; False if variable scope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attr_info</span><span class="p">[</span><span class="n">attrname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span></div>

<div class="viewcode-block" id="CDF.add_to_cache"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDF.html#spacepy.pycdf.CDF.add_to_cache">[docs]</a>    <span class="k">def</span> <span class="nf">add_to_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a variable to the name-to-number cache</span>

<span class="sd">        This maintains a cache of name-to-number mappings for zVariables</span>
<span class="sd">        to keep from having to query the CDF library constantly. It&#39;s mostly</span>
<span class="sd">        an internal function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        varname : bytes</span>
<span class="sd">            name of the zVariable. Not this is NOT a string in Python 3!</span>
<span class="sd">        num : int</span>
<span class="sd">            number of the variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_nums</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span></div></div>

    <span class="c1">#Note there is no function for delete, currently handled in Var.rename</span>
    <span class="c1">#and Attr.rename by just deleting from the dict directly. Maybe this</span>
    <span class="c1">#should be differen (maybe should be possible to follow a variable across</span>
    <span class="c1">#a rename...)</span>


<div class="viewcode-block" id="CDFCopy"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.CDFCopy.html#spacepy.pycdf.CDFCopy">[docs]</a><span class="k">class</span> <span class="nc">CDFCopy</span><span class="p">(</span><span class="n">spacepy</span><span class="o">.</span><span class="n">datamodel</span><span class="o">.</span><span class="n">SpaceData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A dictionary-like copy of all data and attributes in a :py:class:`CDF`</span>

<span class="sd">    Data are :class:`VarCopy` objects, keyed by variable name.</span>
<span class="sd">    CDF attributes are in :attr:`attrs`. (I.e.,</span>
<span class="sd">    data are accessed much like from a :class:`CDF`).</span>

<span class="sd">    Do not instantiate this class directly; use :meth:`~CDF.copy`</span>
<span class="sd">    on an existing :class:`CDF`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from spacepy import pycdf</span>
<span class="sd">    &gt;&gt;&gt; with pycdf.CDF(&#39;test.cdf&#39;) as cdffile:</span>
<span class="sd">    ...     data = cdffile.copy()</span>

<span class="sd">    .. attribute:: attrs</span>

<span class="sd">       Python dictionary containing attributes copied from the CDF.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies all data and attributes from a CDF</span>

<span class="sd">        @param cdf: CDF to take data from</span>
<span class="sd">        @type cdf: :py:class:`pycdf.CDF`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CDFCopy</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(((</span><span class="n">key</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                                      <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cdf</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>
                                      <span class="n">attrs</span> <span class="o">=</span> <span class="n">cdf</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>


<div class="viewcode-block" id="concatCDF"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.concatCDF.html#spacepy.pycdf.concatCDF">[docs]</a><span class="k">def</span> <span class="nf">concatCDF</span><span class="p">(</span><span class="n">cdfs</span><span class="p">,</span> <span class="n">varnames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Concatenate data from multiple CDFs</span>

<span class="sd">    Reads data from all specified CDFs in order and returns as if they</span>
<span class="sd">    were from a single CDF. The assumption is that the CDFs all have the</span>
<span class="sd">    same structure (same variables, each with the same dimensions and</span>
<span class="sd">    variance.)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cdfs : list of :class:`~spacepy.pycdf.Var`</span>
<span class="sd">        Open CDFs, will be read from in order. Must be a list (cannot</span>
<span class="sd">        be an iterable, as all files need to be open).</span>
<span class="sd">    varnames : list of str</span>
<span class="sd">        Names of variables to read (default: all variables in first CDF)</span>
<span class="sd">    raw : bool</span>
<span class="sd">        If True, read variables as raw (don&#39;t convert epochs, etc.)</span>
<span class="sd">        Default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~spacepy.datamodel.SpaceData`</span>
<span class="sd">        data concatenated from each CDF, with all attributes from first.</span>
<span class="sd">        Non-record-varying data is also only from first, and record</span>
<span class="sd">        variance is only checked on the first!</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Read all data from all CDFs in the current directory. Note that</span>
<span class="sd">    CDFs are closed when their variable goes out of scope.</span>

<span class="sd">    &gt;&gt;&gt; import glob</span>
<span class="sd">    &gt;&gt;&gt; import spacepy.pycdf</span>
<span class="sd">    &gt;&gt;&gt; data = spacepy.pycdf.concatCDF([</span>
<span class="sd">    ...     spacepy.pycdf.CDF(f) for f in glob.glob(&#39;*.cdf&#39;)])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">varnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">varnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cdfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="c1">#Iterate over this CDF only once</span>
    <span class="n">vargetter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">raw_var</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">raw</span> <span class="k">else</span> <span class="n">f</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">datamodel</span><span class="o">.</span><span class="n">SpaceData</span><span class="p">(</span>
        <span class="p">{</span><span class="n">v</span><span class="p">:</span>
         <span class="n">spacepy</span><span class="o">.</span><span class="n">datamodel</span><span class="o">.</span><span class="n">dmarray</span><span class="p">(</span>
             <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">vargetter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)[</span><span class="o">...</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">cdfs</span><span class="p">]),</span>
             <span class="n">attrs</span><span class="o">=</span><span class="n">vargetter</span><span class="p">(</span><span class="n">cdfs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
         <span class="k">if</span> <span class="n">cdfs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">rv</span><span class="p">()</span> <span class="k">else</span> <span class="n">vargetter</span><span class="p">(</span><span class="n">cdfs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varnames</span><span class="p">},</span>
        <span class="n">attrs</span><span class="o">=</span><span class="n">cdfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>


<div class="viewcode-block" id="Var"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Var.html#spacepy.pycdf.Var">[docs]</a><span class="k">class</span> <span class="nc">Var</span><span class="p">(</span><span class="n">MutableSequence</span><span class="p">,</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">datamodel</span><span class="o">.</span><span class="n">MetaMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A CDF variable.</span>

<span class="sd">    This object does not directly store the data from the CDF; rather,</span>
<span class="sd">    it provides access to the data in a format that much like a Python</span>
<span class="sd">    list or numpy :class:`~numpy.ndarray`.</span>
<span class="sd">    General list information is available in the python docs:</span>
<span class="sd">    `1 &lt;http://docs.python.org/tutorial/introduction.html#lists&gt;`_,</span>
<span class="sd">    `2 &lt;http://docs.python.org/tutorial/datastructures.html#more-on-lists&gt;`_,</span>
<span class="sd">    `3 &lt;http://docs.python.org/library/stdtypes.html#typesseq&gt;`_.</span>

<span class="sd">    The CDF user&#39;s guide, section 2.3, provides background on variables.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Not intended to be created directly; use methods of :class:`CDF` to gain access to a variable.</span>

<span class="sd">    A record-varying variable&#39;s data are viewed as a hypercube of dimensions</span>
<span class="sd">    n_dims+1 (the extra dimension is the record number). They are indexed in</span>
<span class="sd">    row-major fashion, i.e. the last index changes most frequently / is</span>
<span class="sd">    contiguous in memory. If the CDF is column-major, the data are</span>
<span class="sd">    transformed to row-major before return.</span>

<span class="sd">    Non record-varying variables are similar, but do not have the extra</span>
<span class="sd">    dimension of record number.</span>

<span class="sd">    Variables can be subscripted by a multidimensional index to return the</span>
<span class="sd">    data. Indices are in row-major order with the first dimension</span>
<span class="sd">    representing the record number. If the CDF is column major,</span>
<span class="sd">    the data are reordered to row major. Each dimension is specified</span>
<span class="sd">    by standard Python</span>
<span class="sd">    `slice &lt;http://docs.python.org/tutorial/introduction.html#strings&gt;`_</span>
<span class="sd">    notation, with dimensions separated by commas. The ellipsis fills in</span>
<span class="sd">    any missing dimensions with full slices. The returned data are</span>
<span class="sd">    lists; Python represents multidimensional arrays as nested lists.</span>
<span class="sd">    The innermost set of lists represents contiguous data.</span>

<span class="sd">    .. note::</span>
<span class="sd">        numpy &#39;fancy indexing&#39; is *not* supported.</span>

<span class="sd">    Degenerate dimensions are &#39;collapsed&#39;, i.e. no list of only one</span>
<span class="sd">    element will be returned if a single subscript is specified</span>
<span class="sd">    instead of a range. (To avoid this, specify a slice like 1:2,</span>
<span class="sd">    which starts with 1 and ends before 2).</span>

<span class="sd">    Two special cases:</span>
<span class="sd">        </span>
<span class="sd">      1. requesting a single-dimension slice for a</span>
<span class="sd">         record-varying variable will return all data for that</span>
<span class="sd">         record number (or those record numbers) for that variable.</span>
<span class="sd">      2. Requests for multi-dimensional variables may skip the record-number</span>
<span class="sd">         dimension and simply specify the slice on the array itself. In that</span>
<span class="sd">         case, the slice of the array will be returned for all records.</span>

<span class="sd">    In the event of ambiguity (e.g., single-dimension slice on a one-dimensional</span>
<span class="sd">    variable), case 1 takes priority.</span>
<span class="sd">    Otherwise, mismatch between the number of dimensions specified in</span>
<span class="sd">    the slice and the number of dimensions in the variable will cause</span>
<span class="sd">    an :exc:`~exceptions.IndexError` to be thrown.</span>

<span class="sd">    This all sounds very complicated but it is essentially attempting</span>
<span class="sd">    to do the &#39;right thing&#39; for a range of slices.</span>

<span class="sd">    An unusual case is scalar (zero-dimensional) non-record-varying variables.</span>
<span class="sd">    Clearly they cannot be subscripted normally. In this case, use the</span>
<span class="sd">    ``[...]`` syntax meaning &#39;access all data.&#39;:</span>

<span class="sd">    &gt;&gt;&gt; from spacepy import pycdf</span>
<span class="sd">    &gt;&gt;&gt; testcdf = pycdf.CDF(&#39;test.cdf&#39;, &#39;&#39;)</span>
<span class="sd">    &gt;&gt;&gt; variable = testcdf.new(&#39;variable&#39;, recVary=False,</span>
<span class="sd">    ...     type=pycdf.const.CDF_INT4)</span>
<span class="sd">    &gt;&gt;&gt; variable[...] = 10</span>
<span class="sd">    &gt;&gt;&gt; variable</span>
<span class="sd">    &lt;Var:</span>
<span class="sd">    CDF_INT4 [] NRV</span>
<span class="sd">    &gt;</span>
<span class="sd">    &gt;&gt;&gt; variable[...]</span>
<span class="sd">    10</span>

<span class="sd">    Reading any empty non-record-varying variable will return an empty</span>
<span class="sd">    with the same *number* of dimensions, but all dimensions will be</span>
<span class="sd">    of zero length. The scalar is, again, a special case: due to the</span>
<span class="sd">    inability to have a numpy array which is both zero-dimensional and empty,</span>
<span class="sd">    reading an NRV scalar variable with no data will return an empty</span>
<span class="sd">    one-dimensional array. This is really not recommended.</span>

<span class="sd">    As a list type, variables are also `iterable</span>
<span class="sd">    &lt;http://docs.python.org/tutorial/classes.html#iterators&gt;`_; iterating</span>
<span class="sd">    over a variable returns a single complete record at a time.</span>

<span class="sd">    This is all clearer with examples. Consider a variable ``B_GSM``, with</span>
<span class="sd">    three elements per record (x, y, z components) and fifty records in</span>
<span class="sd">    the CDF. Then:</span>
<span class="sd">        </span>
<span class="sd">      1. ``B_GSM[0, 1]`` is the y component of the first record.</span>
<span class="sd">      2. ``B_GSM[10, :]`` is a three-element list, containing x, y, and z</span>
<span class="sd">         components of the 11th record. As a shortcut, if only one dimension</span>
<span class="sd">         is specified, it is assumed to be the record number, so this</span>
<span class="sd">         could also be written ``B_GSM[10]``.</span>
<span class="sd">      3. ``B_GSM[...]`` reads all data for ``B_GSM`` and returns it as a</span>
<span class="sd">         fifty-element list, each element itself being a three-element</span>
<span class="sd">         list of x, y, z components.</span>

<span class="sd">    Multidimensional example: consider fluxes stored as a function of</span>
<span class="sd">    pitch angle and energy. Such a variable may be called Flux and</span>
<span class="sd">    stored as a two-dimensional array, with the first dimension</span>
<span class="sd">    representing (say) ten energy steps and the second, eighteen</span>
<span class="sd">    pitch angle bins (ten degrees wide, centered from 5 to 175 degrees).</span>
<span class="sd">    Assume 100 records stored in the CDF (i.e. 100 different times).</span>
<span class="sd">    </span>
<span class="sd">      1. ``Flux[4]`` is a list of ten elements, one per energy step,</span>
<span class="sd">         each element being a list of 18 fluxes, one per pitch bin.</span>
<span class="sd">         All are taken from the fifth record in the CDF.</span>
<span class="sd">      2. ``Flux[4, :, 0:4]`` is the same record, all energies, but</span>
<span class="sd">         only the first four pitch bins (roughly, field-aligned).</span>
<span class="sd">      3. ``Flux[..., 0:4]`` is a 100-element list (one per record),</span>
<span class="sd">         each element being a ten-element list (one per energy step),</span>
<span class="sd">         each containing fluxes for the first four pitch bins.</span>

<span class="sd">    This slicing notation is very flexible and allows reading</span>
<span class="sd">    specifically the desired data from the CDF.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The C CDF library allows reading records which have not been</span>
<span class="sd">        written to a file, returning a pad value. pycdf checks the</span>
<span class="sd">        size of a variable and will raise `IndexError` for most</span>
<span class="sd">        attempts to read past the end. If these checks fail, a value</span>
<span class="sd">        is returned with a warning ``VIRTUAL_RECORD_DATA``. Please</span>
<span class="sd">        `open an issue</span>
<span class="sd">        &lt;https://github.com/spacepy/spacepy/issues/new&gt;`_ if this</span>
<span class="sd">        occurs. See pg. 39 and following of the `CDF User&#39;s Guide</span>
<span class="sd">        &lt;https://cdf.gsfc.nasa.gov/html/cdf_docs.html&gt;`_ for more on</span>
<span class="sd">        virtual records.</span>

<span class="sd">    All data are, on read, converted to appropriate Python data</span>
<span class="sd">    types; EPOCH, EPOCH16, and TIME_TT2000 types are converted to</span>
<span class="sd">    :class:`~datetime.datetime`. Data are returned in numpy arrays.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Although pycdf supports TIME_TT2000 variables, the Python</span>
<span class="sd">        :class:`~datetime.datetime` object does not support leap</span>
<span class="sd">        seconds. Thus, on read, any seconds past 59 are truncated</span>
<span class="sd">        to 59.999999 (59 seconds, 999 milliseconds, 999 microseconds).</span>

<span class="sd">    Potentially useful list methods and related functions:</span>
<span class="sd">      - `count &lt;http://docs.python.org/tutorial/datastructures.html#more-on-lists&gt;`_</span>
<span class="sd">      - `in &lt;http://docs.python.org/reference/expressions.html#in&gt;`_</span>
<span class="sd">      - `index &lt;http://docs.python.org/tutorial/datastructures.html#more-on-lists&gt;`_</span>
<span class="sd">      - `len &lt;http://docs.python.org/library/functions.html#len&gt;`_</span>
<span class="sd">      - `list comprehensions</span>
<span class="sd">        &lt;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&gt;`_</span>
<span class="sd">      - `sorted &lt;http://docs.python.org/library/functions.html#sorted&gt;`_</span>

<span class="sd">    The topic of array majority can be very confusing; good background material</span>
<span class="sd">    is available at `IDL Array Storage and Indexing</span>
<span class="sd">    &lt;http://www.idlcoyote.com/misc_tips/colrow_major.html&gt;`_. In brief,</span>
<span class="sd">    *regardless of the majority stored in the CDF*, pycdf will always present</span>
<span class="sd">    the data in the native Python majority, row-major order, also known as</span>
<span class="sd">    C order. This is the default order in `NumPy</span>
<span class="sd">    &lt;http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html</span>
<span class="sd">    #internal-memory-layout-of-an-ndarray&gt;`_.</span>
<span class="sd">    However, packages that render image data may expect it in column-major</span>
<span class="sd">    order. If the axes seem &#39;swapped&#39; this is likely the reason.</span>

<span class="sd">    The :attr:`~Var.attrs` Python attribute acts as a dictionary referencing</span>
<span class="sd">    zAttributes (do not confuse the two); all the dictionary methods above</span>
<span class="sd">    also work on the attribute dictionary. See :class:`zAttrList` for more on</span>
<span class="sd">    the dictionary of attributes.</span>

<span class="sd">    With writing, as with reading, every attempt has been made to match the</span>
<span class="sd">    behavior of Python lists. You can write one record, many records, or even</span>
<span class="sd">    certain elements of all records. There is one restriction: only the record</span>
<span class="sd">    dimension (i.e. dimension 0) can be resized by write, as all records</span>
<span class="sd">    in a variable must have the same dimensions. Similarly, only whole</span>
<span class="sd">    records can be deleted.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Unusual error messages on writing data usually mean that pycdf is</span>
<span class="sd">        unable to interpret the data as a regular array of a single type</span>
<span class="sd">        matching the type and shape of the variable being written.</span>
<span class="sd">        A 5x4 array is supported; an irregular array where one row has</span>
<span class="sd">        five columns and a different row has six columns is not. Error messages</span>
<span class="sd">        of this type include:</span>

<span class="sd">          - ``Data must be well-formed, regular array of number, string, or datetime``</span>
<span class="sd">          - ``setting an array element with a sequence.``</span>
<span class="sd">          - ``shape mismatch: objects cannot be broadcast to a</span>
<span class="sd">            single shape``</span>

<span class="sd">    For these examples, assume Flux has 100 records and dimensions [2, 3].</span>
<span class="sd">    </span>
<span class="sd">    Rewrite the first record without changing the rest:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; Flux[0] = [[1, 2, 3], [4, 5, 6]]</span>
<span class="sd">        </span>
<span class="sd">    Writes a new first record and delete all the rest:</span>

<span class="sd">    &gt;&gt;&gt; Flux[...] = [[1, 2, 3], [4, 5, 6]]</span>
<span class="sd">        </span>
<span class="sd">    Write a new record in the last position and add a new record after:</span>

<span class="sd">    &gt;&gt;&gt; Flux[99:] = [[[1, 2, 3], [4, 5, 6]],</span>
<span class="sd">    ...              [[11, 12, 13], [14, 15, 16]]]</span>
<span class="sd">    </span>
<span class="sd">    Insert two new records between the current number 5 and 6:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; Flux[5:6] = [[[1, 2, 3], [4, 5, 6]],  [[11, 12, 13],</span>
<span class="sd">    ...               [14, 15, 16]]]</span>

<span class="sd">    This operation can be quite slow, as it requires reading and</span>
<span class="sd">    rewriting the entire variable. (CDF does not directly support</span>
<span class="sd">    record insertion.)</span>
<span class="sd">    </span>
<span class="sd">    Change the first element of the first two records but leave other</span>
<span class="sd">    elements alone:</span>

<span class="sd">    &gt;&gt;&gt; Flux[0:2, 0, 0] = [1, 2]</span>

<span class="sd">    Remove the first record:</span>

<span class="sd">    &gt;&gt;&gt; del Flux[0]</span>

<span class="sd">    Removes record 5 (the sixth):</span>

<span class="sd">    &gt;&gt;&gt; del Flux[5]</span>

<span class="sd">    Due to the need to work around a bug in the CDF library, this operation</span>
<span class="sd">    can be quite slow.</span>
<span class="sd">    </span>
<span class="sd">    Delete *all data* from ``Flux``, but leave the variable definition intact:</span>

<span class="sd">    &gt;&gt;&gt; del Flux[...]</span>

<span class="sd">    .. note::</span>
<span class="sd">        Although this interface only directly supports zVariables, zMode is</span>
<span class="sd">        set on opening the CDF so rVars appear as zVars. See p.24 of the</span>
<span class="sd">        CDF user&#39;s guide; pyCDF uses zMode 2.</span>


<span class="sd">    .. autosummary::</span>

<span class="sd">        ~Var.attrs</span>
<span class="sd">        ~Var.compress</span>
<span class="sd">        ~Var.copy</span>
<span class="sd">        ~Var.dtype</span>
<span class="sd">        ~Var.dv</span>
<span class="sd">        ~Var.insert</span>
<span class="sd">        ~Var.name</span>
<span class="sd">        ~Var.nelems</span>
<span class="sd">        ~Var.rename</span>
<span class="sd">        ~Var.rv</span>
<span class="sd">        ~Var.shape</span>
<span class="sd">        ~Var.type</span>
<span class="sd">    .. attribute:: Var.attrs</span>

<span class="sd">       zAttributes for this zVariable in a dict-like format.</span>
<span class="sd">       See :class:`zAttrList` for details.</span>
<span class="sd">    .. automethod:: compress</span>
<span class="sd">    .. automethod:: copy</span>
<span class="sd">    .. autoattribute:: dtype</span>
<span class="sd">    .. automethod:: dv</span>
<span class="sd">    .. automethod:: insert</span>
<span class="sd">    .. automethod:: name</span>
<span class="sd">    .. automethod:: nelems</span>
<span class="sd">    .. automethod:: rename</span>
<span class="sd">    .. automethod:: rv</span>
<span class="sd">    .. autoattribute:: shape</span>
<span class="sd">    .. automethod:: type</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdf_file</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create or locate a variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        cdf_file : :py:class:`pycdf.CDF`</span>
<span class="sd">            CDF file containing this variable</span>
<span class="sd">        var_name : string</span>
<span class="sd">            name of this variable</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        args</span>
<span class="sd">            additional arguments passed to :py:meth:`_create`. If none,</span>
<span class="sd">            opens an existing variable. If provided, creates a</span>
<span class="sd">            new one.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError</span>
<span class="sd">            if CDF library reports an error</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        CDFWarning</span>
<span class="sd">            if CDF library reports a warning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span> <span class="o">=</span> <span class="n">cdf_file</span>
        <span class="c1">#This is the definitive &quot;identify&quot; of variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1">#CDF type (long)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#Raw access (skip all conversions)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c1">#Weak reference to attribute list (use attrs instead)</span>
        <span class="c1">#This avoids a reference loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a slice from the data array. Details under :py:class:`pycdf.Var`.</span>

<span class="sd">        @return: The data from this variable</span>
<span class="sd">        @rtype: list-of-lists of appropriate type.</span>
<span class="sd">        @raise IndexError: if L{key} is out of range, mismatches dimensions,</span>
<span class="sd">                           or simply unparseable.</span>
<span class="sd">        @raise CDFError: for errors from the CDF library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hslice</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="c1">#Hyperslice mostly catches this sort of thing, but</span>
        <span class="c1">#an empty variable is a special case, since we might want to</span>
        <span class="c1">#WRITE to 0th record (which Hyperslice also supports) but</span>
        <span class="c1">#can&#39;t READ from it, and iterating over tries to read from it.</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">rv</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">hslice</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> \
               <span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;record index out of range&#39;</span><span class="p">)</span>
        <span class="c1">#For NRV, again hslice will assume 0th record exists since we might</span>
        <span class="c1">#want to write. So ANY degenerate dim other than the glued-on 0th</span>
        <span class="c1">#suggests an explicit index that should fail. None degenerate suggests</span>
        <span class="c1">#make an empty array.</span>
        <span class="c1">#Note this is pulling a lot of hyperslice stuff into getitem!</span>
        <span class="k">elif</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hslice</span><span class="o">.</span><span class="n">degen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="n">hslice</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;record index out of range&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#The zero-length dimension is degenerate so it gets chopped,</span>
                <span class="c1">#and you can&#39;t have a zero-length numpy array that still</span>
                <span class="c1">#maintains the size of all other dimensions. So just force</span>
                <span class="c1">#a zero-dim array and the rest will follow</span>
                <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1">#If this is a scalar, need to make a single non-degenerate</span>
                <span class="c1">#dimension so it can be empty.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">hslice</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">create_array</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">hslice</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_HYPERDATA_</span><span class="p">,</span>
                     <span class="n">result</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hslice</span><span class="o">.</span><span class="n">convert_input_array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes a record (or set of records) from the CDF</span>

<span class="sd">        Only whole records can be deleted, so the del call must either specify</span>
<span class="sd">        only one dimension or it must specify all elements of the non-record</span>
<span class="sd">        dimensions. This is *not* a way to resize a variable!</span>

<span class="sd">        Deleting records from the middle of a variable may be very slow in</span>
<span class="sd">        some circumstances. To work around a bug in CDF library versions</span>
<span class="sd">        3.4.0 and before, all the data must be read in, the requested deletions</span>
<span class="sd">        done, and then all written back out.</span>

<span class="sd">        @param key: index or slice to delete</span>
<span class="sd">        @type key: int or slice</span>
<span class="sd">        @raise TypeError: if an attempt is made to delete from a non</span>
<span class="sd">                          record-varying variable, or to delete below</span>
<span class="sd">                          the record level</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot delete records from non-record-varying &#39;</span>
                            <span class="s1">&#39;variable.&#39;</span><span class="p">)</span>
        <span class="n">hslice</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dims</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Can only delete entire records.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dimsize</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">()</span>
        <span class="n">dangerous_delete</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">lib</span><span class="o">.</span><span class="n">_del_middle_rec_bug</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="n">interval</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">dimsize</span><span class="p">)):</span>
            <span class="c1">#delete from middle is dangerous if only have one index entry</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_nINDEXENTRIES_</span><span class="p">,</span>
                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">entries</span><span class="p">))</span>
            <span class="n">dangerous_delete</span> <span class="o">=</span> <span class="p">(</span><span class="n">entries</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dangerous_delete</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="n">interval</span><span class="p">,</span> <span class="n">interval</span><span class="p">),</span>
                <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">dimsize</span> <span class="o">-</span> <span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">first_rec</span> <span class="o">=</span> <span class="n">dimsize</span> <span class="o">-</span> <span class="n">count</span>
            <span class="n">last_rec</span> <span class="o">=</span> <span class="n">dimsize</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECORDS_</span><span class="p">,</span>
                     <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">first_rec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">last_rec</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">interval</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">first_rec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="n">last_rec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECORDS_</span><span class="p">,</span>
                     <span class="n">first_rec</span><span class="p">,</span> <span class="n">last_rec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">()</span>
            <span class="c1">#delete from end to avoid renumbering of records</span>
            <span class="k">for</span> <span class="n">recno</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval</span><span class="p">,</span>
                               <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">interval</span><span class="p">):</span>
                <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECORDS_</span><span class="p">,</span>
                         <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">recno</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">recno</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Puts a slice into the data array. Details under :py:class:`pycdf.Var`.</span>

<span class="sd">        @param key: index or slice to store</span>
<span class="sd">        @type key: int or slice</span>
<span class="sd">        @param data: data to store</span>
<span class="sd">        @type data: numpy.array</span>
<span class="sd">        @raise IndexError: if L{key} is out of range, mismatches dimensions,</span>
<span class="sd">                           or simply unparseable. IndexError will</span>
<span class="sd">        @raise CDFError: for errors from the CDF library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hslice</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">n_recs</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">hslice</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">cdf_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_epoch16</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_epoch</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_tt2000</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
             <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                  <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_np_type</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">datashape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">datashape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1">#Check data sizes</span>
        <span class="k">if</span> <span class="n">datashape</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">hslice</span><span class="o">.</span><span class="n">expected_dims</span><span class="p">()):</span>
             <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;attempt to assign data of dimensions &#39;</span> <span class="o">+</span>
                              <span class="nb">str</span><span class="p">(</span><span class="n">datashape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; to slice of dimensions &#39;</span> <span class="o">+</span>
                              <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">hslice</span><span class="o">.</span><span class="n">expected_dims</span><span class="p">())))</span>
        <span class="c1">#Flip majority and reversed dimensions, see convert_input_array</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">convert_output_array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1">#Handle insertions and similar weirdness</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_recs</span> <span class="ow">and</span> \
               <span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_recs</span> <span class="o">&lt;</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1">#Specified slice ends before last record, so insert in middle</span>
            <span class="n">saved_data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_recs</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">hslice</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_HYPERDATA_</span><span class="p">,</span>
                     <span class="n">data</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">n_recs</span><span class="p">:</span>
            <span class="n">first_rec</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last_rec</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECORDS_</span><span class="p">,</span>
                     <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">first_rec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">last_rec</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_recs</span> <span class="ow">and</span> \
               <span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_recs</span> <span class="o">&lt;</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1">#Put saved data in after inserted data</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">saved_data</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append multiple values to the end of this variable</span>

<span class="sd">        This is an efficiency function which overrides the base implementation</span>
<span class="sd">        in MutableSequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data :</span>
<span class="sd">            the data to append</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):]</span> <span class="o">=</span> <span class="n">data</span>

<div class="viewcode-block" id="Var.insert"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Var.html#spacepy.pycdf.Var.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a *single* record before an index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            index before which to insert the new record</span>
<span class="sd">        data :</span>
<span class="sd">            the record to insert</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="n">n_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span> <span class="o">=</span> <span class="p">(),</span>
               <span class="n">recVary</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">VARY</span><span class="p">,</span> <span class="n">dimVarys</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new zVariable</span>

<span class="sd">        @param var_name: name of this variable</span>
<span class="sd">        @type var_name: string</span>
<span class="sd">        @param datatype: CDF data type</span>
<span class="sd">        @type datatype: ctypes.c_long</span>
<span class="sd">        @param n_elements: number of elements (should be 1 except for</span>
<span class="sd">                           CDF_CHAR variables).</span>
<span class="sd">        @type n_elements: long</span>
<span class="sd">        @param dims: size of each dimension for multi-dimensional variable,</span>
<span class="sd">                     or empty for a zero-dimensional</span>
<span class="sd">        @type dims: sequence of long</span>
<span class="sd">        @param recVary: record variance for this variable (VARY/NOVARY)</span>
<span class="sd">        @type recVary: long</span>
<span class="sd">        @param dimVarys: array of VARY or NOVARY, variance for each dimension</span>
<span class="sd">        @type dimVarys: sequence of long</span>
<span class="sd">        @return: new variable with this name</span>
<span class="sd">        @rtype: :py:class:`pycdf.Var`</span>
<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        @note: Not intended to be used directly; use L{CDF.new}.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dim_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))(</span><span class="o">*</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">enc_name</span> <span class="o">=</span> <span class="n">var_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dimVarys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim_vary_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">))(</span><span class="n">const</span><span class="o">.</span><span class="n">VARY</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim_vary_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))(</span><span class="o">*</span><span class="n">dimVarys</span><span class="p">)</span>
        <span class="n">varNum</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CREATE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_</span><span class="p">,</span> <span class="n">enc_name</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span>
                 <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">n_elements</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)),</span> <span class="n">dim_array</span><span class="p">,</span>
                 <span class="n">recVary</span><span class="p">,</span> <span class="n">dim_vary_array</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">varNum</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">enc_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">add_to_cache</span><span class="p">(</span><span class="n">enc_name</span><span class="p">,</span> <span class="n">varNum</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes this zVariable from the CDF</span>

<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">clear_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets an existing zVariable</span>

<span class="sd">        @param var_name: name of this variable</span>
<span class="sd">        @type var_name: string</span>
<span class="sd">        @return: variable with this name</span>
<span class="sd">        @rtype: :py:class:`pycdf.Var`</span>
<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        @note: Not intended to be used directly; use L{CDF.__getitem__}.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">str_classes</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">enc_name</span> <span class="o">=</span> <span class="n">var_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">enc_name</span> <span class="o">=</span> <span class="n">var_name</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="c1">#already in ASCII</span>
            <span class="c1">#&#39;touch&#39; CDF to cause an error if the name isn&#39;t there; get number</span>
            <span class="n">varNum</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NUMBER_</span><span class="p">,</span> <span class="n">enc_name</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">varNum</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">enc_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">add_to_cache</span><span class="p">(</span><span class="n">enc_name</span><span class="p">,</span> <span class="n">varNum</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#Looking up by number</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_VAR_NAME_LEN256</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">var_name</span><span class="p">),</span>
                     <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NAME_</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">add_to_cache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the zVar number for this variable</span>

<span class="sd">        @return: number of this zVar</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">var_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get number of records for this variable in this file</span>

<span class="sd">        @return: Number of records</span>
<span class="sd">        @rtype: long</span>
<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_MAXREC_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns representation of the variable</span>

<span class="sd">        Cannot return anything that can be eval&#39;d to create a copy,</span>
<span class="sd">        so just wrap the informal representation in angle brackets.</span>
<span class="sd">        @return: info on this zVar</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;Var:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string representation of the variable</span>

<span class="sd">        This is an &#39;informal&#39; representation in that it cannot be evaluated</span>
<span class="sd">        directly to create a :py:class:`pycdf.Var`.</span>

<span class="sd">        @return: info on this zVar, CDFTYPE [dimensions] NRV</span>
<span class="sd">                 (if not record-varying)</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
            <span class="n">chartypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span><span class="p">()</span>
            <span class="n">typestr</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="n">cdftype</span><span class="p">]</span> <span class="o">+</span> \
                      <span class="p">(</span><span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nelems</span><span class="p">())</span> <span class="k">if</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="n">chartypes</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">rv</span><span class="p">:</span>
                <span class="n">sizestr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sizestr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">typestr</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">sizestr</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">rv</span> <span class="k">else</span> <span class="s1">&#39; NRV&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;zVar &quot;</span><span class="si">{0}</span><span class="s1">&quot; in closed CDF </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;zVar &quot;</span><span class="si">{0}</span><span class="s1">&quot; in closed CDF </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_n_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get number of dimensions for this variable</span>

<span class="sd">        @return: the number of dimensions</span>
<span class="sd">        @rtype: long</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_dims</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NUMDIMS_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">n_dims</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">n_dims</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">_dim_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the dimension sizes for this variable</span>

<span class="sd">        @return: sequence of sizes</span>
<span class="sd">        @rtype: sequence of long</span>
<span class="sd">        @note: This will always be in Python order (i.e. row major, last index</span>
<span class="sd">        iterates most quickly), *regardless* of the majority of the CDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAX_DIMS</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMSIZES_</span><span class="p">,</span> <span class="n">sizes</span><span class="p">)</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">sizes</span>

<div class="viewcode-block" id="Var.rv"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Var.html#spacepy.pycdf.Var.rv">[docs]</a>    <span class="k">def</span> <span class="nf">rv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_rv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets or sets whether this variable has record variance</span>

<span class="sd">        If the variance is unknown, True is assumed</span>
<span class="sd">        (this replicates the apparent behavior of the CDF library on</span>
<span class="sd">        variable creation).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        new_rv : boolean</span>
<span class="sd">            True to change to record variance, False to change to NRV,</span>
<span class="sd">            unspecified to simply check variance.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : Boolean</span>
<span class="sd">            True if record varying, False if NRV</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_rv</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECVARY_</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">VARY</span> <span class="k">if</span> <span class="n">new_rv</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span><span class="p">)</span>
        <span class="n">vary</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECVARY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">vary</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">vary</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="Var.dv"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Var.html#spacepy.pycdf.Var.dv">[docs]</a>    <span class="k">def</span> <span class="nf">dv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets or sets dimension variance of each dimension of variable.</span>

<span class="sd">        If the variance is unknown, True is assumed</span>
<span class="sd">        (this replicates the apparent behavior of the</span>
<span class="sd">        CDF library on variable creation).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        new_dv : list of boolean</span>
<span class="sd">            Each element True to change that dimension to dimension</span>
<span class="sd">            variance, False to change to not dimension variance.</span>
<span class="sd">            (Unspecified to simply check variance.)</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : list of boolean</span>
<span class="sd">            True if that dimension has variance, else false.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">new_dv</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_dv</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must specify variance for &#39;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">ndims</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;dimensions.&#39;</span><span class="p">)</span>
            <span class="n">varies</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">ndims</span><span class="p">)(</span>
                <span class="o">*</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">VARY</span> <span class="k">if</span> <span class="n">dv</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span> <span class="k">for</span> <span class="n">dv</span> <span class="ow">in</span> <span class="n">new_dv</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMVARYS_</span><span class="p">,</span>
                       <span class="n">varies</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">varies</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAX_DIMS</span><span class="p">)()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMVARYS_</span><span class="p">,</span> <span class="n">varies</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">dv</span> <span class="o">!=</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">dv</span> <span class="ow">in</span> <span class="n">varies</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ndims</span><span class="p">]]</span></div>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select this CDF and variable and call the CDF internal interface</span>

<span class="sd">        Adds call to select this CDF to L{args} and passes all parameters</span>
<span class="sd">        directly through to the CDFlib routine of the CDF library&#39;s C internal</span>
<span class="sd">        interface. Checks the return value with L{Library.check_status}.</span>

<span class="sd">        @param args: Passed directly to the CDF library interface. Useful</span>
<span class="sd">                     constants are defined in the :py:mod:`pycdf.const` module of this package.</span>
<span class="sd">        @type args: various, see :py:mod:`ctypes`.</span>
<span class="sd">        @return: CDF status from the library</span>
<span class="sd">        @rtype: ctypes.c_long</span>
<span class="sd">        @note: Terminal NULL_ is automatically added to L{args}.</span>
<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
            <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_</span><span class="p">,</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">var_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_np_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the numpy type of this variable</span>

<span class="sd">        This is the numpy type that will come directly out of the CDF;</span>
<span class="sd">        see :meth:`dtype` for the representation post-conversion.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : for library-reported error or failure to find numpy type</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : dtype</span>
<span class="sd">            numpy dtype that will hold value from this variable</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span> <span class="ow">or</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;S&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nelems</span><span class="p">()))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">cdftype</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_DATA_TYPE</span><span class="p">)</span>

<div class="viewcode-block" id="Var.type"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Var.html#spacepy.pycdf.Var.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns or sets the CDF type of this variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        new_type : ctypes.c_long</span>
<span class="sd">            the new type from :mod:`~spacepy.pycdf.const`</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            CDF type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_type</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">):</span>
                <span class="n">new_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">new_type</span><span class="p">)</span>
            <span class="n">n_elements</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nelems</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DATASPEC_</span><span class="p">,</span>
                       <span class="n">new_type</span><span class="p">,</span> <span class="n">n_elements</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cdftype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DATATYPE_</span><span class="p">,</span>
                       <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">cdftype</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="n">cdftype</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span></div>

<div class="viewcode-block" id="Var.nelems"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Var.html#spacepy.pycdf.Var.nelems">[docs]</a>    <span class="k">def</span> <span class="nf">nelems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of elements for each value in this variable</span>

<span class="sd">        This is the length of strings for CHAR and UCHAR,</span>
<span class="sd">        should be 1 otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        int</span>
<span class="sd">            length of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nelems</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NUMELEMS_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">nelems</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nelems</span><span class="o">.</span><span class="n">value</span></div>

    <span class="k">def</span> <span class="nf">_nelems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of elements for each value in this variable</span>

<span class="sd">        .. deprecated:: 0.2.2</span>
<span class="sd">            This method will be removed in the future. Use the public</span>
<span class="sd">            interface `nelems` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;_nelems is deprecated and will be removed. Use nelems.&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelems</span><span class="p">()</span>

<div class="viewcode-block" id="Var.name"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Var.html#spacepy.pycdf.Var.name">[docs]</a>    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of this variable</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : str</span>
<span class="sd">            variable&#39;s name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span></div>

<div class="viewcode-block" id="Var.compress"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Var.html#spacepy.pycdf.Var.compress">[docs]</a>    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comptype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set or check the compression of this variable</span>

<span class="sd">        Compression may not be changeable on variables with data already</span>
<span class="sd">        written; even deleting the data may not permit the change.</span>

<span class="sd">        See section 2.6 of the CDF user&#39;s guide for more information on</span>
<span class="sd">        compression.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        comptype : ctypes.c_long</span>
<span class="sd">            type of compression to change to, see CDF C reference</span>
<span class="sd">            manual section 4.10. Constants for this parameter</span>
<span class="sd">            are in :mod:`~spacepy.pycdf.const`. If not specified, will not</span>
<span class="sd">            change compression.</span>
<span class="sd">        param : ctypes.c_long</span>
<span class="sd">            Compression parameter, see CDF CRM 4.10 and</span>
<span class="sd">            :mod:`~spacepy.pycdf.const`.</span>
<span class="sd">            If not specified, will choose reasonable default (5 for</span>
<span class="sd">            gzip; other types have only one possible parameter.)</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : tuple</span>
<span class="sd">            the (comptype, param) currently in effect</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comptype</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span></div>

<div class="viewcode-block" id="Var.copy"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Var.html#spacepy.pycdf.Var.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copies all data and attributes from this variable</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :class:`VarCopy`</span>
<span class="sd">            list of all data in record order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">VarCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Var.rename"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Var.html#spacepy.pycdf.Var.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames this variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        new_name : str</span>
<span class="sd">            the new name for this variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">enc_name</span> <span class="o">=</span> <span class="n">new_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">enc_name</span> <span class="o">=</span> <span class="n">new_name</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enc_name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_VAR_NAME_LEN256</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_VAR_NAME</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NAME_</span><span class="p">,</span> <span class="n">enc_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">add_to_cache</span><span class="p">(</span>
            <span class="n">enc_name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">var_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">))</span> <span class="c1">#Still in cache</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_var_nums</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">enc_name</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides the numpy array-like shape of this variable.</span>

<span class="sd">        Returns a tuple; first element is number of records (RV variable</span>
<span class="sd">        only) And the rest provide the dimensionality of the variable.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Assigning to this attribute will not change the shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide the numpy dtype equivalent to the CDF type of this variable.</span>

<span class="sd">        Data from this variable will be returned in numpy arrays of this type.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">str</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bytes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;U&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nelems</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_np_type</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get attribute list</span>

<span class="sd">        Provide access to the zVar&#39;s attribute list without holding a</span>
<span class="sd">        strong reference, as the attribute list has a (strong)</span>
<span class="sd">        back-reference to its parent.</span>

<span class="sd">        Either deref a weak reference (to try and keep the object the same),</span>
<span class="sd">        or make a new AttrList instance and assign it to the weak reference</span>
<span class="sd">        for next time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">al</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">al</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">al</span> <span class="o">=</span> <span class="n">zAttrList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">al</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">al</span>

    <span class="k">def</span> <span class="nf">_set_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign to the attribute list</span>

<span class="sd">        Clears all elements of the attribute list and copies from value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">_get_attrs</span><span class="p">,</span> <span class="n">_set_attrs</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
        <span class="sd">&quot;&quot;&quot;zAttributes for this zVariable in a dict-like format.</span>
<span class="sd">        See :class:`zAttrList` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="VarCopy"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.VarCopy.html#spacepy.pycdf.VarCopy">[docs]</a><span class="k">class</span> <span class="nc">VarCopy</span><span class="p">(</span><span class="n">spacepy</span><span class="o">.</span><span class="n">datamodel</span><span class="o">.</span><span class="n">dmarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A list-like copy of the data and attributes in a :class:`Var`</span>

<span class="sd">    Data are in the list elements. CDF attributes are in a dict,</span>
<span class="sd">    accessed through :attr:`attrs`. (I.e.,</span>
<span class="sd">    data and attributes are accessed like in a :class:`Var`.)</span>

<span class="sd">    Do not instantiate this class directly; use :meth:`~Var.copy`</span>
<span class="sd">    on an existing :class:`Var`.</span>

<span class="sd">    Several methods provide access to details about how the original</span>
<span class="sd">    variable was constructed. This is mostly for making it easier to</span>
<span class="sd">    reproduce the variable by passing it to</span>
<span class="sd">    :meth:`~spacepy.pycdf.CDF.new`. Operations that e.g. change the</span>
<span class="sd">    dimensionality of the copy may make this (or any) metadata out of</span>
<span class="sd">    date; see :meth:`set` to update.</span>

<span class="sd">    .. autosummary::</span>

<span class="sd">        compress</span>
<span class="sd">        dv</span>
<span class="sd">        nelems</span>
<span class="sd">        rv</span>
<span class="sd">        set</span>
<span class="sd">        type</span>

<span class="sd">    .. attribute:: attrs</span>

<span class="sd">       Python dictionary containing attributes copied from the zVar</span>

<span class="sd">    .. automethod:: compress</span>
<span class="sd">    .. automethod:: dv</span>
<span class="sd">    .. automethod:: nelems</span>
<span class="sd">    .. automethod:: rv</span>
<span class="sd">    .. automethod:: set</span>
<span class="sd">    .. automethod:: type</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Allowed_Attributes</span> <span class="o">=</span> <span class="n">spacepy</span><span class="o">.</span><span class="n">datamodel</span><span class="o">.</span><span class="n">dmarray</span><span class="o">.</span><span class="n">Allowed_Attributes</span> \
                         <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;_cdf_meta&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">zVar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies all data and attributes from a zVariable</span>

<span class="sd">        @param zVar: variable to take data from</span>
<span class="sd">        @type zVar: :py:class:`pycdf.Var`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">VarCopy</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">zVar</span><span class="p">[</span><span class="o">...</span><span class="p">],</span> <span class="n">zVar</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_cdf_meta</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;compress&#39;</span><span class="p">:</span> <span class="n">zVar</span><span class="o">.</span><span class="n">compress</span><span class="p">(),</span>
            <span class="s1">&#39;dv&#39;</span><span class="p">:</span> <span class="n">zVar</span><span class="o">.</span><span class="n">dv</span><span class="p">(),</span>
            <span class="s1">&#39;nelems&#39;</span><span class="p">:</span> <span class="n">zVar</span><span class="o">.</span><span class="n">nelems</span><span class="p">(),</span>
            <span class="s1">&#39;rv&#39;</span><span class="p">:</span> <span class="n">zVar</span><span class="o">.</span><span class="n">rv</span><span class="p">(),</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">zVar</span><span class="o">.</span><span class="n">type</span><span class="p">(),</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="n">obj</span>

<div class="viewcode-block" id="VarCopy.compress"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.VarCopy.html#spacepy.pycdf.VarCopy.compress">[docs]</a>    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets compression of the variable this was copied from.</span>

<span class="sd">        For details on CDF compression, see</span>
<span class="sd">        :meth:`spacepy.pycdf.Var.compress`.</span>

<span class="sd">        If any arguments are specified, calls</span>
<span class="sd">        :meth:`numpy.ndarray.compress` instead (as the names conflict)</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        tuple</span>
<span class="sd">            compression type, parameter currently in effect.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">VarCopy</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_meta</span><span class="p">[</span><span class="s1">&#39;compress&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="VarCopy.dv"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.VarCopy.html#spacepy.pycdf.VarCopy.dv">[docs]</a>    <span class="k">def</span> <span class="nf">dv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets dimension variance of the variable this was copied from.</span>

<span class="sd">        Each dimension other than the record dimension may either vary</span>
<span class="sd">        or not.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        list of boolean</span>
<span class="sd">            True if that dimension has variance, else False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_meta</span><span class="p">[</span><span class="s1">&#39;dv&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="VarCopy.nelems"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.VarCopy.html#spacepy.pycdf.VarCopy.nelems">[docs]</a>    <span class="k">def</span> <span class="nf">nelems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets number of elements of the variable this was copied from.</span>

<span class="sd">        This is usually 1 except for strings, where it is the length of the</span>
<span class="sd">        string.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        int</span>
<span class="sd">            Number of elements in parent variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_meta</span><span class="p">[</span><span class="s1">&#39;nelems&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="VarCopy.rv"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.VarCopy.html#spacepy.pycdf.VarCopy.rv">[docs]</a>    <span class="k">def</span> <span class="nf">rv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets record variance of the variable this was copied from.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        boolean</span>
<span class="sd">            True if parent variable was record varying, False if NRV</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_meta</span><span class="p">[</span><span class="s1">&#39;rv&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="VarCopy.set"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.VarCopy.html#spacepy.pycdf.VarCopy.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set CDF metadata</span>

<span class="sd">        Set the metadata describing the original variable this was</span>
<span class="sd">        copied from. Can be used to update the metadata if</span>
<span class="sd">        transformation of the copy has made it out of date (e.g. by</span>
<span class="sd">        removing dimensions.) There is very little checking done and</span>
<span class="sd">        this function should only be used with care.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        key : str</span>
<span class="sd">            Which metadata to set; this matches the name of the method</span>
<span class="sd">            used to retrieve it (e.g. use ``type`` to set the CDF type, which</span>
<span class="sd">            is returned by :meth:`type`).</span>
<span class="sd">        value</span>
<span class="sd">            Value to assign to `key`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_meta</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Invalid CDF metadata key </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_meta</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="VarCopy.type"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.VarCopy.html#spacepy.pycdf.VarCopy.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns CDF type of the variable this was copied from.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        int</span>
<span class="sd">            CDF type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_meta</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span></div></div>


<span class="k">class</span> <span class="nc">_Hyperslice</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a CDF &#39;slice&#39; used for the hyper CDF functions</span>

<span class="sd">    For internal module use only.</span>

<span class="sd">    @ivar dims: number of dimensions to this slice, usually</span>
<span class="sd">                number of dimensions to the variable plus one</span>
<span class="sd">                for the record, which represents the 0th</span>
<span class="sd">                (least rapidly varying) dimension.</span>
<span class="sd">    @type dims: int</span>
<span class="sd">    @ivar dimsizes: size of each dimension (0th is number of records)</span>
<span class="sd">    @type dimsizes: list of int</span>
<span class="sd">    @ivar starts: index of the start value for each dimension</span>
<span class="sd">                  (&#39;dimension indices&#39; in CDF speak)</span>
<span class="sd">    @type starts: list of int</span>
<span class="sd">    @ivar counts: number of values to get from each dimension.</span>
<span class="sd">                  Final result will be the product of everything</span>
<span class="sd">                  in counts.</span>
<span class="sd">                  (&#39;dimension counts&#39; in CDF speak)</span>
<span class="sd">    @type counts: numpy.array</span>
<span class="sd">    @ivar intervals: interval between successive indices</span>
<span class="sd">                     to use for each dimension.</span>
<span class="sd">                     (&#39;dimension invervals&#39; in CDF speak)</span>
<span class="sd">    @type intervals: list of int</span>
<span class="sd">    @ivar degen: is this dimension degenerate, i.e. should be</span>
<span class="sd">                 removed in the returned dataset. A 3D array</span>
<span class="sd">                 with one dimension degenerate will be returned</span>
<span class="sd">                 as a 2D array (i.e. list-of-lists.)</span>
<span class="sd">    @type degen: numpy.array</span>
<span class="sd">    @ivar rev: should this dimension be returned in reverse order?</span>
<span class="sd">    @type rev: numpy.array</span>
<span class="sd">    @ivar column: is this slice in column-major mode (if false, row-major)</span>
<span class="sd">    @type column: boolean</span>
<span class="sd">    @ivar zvar: what CDF variable this object slices on</span>
<span class="sd">    @type zvar: :py:class:`pycdf.Var`</span>
<span class="sd">    @ivar expanded_key: fully-expanded version of the key passed to the</span>
<span class="sd">                        constructor (all dimensions filled in)</span>
<span class="sd">    @type expanded_key: tuple</span>
<span class="sd">    @note: All dimension-related variables are stored row-major</span>
<span class="sd">           (Python order)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zvar</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a Hyperslice</span>

<span class="sd">        @param zvar: zVariable that this slices</span>
<span class="sd">        @type zvar: :py:class:`pycdf.Var`</span>
<span class="sd">        @param key: Python multi-dimensional slice as passed to</span>
<span class="sd">                    __getitem__</span>
<span class="sd">        @type key: tuple of slice and/or int</span>
<span class="sd">        @raise IndexError: if slice is out of range, mismatches dimensions, or</span>
<span class="sd">                           otherwise unparsable.</span>
<span class="sd">        @raise ValueError: if slice has invalid values</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span> <span class="o">=</span> <span class="n">zvar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">rv</span><span class="p">()</span>
        <span class="c1">#dim of records, + 1 record dim (NRV always is record 0)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="n">zvar</span><span class="o">.</span><span class="n">_n_dims</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimsizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">zvar</span><span class="p">)]</span> <span class="o">+</span> \
                        <span class="n">zvar</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">starts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degen</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rev</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="c1">#key is:</span>
        <span class="c1">#1. a single value (integer or slice object) if called 1D</span>
        <span class="c1">#2. a tuple (of integers and/or slice objects) if called nD</span>
        <span class="c1">#3. Each item is either a single value (degenerate dim)</span>
        <span class="c1">#   or a slice object.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span> <span class="c1">#Not a container object, pack in tuple</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">key</span> <span class="c1">#NRV, so always get 0th record (degenerate)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_ellipsis</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span><span class="p">:</span> <span class="c1">#special-cases for RV variables</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">#get all data for this record(s)</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_ellipsis</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">#get same slice from each record</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">key</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expanded_key</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">):</span> <span class="c1">#slice</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> \
                     <span class="bp">self</span><span class="o">.</span><span class="n">convert_range</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span>
                                              <span class="n">idx</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#Single degenerate value</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index out of range&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Slice does not match dimensions for zVar &#39;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">zvar</span><span class="o">.</span><span class="n">_name</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">zvar</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">col_major</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">expected_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate size of non-degenerate dimensions</span>

<span class="sd">        Figures out size, in each dimension, of expected input data</span>

<span class="sd">        @return: size of each dimension for this slice, excluding degenerate</span>
<span class="sd">        @rtype: list of int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expands the record dimension of this slice to hold a set of data</span>

<span class="sd">        If the length of data (outermost dimension) is larger than the record</span>
<span class="sd">        count (counts[0]) for this slice, expand the slice to hold all the data.</span>
<span class="sd">        This requires that the record dimension of the slice not be degenerate,</span>
<span class="sd">        and also that it not have been completely specified when the hyperslice</span>
<span class="sd">        was created (i.e. record dimension either ellipsis or no specified</span>
<span class="sd">        stop.)</span>

<span class="sd">        Does *not* expand any other dimension, since that&#39;s Very Hard in CDF.</span>

<span class="sd">        @param data: the data which are intended to be stored in this slice</span>
<span class="sd">        @type data: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rec_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">str_classes</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> \
               <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rec_slice</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c1">#Truncate to fit data</span>
            <span class="k">if</span> <span class="n">rec_slice</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rec_slice</span><span class="o">.</span><span class="n">step</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c1">#Expand to fit data</span>
            <span class="k">if</span> <span class="n">rec_slice</span><span class="o">.</span><span class="n">step</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a numpy array to hold the data from this slice</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : numpy.array</span>
<span class="sd">            array sized, typed, and dimensioned to hold data from</span>
<span class="sd">            this slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span>
        <span class="n">degen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degen</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            <span class="n">degen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">degen</span><span class="p">)</span>
        <span class="c1">#TODO: Forcing C order for now, revert to using self.column later</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">[</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">degen</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">_np_type</span><span class="p">(),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">))</span>
                           
    <span class="k">def</span> <span class="nf">convert_input_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a buffer of raw data from this slice</span>

<span class="sd">        EPOCH(16) variables always need to be converted.</span>
<span class="sd">        CHAR need converted to Unicode if py3k</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        buffer : numpy.array</span>
<span class="sd">            data as read from the CDF file</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : numpy.array</span>
<span class="sd">            converted data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flip_array</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>

        <span class="c1">#Convert to derived types</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="nb">str</span> <span class="o">!=</span> <span class="nb">bytes</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;U</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(),</span>
                                       <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_epoch_to_datetime</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_epoch16_to_datetime</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_tt2000_to_datetime</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">convert_output_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a buffer of data that will go into this slice</span>
<span class="sd">         </span>
<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        buffer : numpy.array</span>
<span class="sd">        data to go into the CDF file</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : numpy.array</span>
<span class="sd">        input with majority flipped and dimensions reversed to be</span>
<span class="sd">        suitable to pass directly to CDF library.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flip_array</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_flip_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operations for majority, etc. common between convert_input and _output</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="c1">#Flip majority if any non-degenerate dimensions exist</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">):</span>
            <span class="c1">#Record-number dim degen, swap whole thing</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="c1">#Maintain last dimension</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                        <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
                        <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="c1">#Record-number dimension is not degenerate, so keep it first</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
                        <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="c1">#Reverse non-degenerate dimensions in rev</span>
        <span class="c1">#Remember that the degenerate indices are already gone!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rev</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">sliced</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="c1">#don&#39;t reverse last dim</span>
                <span class="n">sliced</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sliced</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Selects this hyperslice in the CDF</span>

<span class="sd">        Calls the CDF library to select the CDF, variable, records, and</span>
<span class="sd">        array elements corresponding to this slice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECNUMBER_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECCOUNT_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECINTERVAL_</span><span class="p">,</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">args</span> <span class="o">+=</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMINDICES_</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">dims</span><span class="p">)(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                     <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMCOUNTS_</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">dims</span><span class="p">)(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                     <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMINTERVALS_</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">dims</span><span class="p">)(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">expand_ellipsis</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expands any ellipses into correct number of full-size slices</span>

<span class="sd">        @param slices: tuple of slices, integers, or ellipse objects</span>
<span class="sd">        @type slices: tuple</span>
<span class="sd">        @param n_dims: number of dimensions this slice is over</span>
<span class="sd">        @type n_dims: int</span>
<span class="sd">        @return: L{slices} with ellipses replaced by appropriate number of</span>
<span class="sd">                 full-dimension slices</span>
<span class="sd">        @rtype: tuple</span>
<span class="sd">        @raise IndexError: if ellipses specified when already have enough</span>
<span class="sd">                           dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">slices</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dims</span><span class="p">)])</span>
        <span class="c1">#Elements might be numpy arrays, so can&#39;t use in/index</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span> <span class="c1">#no ellipsis</span>
            <span class="k">return</span> <span class="n">slices</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">#multiples!</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Ellipses can only be used once per slice.&#39;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#how many dims to expand ellipsis to</span>
        <span class="c1">#remember the ellipsis is in len(slices) and must be replaced!</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">n_dims</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">extra</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;too many indices&#39;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="p">)</span> <span class="o">*</span> <span class="n">extra</span> <span class="o">+</span> <span class="n">slices</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_well_formed</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if input data is well-formed, regular array&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">object</span><span class="p">:</span> <span class="c1">#this is probably going to be bad</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="c1">#Completely empty, so &quot;well-formed&quot; enough</span>
                <span class="k">return</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span> <span class="c1">#at least it&#39;s not a list</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Data must be well-formed, regular array of number, &#39;</span>
                    <span class="s1">&#39;string, or datetime&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds the dimensions of a nested list-of-lists</span>

<span class="sd">        @param data: data of which dimensions are desired</span>
<span class="sd">        @type data: list (of lists)</span>
<span class="sd">        @return: dimensions of L{data}, in order outside-in</span>
<span class="sd">        @rtype: list of int</span>
<span class="sd">        @raise ValueError: if L{data} has irregular dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">_Hyperslice</span><span class="o">.</span><span class="n">check_well_formed</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">backward</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find dimensions and valid types of a nested list-of-lists</span>

<span class="sd">        Any given data may be representable by a range of CDF types; infer</span>
<span class="sd">        the CDF types which can represent this data. This breaks down to:</span>
<span class="sd">          1. Proper kind (numerical, string, time)</span>
<span class="sd">          2. Proper range (stores highest and lowest number)</span>
<span class="sd">          3. Sufficient resolution (EPOCH16 required if datetime has</span>
<span class="sd">             microseconds or below.)</span>

<span class="sd">        If more than one value satisfies the requirements, types are returned</span>
<span class="sd">        in preferred order:</span>
<span class="sd">          1. Type that matches precision of data first, then</span>
<span class="sd">          2. integer type before float type, then</span>
<span class="sd">          3. Smallest type first, then</span>
<span class="sd">          4. signed type first, then</span>
<span class="sd">          5. specifically-named (CDF_BYTE) vs. generically named (CDF_INT1)</span>
<span class="sd">        So for example, EPOCH_16 is preferred over EPOCH if L{data} specifies</span>
<span class="sd">        below the millisecond level (rule 1), but otherwise EPOCH is preferred</span>
<span class="sd">        (rule 2).</span>

<span class="sd">        For floats, four-byte is preferred unless eight-byte is required:</span>
<span class="sd">          1. absolute values between 0 and 3e-39</span>
<span class="sd">          2. absolute values greater than 1.7e38</span>
<span class="sd">        This will switch to an eight-byte double in some cases where four bytes</span>
<span class="sd">        would be sufficient for IEEE 754 encoding, but where DEC formats would</span>
<span class="sd">        require eight.</span>

<span class="sd">        @param data: data for which dimensions and CDF types are desired</span>
<span class="sd">        @type data: list (of lists)</span>
<span class="sd">        @param backward: limit to pre-CDF3 types</span>
<span class="sd">        @type backward: bool</span>
<span class="sd">        @return: dimensions of L{data}, in order outside-in;</span>
<span class="sd">                 CDF types which can represent this data;</span>
<span class="sd">                 number of elements required (i.e. length of longest string)</span>
<span class="sd">        @rtype: 3-tuple of lists ([int], [ctypes.c_long], [int])</span>
<span class="sd">        @raise ValueError: if L{data} has irregular dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">_Hyperslice</span><span class="o">.</span><span class="n">check_well_formed</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">):</span> <span class="c1">#it&#39;s a string</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="p">]</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="c1">#UTF-8 uses 4 bytes per</span>
                <span class="n">elements</span> <span class="o">//=</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;microsecond&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">max</span><span class="p">((</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">%</span> <span class="mi">1000</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="p">,</span>
                         <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="p">,</span>
                         <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">backward</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">types</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="p">)]</span>
                <span class="k">del</span> <span class="n">types</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">supports_int8</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">types</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">data</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">generic</span><span class="p">):</span>
            <span class="c1">#numpy array came in, use its type (or byte-swapped)</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span>
                     <span class="k">if</span> <span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span>
                         <span class="ow">or</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">())</span>
                     <span class="ow">and</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">timetypes</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">supports_int8</span> <span class="ow">or</span> <span class="n">backward</span><span class="p">)</span> \
               <span class="ow">and</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">types</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">)]</span>
            <span class="c1">#Maintain priority to match the ordered lists below:</span>
            <span class="c1">#float/double (44, 45) before real (21/22), and</span>
            <span class="c1">#byte (41) before int (1) before char (51). So hack.</span>
            <span class="c1">#Consider making typedict an ordered dict once 2.6 is dead.</span>
            <span class="n">types</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">50</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="p">:</span> <span class="c1">#not a numpy array, or can&#39;t parse its type</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="c1">#Object. Try to make it numeric</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Cannot determine CDF type of empty object array.&#39;</span><span class="p">)</span>
                <span class="c1">#Can&#39;t do safe casting from Object, so try and compare</span>
                <span class="c1">#Basically try most restrictive to least restrictive</span>
                <span class="n">trytypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trytypes</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">newd</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span> <span class="c1">#Failure to cast, try next type</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">newd</span> <span class="o">==</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span> <span class="c1">#Values preserved, use this type</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">newd</span>
                        <span class="c1">#Continue with normal guessing, as if a list</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#fell through without a match</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Cannot convert generic objects to CDF type.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">):</span> <span class="c1">#integer</span>
                <span class="n">minval</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">maxval</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">minval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_BYTE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT1</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT2</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT4</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
                    <span class="n">cutoffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">63</span><span class="p">,</span>
                               <span class="mf">1.7e38</span><span class="p">,</span> <span class="mf">1.7e38</span><span class="p">,</span> <span class="mf">8e307</span><span class="p">,</span> <span class="mf">8e307</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_BYTE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT1</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT1</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT2</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT2</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT4</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT4</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
                    <span class="n">cutoffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">8</span><span class="p">,</span>
                               <span class="mi">2</span> <span class="o">**</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">63</span><span class="p">,</span>
                               <span class="mf">1.7e38</span><span class="p">,</span> <span class="mf">1.7e38</span><span class="p">,</span> <span class="mf">8e307</span><span class="p">,</span> <span class="mf">8e307</span><span class="p">]</span>
                <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">cutoffs</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">maxval</span>
                         <span class="ow">and</span> <span class="p">(</span><span class="n">minval</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">minval</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">c</span><span class="p">)]</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">supports_int8</span> <span class="ow">or</span> <span class="n">backward</span><span class="p">)</span> \
                       <span class="ow">and</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">types</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#float</span>
                <span class="k">if</span> <span class="n">dims</span> <span class="o">==</span> <span class="p">():</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.7e38</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3e-39</span><span class="p">):</span>
                        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="p">,</span>
                                 <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">absolutes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">absolutes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> \
                           <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">absolutes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.7e38</span> <span class="ow">or</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">absolutes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3e-39</span><span class="p">):</span>
                        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="p">,</span>
                                 <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">]</span>
        <span class="c1">#If data has a type, might be a VarCopy, prefer that type</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="c1">#If passed array, types prefers its dtype, so try for compatible</span>
            <span class="c1">#and let type() override</span>
            <span class="k">elif</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="c1">#And if the VarCopy specifies a number of elements, use that</span>
        <span class="c1">#if compatible</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;nelems&#39;</span><span class="p">):</span>
            <span class="n">ne</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">nelems</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ne</span> <span class="o">&gt;</span> <span class="n">elements</span><span class="p">:</span>
                <span class="n">elements</span> <span class="o">=</span> <span class="n">ne</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorders seq to switch array majority</span>

<span class="sd">        Used to take an array of subscripts between row</span>
<span class="sd">        and column majority. First element is not touched,</span>
<span class="sd">        being the record number.</span>

<span class="sd">        @param seq: a sequence of *subscripts*</span>
<span class="sd">        @type seq: sequence of integers</span>
<span class="sd">        @return: seq with all but element 0 reversed in order</span>
<span class="sd">        @rtype: sequence of integers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="n">numpy</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">seq</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a start/stop/step range to start/count/interval</span>

<span class="sd">        (i.e. changes from Python-style slice to CDF-style)</span>
<span class="sd">        @param start: index to start a slice at, may be none or negative</span>
<span class="sd">        @type start: int</span>
<span class="sd">        @param stop: index at end of slice (one-past, standard Python),</span>
<span class="sd">                     may be none or negative</span>
<span class="sd">        @type stop: int</span>
<span class="sd">        @param step: interval for stepping through stlice</span>
<span class="sd">        @type step: int</span>
<span class="sd">        @param size: size of list to slice</span>
<span class="sd">        @type size: int</span>
<span class="sd">        @return: (start, count, interval, rev) where:</span>
<span class="sd">                   1. start is the start index, normalized to be within</span>
<span class="sd">                      the size of the list and negatives handled</span>
<span class="sd">                   2. count is the number of records in the slice,</span>
<span class="sd">                      guaranteed to stop before the end</span>
<span class="sd">                   3. interval is the skip between records</span>
<span class="sd">                   4. rev indicates whether the sequence should be reversed</span>
<span class="sd">        @rtype: (int, int, int, boolean)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">start</span> <span class="o">-</span> <span class="n">stop</span> <span class="o">+</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>
            <span class="n">rev</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
            <span class="n">rev</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">rev</span><span class="p">)</span>


<div class="viewcode-block" id="Attr"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Attr.html#spacepy.pycdf.Attr">[docs]</a><span class="k">class</span> <span class="nc">Attr</span><span class="p">(</span><span class="n">MutableSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An attribute, g or z, for a CDF</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This class should not be used directly, but only in its</span>
<span class="sd">        subclasses, :class:`gAttr` and :class:`zAttr`. The methods</span>
<span class="sd">        listed here are safe to use in the subclasses.</span>

<span class="sd">    Represents a CDF attribute, providing access to the Entries in a format</span>
<span class="sd">    that looks like a Python</span>
<span class="sd">    list. General list information is available in the python docs:</span>
<span class="sd">    `1 &lt;http://docs.python.org/tutorial/introduction.html#lists&gt;`_,</span>
<span class="sd">    `2 &lt;http://docs.python.org/tutorial/datastructures.html#more-on-lists&gt;`_,</span>
<span class="sd">    `3 &lt;http://docs.python.org/library/stdtypes.html#typesseq&gt;`_.</span>

<span class="sd">    An introduction to CDF attributes can be found in section 2.4 of</span>
<span class="sd">    the CDF user&#39;s guide.</span>

<span class="sd">    Each element of the list is a single Entry of the appropriate type.</span>
<span class="sd">    The index to the elements is the Entry number.</span>

<span class="sd">    Multi-dimensional slicing is *not* supported; an Entry with multiple</span>
<span class="sd">    elements will have all elements returned (and can thus be sliced itself).</span>
<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; first_three = attribute[5, 0:3] #will fail</span>
<span class="sd">        &gt;&gt;&gt; first_three = attribute[5][0:3] #first three elements of 5th Entry</span>

<span class="sd">    .. autosummary::</span>

<span class="sd">        ~Attr.append</span>
<span class="sd">        ~Attr.has_entry</span>
<span class="sd">        ~Attr.insert</span>
<span class="sd">        ~Attr.max_idx</span>
<span class="sd">        ~Attr.new</span>
<span class="sd">        ~Attr.number</span>
<span class="sd">        ~Attr.rename</span>
<span class="sd">        ~Attr.type</span>

<span class="sd">    .. automethod:: append</span>
<span class="sd">    .. automethod:: has_entry</span>
<span class="sd">    .. automethod:: insert</span>
<span class="sd">    .. automethod:: max_idx</span>
<span class="sd">    .. automethod:: new</span>
<span class="sd">    .. automethod:: number</span>
<span class="sd">    .. automethod:: rename</span>
<span class="sd">    .. automethod:: type</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdf_file</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize this attribute</span>

<span class="sd">        @param cdf_file: CDF file containing this attribute</span>
<span class="sd">        @type cdf_file: :py:class:`pycdf.CDF`</span>
<span class="sd">        @param attr_name: Name of this attribute</span>
<span class="sd">        @type attr_name: str</span>
<span class="sd">        @param create: True to create attribute, False to look up existing.</span>
<span class="sd">        @type create: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span> <span class="o">=</span> <span class="n">cdf_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">str_classes</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">attr_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">attr_name</span>
            <span class="n">attrno</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">create</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CREATE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SCOPE</span><span class="p">,</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">attrno</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">add_attr_to_cache</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">attrno</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SCOPE</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">GLOBAL_SCOPE</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#Ensure exists, and populate cache. See scope note below</span>
                <span class="n">attrno</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">attr_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_ATTR_NAME_LEN256</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_</span><span class="p">,</span>
                                 <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">attr_name</span><span class="p">))</span>
            <span class="c1">#Because it&#39;s possible to create a gAttr Python object</span>
            <span class="c1">#referencing an Attribute with variable scope, and vice-versa,</span>
            <span class="c1">#do NOT assume the scope matches</span>
            <span class="c1">#(Higher level code checks for that being a bad thing.)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
                <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NAME_</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_SCOPE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">scope</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">scope</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">GLOBAL_SCOPE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">scope</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">scope</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">VARIABLE_SCOPE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">scope</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_SCOPE</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">add_attr_to_cache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a slice of Entries.</span>

<span class="sd">        Because Attributes may be sparse, a multi-element slice will return</span>
<span class="sd">        None for those elements which do not have associated Entries.</span>

<span class="sd">        @param key: index or range of Entry number to return</span>
<span class="sd">        @type key: slice or int</span>
<span class="sd">        @return: a list of entries, appropriate type.</span>
<span class="sd">        @raise IndexError: if L{key} is an int and that Entry number does not</span>
<span class="sd">                           exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_entry</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; out of range.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_other_entries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to get the type of this entry from others in the Attribute</span>

<span class="sd">        For zAttrs, checks if all other Entries are the same type, and at</span>
<span class="sd">        least one doesn&#39;t match its zVar, i.e. Entry type dominates (otherwise</span>
<span class="sd">        assumption is the Var type dominates).</span>

<span class="sd">        For gAttrs, checks all other Entries, and gives priority to the</span>
<span class="sd">        one that&#39;s earliest in the possible type list and exists in other</span>
<span class="sd">        Entries.</span>

<span class="sd">        This is only one component of Entry type guessing!</span>

<span class="sd">        :param list types: CDF types that are candidates (match the data)</span>
<span class="sd">        :return: The type discerned from other Entries, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_</span><span class="p">:</span>
            <span class="c1">#If everything else is the same entry type,</span>
            <span class="c1">#and one is not the same as its var, probably</span>
            <span class="c1">#all entries should be of that type</span>
            <span class="n">cand_et</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1">#The Entry type that might work</span>
            <span class="n">one_var_diff</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#One Var has a type different from Entry</span>
            <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">vartype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
                <span class="n">entrytype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">vartype</span> <span class="o">!=</span> <span class="n">entrytype</span><span class="p">:</span>
                    <span class="n">one_var_diff</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">cand_et</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">entrytype</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span> <span class="c1">#One var has Entry with &quot;impossible&quot; type</span>
                    <span class="n">cand_et</span> <span class="o">=</span> <span class="n">entrytype</span>
                <span class="k">elif</span> <span class="n">cand_et</span> <span class="o">!=</span> <span class="n">entrytype</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span> <span class="c1">#Two vars have Entries with different types</span>
            <span class="k">if</span> <span class="n">one_var_diff</span> <span class="ow">and</span> <span class="n">cand_et</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cand_et</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Of those types which exist in other entries,</span>
            <span class="c1"># find the one which is earliest</span>
            <span class="c1"># in types, i.e. the preferred type</span>
            <span class="n">entrytypes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span>
                          <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">num</span><span class="p">)]</span>
            <span class="n">entrytypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">et</span> <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="n">entrytypes</span> <span class="k">if</span> <span class="n">et</span> <span class="ow">in</span> <span class="n">types</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">entrytypes</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">types</span><span class="p">[</span>
                    <span class="nb">min</span><span class="p">([</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">et</span><span class="p">)</span> <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="n">entrytypes</span><span class="p">])]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a slice of Entries.</span>

<span class="sd">        @param key: index or range of Entry numbers to set</span>
<span class="sd">        @type key: slice or int</span>
<span class="sd">        @param data: the data to set these entries to. Normally each entry should</span>
<span class="sd">        be a sequence; if a scalar is provided, it is treated</span>
<span class="sd">        as a single-element list.</span>
<span class="sd">        @type data: scalar or list</span>
<span class="sd">        @raise ValueError: if size of {data} does not match size of L{key}</span>
<span class="sd">        @note: Attributes do not &#39;grow&#39; or &#39;shrink&#39; as entries are added</span>
<span class="sd">               or removed. Indexes of entries never change and there is no</span>
<span class="sd">               way to &#39;insert&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">):</span>
            <span class="c1">#Single value, promote everything a dimension</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#Iterating forward, extend slice to match data</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">)):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1">#get, and check, types and sizes for all data</span>
        <span class="c1">#checks first so don&#39;t have error after changing half the Entries</span>
        <span class="n">data_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">typelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">data_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">data_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">datum</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">datum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">typelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="o">.</span><span class="n">types</span><span class="p">(</span>
                <span class="n">datum</span><span class="p">,</span> <span class="n">backward</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">backward</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot find a matching CDF type.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Entries must be scalar or 1D.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">str_classes</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Entry strings must be scalar.&#39;</span><span class="p">)</span>
            <span class="n">entry_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="c1">#If the entry already exists, match its type</span>
                <span class="n">entry_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">entry_type</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                    <span class="n">entry_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">entry_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#Check other entries for this attribute</span>
                <span class="n">entry_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_other_entries</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">entry_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_</span><span class="p">:</span>
                <span class="c1">#Fall back to zVar type</span>
                <span class="n">vartype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">vartype</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                    <span class="n">entry_type</span> <span class="o">=</span> <span class="n">vartype</span>
            <span class="k">if</span> <span class="n">entry_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">entry_type</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">entry_type</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">timetypes</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;Assuming </span><span class="si">{}</span><span class="s1"> for time input. This will change to&#39;</span>
                        <span class="s1">&#39; TT2000 in the future, on systems which support it.&#39;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="n">entry_type</span><span class="p">]),</span>
                        <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">entry_type</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot find a matching numpy type.&#39;</span><span class="p">)</span>
            <span class="n">typelist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dims</span><span class="p">,</span> <span class="n">entry_type</span><span class="p">,</span> <span class="n">elements</span><span class="p">))</span>

        <span class="n">data_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">data_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">data_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="n">datum</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
            <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">entry_type</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span> <span class="o">=</span> <span class="n">typelist</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">datum</span><span class="p">,</span> <span class="n">entry_type</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a slice of Entries.</span>

<span class="sd">        @param key: index or range of Entry numbers to delete</span>
<span class="sd">        @type key: slice or int</span>
<span class="sd">        @note: Attributes do not &#39;grow&#39; or &#39;shrink&#39; as entries are added</span>
<span class="sd">               or removed. Indexes of entries never change and there is no</span>
<span class="sd">               way to &#39;insert&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterates over all entries in this Attribute</span>

<span class="sd">        Returns data from one entry at a time until reaches the end.</span>
<span class="sd">        @note: Returned in entry-number order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="n">current</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_entry</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterates over all entries in this Attribute</span>

<span class="sd">        Returns data from one entry at a time, starting at end and going</span>
<span class="sd">        to beginning.</span>
<span class="sd">        @note: Returned in entry-number order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">current</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_entry</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">current</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of Entries for this Attr. NOT same as max Entry number.</span>

<span class="sd">        @return: Number of Entries</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ATTR_NUMENTRIES_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns representation of an attribute</span>

<span class="sd">        Cannot return anything that can be eval&#39;d to create a copy of the</span>
<span class="sd">        attribtute, so just wrap the informal representation in angle brackets.</span>
<span class="sd">        @return: all the data in this attribute</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string representation of the attribute</span>

<span class="sd">        This is an &#39;informal&#39; representation in that it cannot be evaluated</span>
<span class="sd">        directly to create an L{Attr}.</span>

<span class="sd">        @return: all the data in this attribute</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;Attribute &quot;</span><span class="si">{0}</span><span class="s1">&quot; in closed CDF </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Attribute &quot;</span><span class="si">{0}</span><span class="s1">&quot; in closed CDF </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

<div class="viewcode-block" id="Attr.insert"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Attr.html#spacepy.pycdf.Attr.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert an entry at a particular number</span>

<span class="sd">        Inserts entry at particular number while moving all subsequent</span>
<span class="sd">        entries to one entry number later. Does not close gaps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        index : int</span>
<span class="sd">            index where to put the new entry</span>
<span class="sd">        data : </span>
<span class="sd">            data for the new entry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">max_entry</span><span class="p">:</span> <span class="c1">#Easy case</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_entry</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">number</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Attr.append"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Attr.html#spacepy.pycdf.Attr.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an entry to end of attribute</span>

<span class="sd">        Puts entry after last defined entry (does not fill gaps)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        data : </span>
<span class="sd">            data for the new entry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span></div>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select this CDF and Attr and call the CDF internal interface</span>

<span class="sd">        @param args: Passed directly to the CDF library interface.</span>
<span class="sd">        @type args: various, see :py:mod:`ctypes`.</span>
<span class="sd">        @return: CDF status from the library</span>
<span class="sd">        @rtype: ctypes.c_long</span>
<span class="sd">        @note: Terminal NULL_ is automatically added to L{args}.</span>
<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
            <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_</span><span class="p">,</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">attr_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_entry_len</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of elements in an Entry</span>

<span class="sd">        @param number: number of Entry</span>
<span class="sd">        @type number: int</span>
<span class="sd">        @return: number of elements</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; out of range.&#39;</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
            <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">number</span><span class="p">),</span>
            <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_NUMELEMS_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span>

<div class="viewcode-block" id="Attr.type"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Attr.html#spacepy.pycdf.Attr.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find or change the CDF type of a particular Entry number</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        number : int</span>
<span class="sd">            number of Entry to check or change</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        new_type</span>
<span class="sd">            type to change this Entry to, from :mod:`~spacepy.pycdf.const`.</span>
<span class="sd">            Omit to only check type.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            CDF variable type, see :mod:`~spacepy.pycdf.const`</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>
<span class="sd">        If changing types, old and new must be equivalent, see CDF</span>
<span class="sd">        User&#39;s Guide section 2.5.5 pg. 57</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_type</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">):</span>
                <span class="n">new_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">new_type</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entry_len</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>
            <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">number</span><span class="p">),</span>
                                <span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATASPEC_</span><span class="p">,</span> <span class="n">new_type</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
                                <span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ENTRY</span><span class="p">,))</span>
            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ENTRY</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; out of range.&#39;</span><span class="p">)</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">number</span><span class="p">),</span>
                            <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATATYPE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">cdftype</span><span class="p">),</span>
                            <span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ENTRY</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ENTRY</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; out of range.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cdftype</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="Attr.has_entry"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Attr.html#spacepy.pycdf.Attr.has_entry">[docs]</a>    <span class="k">def</span> <span class="nf">has_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if this attribute has a particular Entry number</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        number : int</span>
<span class="sd">            number of Entry to check or change</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : bool</span>
<span class="sd">            True if ``number`` is a valid entry number; False if not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CONFIRM_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_EXISTENCE_</span><span class="p">,</span>
                            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">number</span><span class="p">),</span>
                            <span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ENTRY</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">status</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ENTRY</span></div>

<div class="viewcode-block" id="Attr.max_idx"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Attr.html#spacepy.pycdf.Attr.max_idx">[docs]</a>    <span class="k">def</span> <span class="nf">max_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum index of Entries for this Attr</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            maximum Entry number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ATTR_MAXENTRY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="Attr.new"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Attr.html#spacepy.pycdf.Attr.new">[docs]</a>    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new Entry in this Attribute</span>

<span class="sd">        .. note:: If ``number`` is provided and an Entry with that number</span>
<span class="sd">                  already exists, it will be overwritten.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        data</span>
<span class="sd">            data to put in the Entry</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        type : int</span>
<span class="sd">            type of the new Entry, from :mod:`~spacepy.pycdf.const`</span>
<span class="sd">            (otherwise guessed from ``data``)</span>
<span class="sd">        number : int</span>
<span class="sd">            Entry number to write, default is lowest available number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">number</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
                <span class="n">number</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="o">.</span><span class="n">types</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">backward</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">backward</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#Guess based on other entries</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_other_entries</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_</span><span class="p">:</span>
            <span class="c1">#Try to match variable type</span>
                <span class="n">vartype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">[</span><span class="n">number</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">vartype</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                    <span class="nb">type</span> <span class="o">=</span> <span class="n">vartype</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">):</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_entry</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span></div>

<div class="viewcode-block" id="Attr.number"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Attr.html#spacepy.pycdf.Attr.number">[docs]</a>    <span class="k">def</span> <span class="nf">number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the attribute number for this attribute</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            attribute number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NUMBER_</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">no</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">no</span><span class="o">.</span><span class="n">value</span></div>

    <span class="k">def</span> <span class="nf">global_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine scope of this attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : bool</span>
<span class="sd">            True if global (i.e. gAttr), False if zAttr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">attr_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="Attr.rename"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.Attr.html#spacepy.pycdf.Attr.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename this attribute</span>

<span class="sd">        Renaming a zAttribute renames it for *all* zVariables in this CDF!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        new_name : str</span>
<span class="sd">             the new name of the attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">enc_name</span> <span class="o">=</span> <span class="n">new_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">enc_name</span> <span class="o">=</span> <span class="n">new_name</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enc_name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_ATTR_NAME_LEN256</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_ATTR_NAME</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NAME_</span><span class="p">,</span> <span class="n">enc_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">add_attr_to_cache</span><span class="p">(</span>
            <span class="n">enc_name</span><span class="p">,</span>
            <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">attr_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">))</span> <span class="c1">#still in cache</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_attr_info</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">enc_name</span></div>

    <span class="k">def</span> <span class="nf">_get_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read an Entry associated with this L{Attr}</span>

<span class="sd">        @param number: number of Entry to return</span>
<span class="sd">        @type number: int</span>
<span class="sd">        @return: data from entry numbered L{number}</span>
<span class="sd">        @rtype: list or str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; out of range.&#39;</span><span class="p">)</span>
        <span class="c1">#Make a big enough buffer</span>
        <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entry_len</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="n">buff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((),</span> <span class="s1">&#39;S</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_DATA_TYPE</span><span class="p">)</span>
            <span class="n">buff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">length</span><span class="p">,),</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">cdftype</span><span class="p">],</span>
                               <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">buff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">number</span><span class="p">),</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATA_</span><span class="p">,</span>
                   <span class="n">buff</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">))</span>

        <span class="c1">#decode</span>
        <span class="k">if</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">str</span> <span class="o">==</span> <span class="nb">bytes</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span> <span class="c1">#Py2k, leave as bytes</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#Py3k, make unicode</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_epoch_to_datetime</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_epoch16_to_datetime</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_tt2000_to_datetime</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">buff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">buff</span>
            <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_write_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cdf_type</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">elements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write an Entry to this Attr.</span>

<span class="sd">        @param number: number of Entry to write</span>
<span class="sd">        @type number: int</span>
<span class="sd">        @param data: data to write</span>
<span class="sd">        @param cdf_type: the CDF type to write, from :py:mod:`pycdf.const`</span>
<span class="sd">        @param dims: dimensions of L{data}</span>
<span class="sd">        @type dims: list</span>
<span class="sd">        @param elements: number of elements in L{data}, 1 unless it is a string</span>
<span class="sd">        @type elements: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_write</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cdf_type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;S&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">elements</span><span class="p">)))</span>
            <span class="n">n_write</span> <span class="o">=</span> <span class="n">elements</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">raw_in</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1">#Assume each element is pair of floats</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_epoch16</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="n">raw_in</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#Nope, not raw, was datetime</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">if</span> <span class="n">raw_in</span><span class="p">:</span> <span class="c1">#Floats passed in, extra dim of (2,)</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n_write</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_epoch</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_tt2000</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">cdf_type</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_DATA_TYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">number</span><span class="p">),</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATA_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">cdf_type</span><span class="p">),</span>
                   <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">n_write</span><span class="p">),</span>
                   <span class="n">data</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete this Attribute</span>

<span class="sd">        Also deletes all Entries associated with it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">clear_attr_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="zAttr"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.zAttr.html#spacepy.pycdf.zAttr">[docs]</a><span class="k">class</span> <span class="nc">zAttr</span><span class="p">(</span><span class="n">Attr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;zAttribute for zVariables within a CDF.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Because zAttributes are shared across all variables in a CDF,</span>
<span class="sd">        directly manipulating them may have unexpected consequences.</span>
<span class="sd">        It is safest to operate on zEntries via :class:`zAttrList`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        When accessing a zAttr, pyCDF exposes only the zEntry corresponding</span>
<span class="sd">        to the associated zVariable.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :class:`Attr`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ENTRY_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_</span>
    <span class="n">ENTRY_DATA_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_DATA_</span>
    <span class="n">SCOPE</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">VARIABLE_SCOPE</span>
    <span class="n">ENTRY_EXISTENCE_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_EXISTENCE_</span>
    <span class="n">ATTR_NUMENTRIES_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NUMzENTRIES_</span>
    <span class="n">ATTR_MAXENTRY_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_MAXzENTRY_</span>
    <span class="n">ENTRY_NUMELEMS_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_NUMELEMS_</span>
    <span class="n">ENTRY_DATATYPE_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_DATATYPE_</span>
    <span class="n">ENTRY_DATASPEC_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_DATASPEC_</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert entry at particular index number</span>

<span class="sd">        Since there can only be one zEntry per zAttr, this cannot be</span>
<span class="sd">        implemented.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        NotImplementedError : always</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add entry to end of attribute list</span>

<span class="sd">        Since there can only be one zEntry per zAttr, this cannot be</span>
<span class="sd">        implemented.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        NotImplementedError : always</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="gAttr"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.gAttr.html#spacepy.pycdf.gAttr">[docs]</a><span class="k">class</span> <span class="nc">gAttr</span><span class="p">(</span><span class="n">Attr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Global Attribute for a CDF</span>

<span class="sd">    Represents a CDF attribute, providing access to the gEntries in a format</span>
<span class="sd">    that looks like a Python list. General list information is available in</span>
<span class="sd">    the python docs:</span>
<span class="sd">    `1 &lt;http://docs.python.org/tutorial/introduction.html#lists&gt;`_,</span>
<span class="sd">    `2 &lt;http://docs.python.org/tutorial/datastructures.html#more-on-lists&gt;`_,</span>
<span class="sd">    `3 &lt;http://docs.python.org/library/stdtypes.html#typesseq&gt;`_.</span>

<span class="sd">    Normally accessed by providing a key to a :class:`gAttrList`:</span>

<span class="sd">        &gt;&gt;&gt; attribute = cdffile.attrs[&#39;attribute_name&#39;]</span>
<span class="sd">        &gt;&gt;&gt; first_gentry = attribute[0]</span>

<span class="sd">    Each element of the list is a single gEntry of the appropriate type.</span>
<span class="sd">    The index to the elements is the gEntry number.</span>

<span class="sd">    A gEntry may be either a single string or a 1D array of numerical type.</span>
<span class="sd">    Entries of numerical type (everything but CDF_CHAR and CDF_UCHAR)</span>
<span class="sd">    with a single element are returned as scalars; multiple-element entries</span>
<span class="sd">    are returned as a list. No provision is made for accessing below</span>
<span class="sd">    the entry level; the whole list is returned at once (but Python&#39;s</span>
<span class="sd">    slicing syntax can be used to extract individual items from that list.)</span>

<span class="sd">    Multi-dimensional slicing is *not* supported; an entry with multiple</span>
<span class="sd">    elements will have all elements returned (and can thus be sliced itself).</span>
<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; first_three = attribute[5, 0:3] #will fail</span>
<span class="sd">        &gt;&gt;&gt; first_three = attribute[5][0:3] #first three elements of 5th Entry</span>

<span class="sd">    gEntries are *not* necessarily contiguous; a gAttribute may have an</span>
<span class="sd">    entry 0 and entry 2 without an entry 1. :meth:`~Attr.len` will return the</span>
<span class="sd">    *number* of gEntries; use :meth:`~Attr.max_idx` to find the highest defined</span>
<span class="sd">    gEntry number and :meth:`~Attr.has_entry` to determine if a particular</span>
<span class="sd">    gEntry number exists. Iterating over all entries is also supported::</span>

<span class="sd">        &gt;&gt;&gt; entrylist = [entry for entry in attribute]</span>

<span class="sd">    Deleting gEntries will leave a &quot;hole&quot;:</span>

<span class="sd">        &gt;&gt;&gt; attribute[0:3] = [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; del attribute[1]</span>
<span class="sd">        &gt;&gt;&gt; attribute.has_entry(1)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; attribute.has_entry(2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; print attribute[0:3]</span>
<span class="sd">        [1, None, 3]</span>

<span class="sd">    Multi-element slices over nonexistent gEntries will return ``None`` where</span>
<span class="sd">    no entry exists. Single-element indices for nonexistent gEntries will</span>
<span class="sd">    raise ``IndexError``. Assigning ``None`` to a gEntry will delete it.</span>

<span class="sd">    When assigning to a gEntry, the type is chosen to match the data;</span>
<span class="sd">    subject to that constraint, it will try to match</span>
<span class="sd">    (in order):</span>

<span class="sd">        #. existing gEntry of the same number in this gAttribute</span>
<span class="sd">        #. other gEntries in this gAttribute</span>
<span class="sd">        #. data-matching constraints described in :meth:`CDF.new`.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :class:`Attr`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ENTRY_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_</span>
    <span class="n">ENTRY_DATA_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_DATA_</span>
    <span class="n">SCOPE</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">GLOBAL_SCOPE</span>
    <span class="n">ENTRY_EXISTENCE_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_EXISTENCE_</span>
    <span class="n">ATTR_NUMENTRIES_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NUMgENTRIES_</span>
    <span class="n">ATTR_MAXENTRY_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_MAXgENTRY_</span>
    <span class="n">ENTRY_NUMELEMS_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_NUMELEMS_</span>
    <span class="n">ENTRY_DATATYPE_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_DATATYPE_</span>
    <span class="n">ENTRY_DATASPEC_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_DATASPEC_</span></div>


<div class="viewcode-block" id="AttrList"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.AttrList.html#spacepy.pycdf.AttrList">[docs]</a><span class="k">class</span> <span class="nc">AttrList</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object representing a list of attributes.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This class should not be used directly, but only via its</span>
<span class="sd">        subclasses, :class:`gAttrList` and :class:`zAttrList`.</span>
<span class="sd">        Methods listed here are safe to use from the subclasses.</span>

<span class="sd">    .. autosummary::</span>

<span class="sd">        ~AttrList.clone</span>
<span class="sd">        ~AttrList.copy</span>
<span class="sd">        ~AttrList.from_dict</span>
<span class="sd">        ~AttrList.new</span>
<span class="sd">        ~AttrList.rename</span>
<span class="sd">    </span>
<span class="sd">    .. automethod:: clone</span>
<span class="sd">    .. automethod:: copy</span>
<span class="sd">    .. automethod:: from_dict</span>
<span class="sd">    .. automethod:: new</span>
<span class="sd">    .. automethod:: rename</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdf_file</span><span class="p">,</span> <span class="n">special_entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the attribute collection</span>

<span class="sd">        @param cdf_file: CDF these attributes are in</span>
<span class="sd">        @type cdf_file: :py:class:`pycdf.CDF`</span>
<span class="sd">        @param special_entry: callable which returns a &quot;special&quot; entry number,</span>
<span class="sd">        used to limit results for zAttrs to those which match the zVar</span>
<span class="sd">        (i.e. the var number)</span>
<span class="sd">        @type special_entry: callable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span> <span class="o">=</span> <span class="n">cdf_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_entry</span> <span class="o">=</span> <span class="n">special_entry</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find an Attribute by name</span>

<span class="sd">        @param name: name of the Attribute to return</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @return: attribute named L{name}</span>
<span class="sd">        @rtype: L{Attr}</span>
<span class="sd">        @raise KeyError: if there is no attribute named L{name}</span>
<span class="sd">        @raise CDFError: other errors in CDF library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attrib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AttrType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CDFError</span><span class="p">:</span>
            <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ATTR</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">if</span> <span class="n">attrib</span><span class="o">.</span><span class="n">global_scope</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: no &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span> <span class="o">+</span> <span class="s1">&#39; by that name.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">attrib</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Attribute or change its entries</span>

<span class="sd">        @param name: name of Attribute to change</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @param data: Entries to populate this Attribute with.</span>
<span class="sd">                     Any existing Entries will be deleted!</span>
<span class="sd">                     Another C{Attr} may be specified, in which</span>
<span class="sd">                     case all its entries are copied.</span>
<span class="sd">        @type data: scalar, list, or L{Attr}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">AttrList</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">entryno</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">entryno</span><span class="p">):</span>
                    <span class="n">attr</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">entryno</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">entryno</span><span class="p">),</span> <span class="n">entryno</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">str_classes</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">junk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
            <span class="n">attr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">del</span> <span class="n">attr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):]</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete an Attribute (and all its entries)</span>

<span class="sd">        @param name: name of Attribute to delete</span>
<span class="sd">        @type name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AttrType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CDFError</span><span class="p">:</span>
            <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ATTR</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">global_scope</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: not &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span><span class="p">)</span>
        <span class="n">attr</span><span class="o">.</span><span class="n">_delete</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterates over all Attr in this CDF or variable</span>

<span class="sd">        Returns name of one L{Attr} at a time until reaches the end.</span>
<span class="sd">        @note: Returned in number order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_NUMATTRS_</span><span class="p">,</span>
                             <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AttrType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">candidate</span><span class="o">.</span><span class="n">global_scope</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_entry</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
                        <span class="n">candidate</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">special_entry</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="nb">str</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">()</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns representation of attribute list</span>

<span class="sd">        Cannot return anything that can be eval&#39;d to create a copy of the</span>
<span class="sd">        list, so just wrap the informal representation in angle brackets.</span>
<span class="sd">        @return: all the data in this list of attributes</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string representation of the attribute list</span>

<span class="sd">        This is an &#39;informal&#39; representation in that it cannot be evaluated</span>
<span class="sd">        directly to create an L{AttrList}.</span>

<span class="sd">        @return: all the data in this list of attributes</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; [&#39;</span> <span class="o">+</span> <span class="n">lib</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Attr</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span>
                <span class="s1">&#39; [&#39;</span> <span class="o">+</span> <span class="n">lib</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;Attribute list in closed CDF </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Attribute list in closed CDF </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

<div class="viewcode-block" id="AttrList.clone"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.AttrList.html#spacepy.pycdf.AttrList.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clones another attribute list, or one attribute from it, into this</span>
<span class="sd">        list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        master : AttrList</span>
<span class="sd">            the attribute list to copy from. This can be any dict-like object.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        name : str (optional)</span>
<span class="sd">            name of attribute to clone (default: clone entire list)</span>
<span class="sd">        new_name : str (optional)</span>
<span class="sd">            name of the new attribute, default ``name``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clone_list</span><span class="p">(</span><span class="n">master</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clone_attr</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="AttrList.copy"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.AttrList.html#spacepy.pycdf.AttrList.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a copy of this attribute list</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : dict</span>
<span class="sd">            copy of the entries for all attributes in this list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">[:]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Attr</span><span class="p">)</span> <span class="k">else</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span></div>

<div class="viewcode-block" id="AttrList.new"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.AttrList.html#spacepy.pycdf.AttrList.new">[docs]</a>    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Attr in this AttrList</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        name : str</span>
<span class="sd">            name of the new Attribute</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        data</span>
<span class="sd">            data to put into the first entry in the new Attribute</span>
<span class="sd">        type</span>
<span class="sd">            CDF type of the first entry from :mod:`~spacepy.pycdf.const`.</span>
<span class="sd">            Only used if data are specified.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        KeyError : if the name already exists in this list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; already exists.&#39;</span><span class="p">)</span>
        <span class="c1">#A zAttr without an Entry in this zVar will be a &quot;get&quot; not &quot;create&quot;</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_entry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attr</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attr</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_entry</span><span class="p">())</span></div>

<div class="viewcode-block" id="AttrList.rename"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.AttrList.html#spacepy.pycdf.AttrList.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename an attribute in this list</span>

<span class="sd">        Renaming a zAttribute renames it for *all* zVariables in this CDF!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        old_name : str</span>
<span class="sd">            the current name of the attribute</span>
<span class="sd">        new_name : str</span>
<span class="sd">            the new name of the attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">AttrList</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="AttrList.from_dict"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.AttrList.html#spacepy.pycdf.AttrList.from_dict">[docs]</a>    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill this list of attributes from a dictionary</span>

<span class="sd">        .. deprecated:: 0.1.5</span>
<span class="sd">           Use :meth:`~spacepy.pycdf.AttrList.clone` instead; it supports</span>
<span class="sd">           cloning from dictionaries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        in_dict : dict</span>
<span class="sd">            Attribute list is populated entirely from this dictionary;</span>
<span class="sd">            all existing attributes are deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;from_dict is deprecated and will be removed. Use clone.&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_clone_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clones a single attribute from one in this list or another</span>

<span class="sd">        Copies data and types from the master attribute to the new one</span>

<span class="sd">        @param master: attribute list to copy attribute from</span>
<span class="sd">        @type master: L{AttrList}</span>
<span class="sd">        @param name: name of attribute to copy</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @param new_name: name of the new attribute, default L{name}</span>
<span class="sd">        @type new_name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">master</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_clone_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clones this attribute list from another</span>

<span class="sd">        @param master: the attribute list to copy from</span>
<span class="sd">        @type master: L{AttrList}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">master</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clone_attr</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1">#Can&#39;t iterate over a list we&#39;re changing</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">master</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_or_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve L{Attr} or create it if it doesn&#39;t exist</span>

<span class="sd">        @param name: name of the attribute to look up or create</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @return: attribute with this name</span>
<span class="sd">        @rtype: L{Attr}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AttrType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CDFError</span><span class="p">:</span>
            <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ATTR</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AttrType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attr</span><span class="o">.</span><span class="n">global_scope</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: not &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">attr</span></div>


<div class="viewcode-block" id="gAttrList"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.gAttrList.html#spacepy.pycdf.gAttrList">[docs]</a><span class="k">class</span> <span class="nc">gAttrList</span><span class="p">(</span><span class="n">AttrList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object representing *all* the gAttributes in a CDF.</span>

<span class="sd">    Normally accessed as an attribute of an open :class:`CDF`:</span>

<span class="sd">        &gt;&gt;&gt; global_attribs = cdffile.attrs</span>

<span class="sd">    Appears as a dictionary: keys are attribute names; each value is an</span>
<span class="sd">    attribute represented by a :class:`gAttr` object. To access the global</span>
<span class="sd">    attribute TEXT:</span>

<span class="sd">        &gt;&gt;&gt; text_attr = cdffile.attrs[&#39;TEXT&#39;]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :class:`AttrList`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">AttrType</span> <span class="o">=</span> <span class="n">gAttr</span>
    <span class="n">attr_name</span> <span class="o">=</span> <span class="s1">&#39;gAttribute&#39;</span>
    <span class="n">global_scope</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of gAttributes in this CDF</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            number of gAttributes in the CDF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_NUMgATTRS_</span><span class="p">,</span>
                             <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="zAttrList"><a class="viewcode-back" href="../../autosummary/spacepy.pycdf.zAttrList.html#spacepy.pycdf.zAttrList">[docs]</a><span class="k">class</span> <span class="nc">zAttrList</span><span class="p">(</span><span class="n">AttrList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object representing *all* the zAttributes in a zVariable.</span>

<span class="sd">    Normally accessed as an attribute of a :class:`Var` in an open</span>
<span class="sd">    CDF:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; epoch_attribs = cdffile[&#39;Epoch&#39;].attrs</span>

<span class="sd">    Appears as a dictionary: keys are attribute names, values are</span>
<span class="sd">    the value of the zEntry associated with the appropriate zVariable.</span>
<span class="sd">    Each vAttribute in a CDF may only have a *single* entry associated</span>
<span class="sd">    with each variable. The entry may be a string, a single numerical value,</span>
<span class="sd">    or a series of numerical values. Entries with multiple values are returned</span>
<span class="sd">    as an entire list; direct access to the individual elements is not</span>
<span class="sd">    possible.</span>

<span class="sd">    Example: finding the first dependency of (ISTP-compliant) variable</span>
<span class="sd">    ``Flux``:</span>

<span class="sd">        &gt;&gt;&gt; print cdffile[&#39;Flux&#39;].attrs[&#39;DEPEND_0&#39;]</span>

<span class="sd">    zAttributes are shared among zVariables, one zEntry allowed per zVariable.</span>
<span class="sd">    (pyCDF hides this detail.) Deleting the last zEntry for a zAttribute will</span>
<span class="sd">    delete the underlying zAttribute.</span>

<span class="sd">    zEntries are created and destroyed by the usual dict methods on the</span>
<span class="sd">    zAttrlist:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; epoch_attribs[&#39;new_entry&#39;] = [1, 2, 4] #assign a list to new zEntry</span>
<span class="sd">        &gt;&gt;&gt; del epoch_attribs[&#39;new_entry&#39;] #delete the zEntry</span>

<span class="sd">    The type of the zEntry is guessed from data provided. The type is chosen to</span>
<span class="sd">    match the data; subject to that constraint, it will try to match</span>
<span class="sd">    (in order):</span>

<span class="sd">        #. existing zEntry corresponding to this zVar</span>
<span class="sd">        #. other zEntries in this zAttribute</span>
<span class="sd">        #. the type of this zVar</span>
<span class="sd">        #. data-matching constraints described in :py:meth:`CDF.new`</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :class:`AttrList`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">AttrType</span> <span class="o">=</span> <span class="n">zAttr</span>
    <span class="n">attr_name</span> <span class="o">=</span> <span class="s1">&#39;zAttribute&#39;</span>
    <span class="n">global_scope</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zvar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the attribute collection</span>

<span class="sd">        @param zvar: zVariable these attributes are in</span>
<span class="sd">        @param zvar: :py:class:`pycdf.Var`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">zvar</span><span class="o">.</span><span class="n">cdf_file</span><span class="p">,</span> <span class="n">zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span> <span class="o">=</span> <span class="n">zvar</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find an zEntry by name</span>

<span class="sd">        @param name: name of the zAttribute to return</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @return: attribute named L{name}</span>
<span class="sd">        @rtype: L{zAttr}</span>
<span class="sd">        @raise KeyError: if there is no attribute named L{name} associated</span>
<span class="sd">                         with this zVariable</span>
<span class="sd">        @raise CDFError: other errors in CDF library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">zvar_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">attrib</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">zvar_num</span><span class="p">):</span>
            <span class="n">attrib</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_raw</span>
            <span class="k">return</span> <span class="n">attrib</span><span class="p">[</span><span class="n">zvar_num</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: no such attribute for variable &#39;</span> <span class="o">+</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete an zEntry by name</span>

<span class="sd">        @param name: name of the zEntry to delete</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @raise KeyError: if there is no attribute named L{name} associated</span>
<span class="sd">                         with this zVariable</span>
<span class="sd">        @raise CDFError: other errors in CDF library</span>
<span class="sd">        @note: If this is the only remaining entry, the Attribute will be</span>
<span class="sd">               deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">zvar_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attrib</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">zvar_num</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;: no such attribute for variable &#39;</span> <span class="o">+</span>
                           <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_name</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">attrib</span><span class="p">[</span><span class="n">zvar_num</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrib</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">attrib</span><span class="o">.</span><span class="n">_delete</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets a zEntry by name</span>

<span class="sd">        The type of the zEntry is guessed from L{data}. The type is chosen to</span>
<span class="sd">        match the data; subject to that constraint, it will try to match</span>
<span class="sd">        (in order):</span>
<span class="sd">        1. existing zEntry corresponding to this zVar</span>
<span class="sd">        2. other zEntries in this zAttribute</span>
<span class="sd">        3. the type of this zVar</span>
<span class="sd">        4. data-matching constraints described in L{_Hyperslice.types}</span>

<span class="sd">        @param name: name of zAttribute; zEntry for this zVariable will be set</span>
<span class="sd">                     in zAttribute by this name</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @raise CDFError: errors in CDF library</span>
<span class="sd">        @raise ValueError: if unable to find a valid CDF type matching L{data},</span>
<span class="sd">                           or if L{data} is the wrong dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">zAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">attr</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_raw</span>
        <span class="n">attr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">()]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of zAttributes in this variable</span>

<span class="sd">        @return: number of zAttributes in the CDF</span>
<span class="sd">                 which have entries for this variable.</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_NUMATTRS_</span><span class="p">,</span>
                             <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">zAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">candidate</span><span class="o">.</span><span class="n">global_scope</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">candidate</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">()):</span>
                    <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">length</span>

    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find or change the CDF type of a zEntry in this zVar</span>

<span class="sd">        @param name: name of the zAttr to check or change</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @param new_type: type to change it to, see :py:mod:`pycdf.const`</span>
<span class="sd">        @type new_type: ctypes.c_long</span>
<span class="sd">        @return: CDF variable type, see :py:mod:`pycdf.const`</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        @note: If changing types, old and new must be equivalent, see CDF</span>
<span class="sd">               User&#39;s Guide section 2.5.5 pg. 57</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">zvar_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attrib</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">zvar_num</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: no such attribute for variable &#39;</span> <span class="o">+</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">attrib</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">zvar_num</span><span class="p">,</span> <span class="n">new_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clone_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clones a single attribute from one in this list or another</span>

<span class="sd">        Copies data and types from the master attribute to the new one</span>

<span class="sd">        @param master: attribute list to copy attribute from</span>
<span class="sd">        @type master: L{zAttrList}</span>
<span class="sd">        @param name: name of attribute to copy</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @param new_name: name of the new attribute, default L{name}</span>
<span class="sd">        @type new_name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">master</span><span class="p">[</span><span class="n">name</span><span class="p">],</span>
                 <span class="n">master</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="https://spacepy.github.io/"">homepage</a>|&nbsp;</li>
        <li><a href="https://github.com/spacepy/spacepy">development</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>
       <li><a href="../../index.html">documentation </a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../spacepy.html" >spacepy</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spacepy.pycdf</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2020, The SpacePy Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.0.
    </div>
  </body>
</html>