
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spacepy.pybats.bats &#8212; SpacePy v0.2.2 Manual</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    
    <link rel="shortcut icon" href="../../../_static/spacepy_favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/spacepy_logo.jpg" border="0" alt="spacepy_logo"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="https://spacepy.github.io/"">homepage</a>|&nbsp;</li>
        <li><a href="https://github.com/spacepy/spacepy">development</a>|&nbsp;</li>
        <li><a href="../../../search.html">search</a>|&nbsp;</li>
       <li><a href="../../../index.html">documentation </a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../spacepy.html" >spacepy</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../pybats.html" accesskey="U">spacepy.pybats</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spacepy.pybats.bats</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spacepy.pybats.bats</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">A PyBats module for handling input, output, and visualization of </span>
<span class="sd">binary SWMF output files taylored to BATS-R-US-type data.</span>

<span class="sd">.. currentmodule:: spacepy.pybats.bats</span>

<span class="sd">.. rubric:: Classes</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :template: clean_class.rst</span>
<span class="sd">    :toctree:</span>

<span class="sd">    BatsLog</span>
<span class="sd">    Stream</span>
<span class="sd">    Bats2d</span>
<span class="sd">    Mag</span>
<span class="sd">    MagFile</span>
<span class="sd">    GeoIndexFile</span>
<span class="sd">    VirtSat</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">spacepy.pybats</span> <span class="kn">import</span> <span class="n">PbData</span><span class="p">,</span> <span class="n">IdlFile</span><span class="p">,</span> <span class="n">LogFile</span>
<span class="kn">import</span> <span class="nn">spacepy.plot.apionly</span>
<span class="kn">from</span> <span class="nn">spacepy.plot</span> <span class="kn">import</span> <span class="n">set_target</span><span class="p">,</span> <span class="n">applySmartTimeTicks</span>
<span class="kn">from</span> <span class="nn">spacepy.datamodel</span> <span class="kn">import</span> <span class="n">dmarray</span>

<span class="c1">#### Module-level variables:</span>
<span class="c1"># recognized species:</span>
<span class="n">mass</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;hp&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;op&#39;</span><span class="p">:</span><span class="mf">16.0</span><span class="p">,</span> <span class="s1">&#39;he&#39;</span><span class="p">:</span><span class="mf">4.0</span><span class="p">,</span> 
        <span class="s1">&#39;sw&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">:</span><span class="mf">16.0</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;iono&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">}</span>

<span class="n">RE</span> <span class="o">=</span> <span class="mi">6371000</span> <span class="c1"># Earth radius in meters.</span>

<span class="c1">#### Module-level functions:</span>

<span class="k">def</span> <span class="nf">_calc_ndens</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given an object of subclass :class:`~spacepy.pybats.PbData` that uses</span>
<span class="sd">    standard BATS-R-US variable names, calculate the number density from</span>
<span class="sd">    all mass density variables (i.e., all variables that end in *rho*).</span>
<span class="sd">    New variables are added to the object.  Variable names are constructed</span>
<span class="sd">    by taking the mass-density variable, *Speciesrho*, and replacing *rho*</span>
<span class="sd">    with *N*.  Total number density is also saved as *N*.</span>

<span class="sd">    Composition information is also saved by taking each species and </span>
<span class="sd">    calculating the percent of the total number density via</span>
<span class="sd">    *fracspecies* = 100% x *speciesN*/*N*.</span>

<span class="sd">    Many species that are implemented in multi-species and multi-fluid</span>
<span class="sd">    BATS-R-US equation files have known mass.  For example, *oprho* is known</span>
<span class="sd">    a-priori to be singly ionized oxygen mass density, so *opN* is created</span>
<span class="sd">    by dividing *oprho* by 16.  If the fluid/species is not recognized, it is</span>
<span class="sd">    assumed to be hyrogen.  The single atom/molecule mass is saved in the</span>
<span class="sd">    attributes of the new variable.</span>

<span class="sd">    This function should be called by object methods of the same name.  </span>
<span class="sd">    It is placed at the module level because it is used by many different </span>
<span class="sd">    classes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    obj : :class:`~spacepy.pybats.PbData` object</span>
<span class="sd">       The object on which to act.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ================</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>
<span class="sd">    True</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>
<span class="sd">    &gt;&gt;&gt; import spacepy.pybats.bats as pbs</span>
<span class="sd">    &gt;&gt;&gt; mhd = pbs.Bats2d(&#39;spacepy-code/spacepy/pybats/slice2d_species.out&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pbs._calc_ndens(mhd)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">species</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">names</span>   <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Get name of Rho (case sensitive check):</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="s1">&#39;Rho&#39;</span><span class="o">*</span><span class="p">(</span><span class="s1">&#39;Rho&#39;</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;rho&#39;</span><span class="o">*</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)</span>
    
    <span class="c1"># Find all species: the variable names end or begin with &quot;rho&quot;.</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
        <span class="c1"># Ends with rho?</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="n">rho</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span><span class="o">!=</span><span class="n">rho</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;N&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">):</span>
            <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
        <span class="c1"># Begins with rho?</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>  <span class="o">==</span> <span class="n">rho</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span><span class="o">!=</span><span class="n">rho</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span> <span class="o">+</span><span class="s1">&#39;N&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">):</span>
            <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>

    <span class="c1"># Individual number density</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">mass</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">mass</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">obj</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="s1">&#39;N&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">/</span><span class="n">m</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;$cm^{-3}$&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;amu mass&#39;</span><span class="p">:</span><span class="n">m</span><span class="p">})</span>

    <span class="c1"># Total N is sum of individual  number densities.</span>
    <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">rho</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> 
                       <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;$cm^{-3}$&#39;</span><span class="p">})</span> 
    <span class="k">if</span> <span class="n">species</span><span class="p">:</span>
        <span class="c1"># Total number density:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">obj</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="s1">&#39;N&#39;</span><span class="p">]</span>
        <span class="c1"># Composition as fraction of total per species:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">obj</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="s1">&#39;Frac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="mf">100.</span><span class="o">*</span><span class="n">obj</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="s1">&#39;N&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">],</span>
                                    <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;Percent&#39;</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># No individual species =&gt; no composition, simple ndens.</span>
        <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">rho</span><span class="p">],</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;$cm^{-3}$&#39;</span><span class="p">})</span> 


<span class="c1">#### Classes:</span>

<div class="viewcode-block" id="BatsLog"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.BatsLog.html#spacepy.pybats.bats.BatsLog">[docs]</a><span class="k">class</span> <span class="nc">BatsLog</span><span class="p">(</span><span class="n">LogFile</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A specialized version of :class:`~spacepy.pybats.LogFile` that includes</span>
<span class="sd">    special methods for plotting common BATS-R-US log file values, such as</span>
<span class="sd">    D$_{ST}$.</span>

<span class="sd">    .. autosummary::</span>

<span class="sd">        ~BatsLog.add_dst_quicklook</span>

<span class="sd">    .. automethod:: add_dst_quicklook</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">fetch_obs_dst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fetch the observed Dst index for the time period covered in the </span>
<span class="sd">        logfile.  Return *True* on success.</span>

<span class="sd">        Observed Dst is automatically fetched from the Kyoto World Data Center</span>
<span class="sd">        via the :mod:`spacepy.pybats.kyoto` module.  The associated </span>
<span class="sd">        :class:`spacepy.pybats.kyoto.KyotoDst` object, which holds the observed</span>
<span class="sd">        Dst, is stored as *self.obs_dst* for future use.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">spacepy.pybats.kyoto</span> <span class="k">as</span> <span class="nn">kt</span>

        <span class="c1"># Return if already obtained:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;obs_dst&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Start and end time to collect observations:</span>
        <span class="n">stime</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="n">etime</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Attempt to fetch from Kyoto website:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs_dst</span> <span class="o">=</span> <span class="n">kt</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s1">&#39;dst&#39;</span><span class="p">,</span> <span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">)</span>
        <span class="c1"># Warn on failure:</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s1">&#39;Failed to fetch Kyoto Dst: &#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">fetch_obs_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fetch the observed SYM-H index for the time period covered in the </span>
<span class="sd">        logfile.  Return *True* on success.</span>

<span class="sd">        Observed SYM-H is automatically fetched from the Kyoto World Data Center</span>
<span class="sd">        via the :mod:`spacepy.pybats.kyoto` module.  The associated </span>
<span class="sd">        :class:`spacepy.pybats.kyoto.KyotoSym` object, which holds the observed</span>
<span class="sd">        Dst, is stored as *self.obs_sym* for future use.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">spacepy.pybats.kyoto</span> <span class="k">as</span> <span class="nn">kt</span>

        <span class="c1"># Return if already obtained:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;obs_sym&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Start and end time to collect observations:</span>
        <span class="n">stime</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="n">etime</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Attempt to fetch from Kyoto website:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs_sym</span> <span class="o">=</span> <span class="n">kt</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s1">&#39;sym&#39;</span><span class="p">,</span> <span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">)</span>
        <span class="c1"># Warn on failure:</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s1">&#39;Failed to fetch Kyoto Dst: &#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>
    
<div class="viewcode-block" id="BatsLog.add_dst_quicklook"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.BatsLog.html#spacepy.pybats.bats.BatsLog.add_dst_quicklook">[docs]</a>    <span class="k">def</span> <span class="nf">add_dst_quicklook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> <span class="n">plot_obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add_legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_sym</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">dstvar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;ls&#39;</span><span class="p">:</span><span class="s1">&#39;--&#39;</span><span class="p">},</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a quick-look plot of Dst (if variable present in file) </span>
<span class="sd">        and compare against observations.</span>
<span class="sd">        </span>
<span class="sd">        Like all *add_\* * methods in Pybats, the *target* kwarg determines</span>
<span class="sd">        where to place the plot.</span>
<span class="sd">        If kwarg *target* is **None** (default), a new figure is </span>
<span class="sd">        generated from scratch.  If *target* is a matplotlib Figure</span>
<span class="sd">        object, a new axis is created to fill that figure at subplot location</span>
<span class="sd">        *loc* (defaults to 111).  If target is a matplotlib Axes object, </span>
<span class="sd">        the plot is placed into that axis at subplot location *loc*.</span>

<span class="sd">        With newer versions of BATS-R-US, new dst-like variables are included,</span>
<span class="sd">        named &#39;dst&#39;, &#39;dst-sm&#39;, &#39;dstflx&#39;, etc.  This subroutine will attempt</span>
<span class="sd">        to first use &#39;dst-sm&#39; as it is calculated consistently with </span>
<span class="sd">        observations.  If not found, &#39;dst&#39; is used.  Users may choose which</span>
<span class="sd">        value to use via the *dstvar* kwarg.</span>

<span class="sd">        Observed Dst and SYM-H is automatically fetched from the Kyoto World </span>
<span class="sd">        Data Center via the :mod:`spacepy.pybats.kyoto` module.  The associated </span>
<span class="sd">        :class:`spacepy.pybats.kyoto.KyotoDst` or </span>
<span class="sd">        :class:`spacepy.pybats.kyoto.KyotoSym` object, which holds the observed</span>
<span class="sd">        Dst/SYM-H, is stored as *self.obs_dst* for future use.</span>
<span class="sd">        The observed line can be customized via the *obs_kwargs* kwarg, which</span>
<span class="sd">        is a dictionary of plotting keyword arguments.</span>

<span class="sd">        If kwarg *epoch* is set to a datetime object, a vertical dashed line</span>
<span class="sd">        will be placed at that time.</span>

<span class="sd">        The figure and axes objects are returned to the user.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="c1"># Set the correct dst value to be used.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dstvar</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;dst_sm&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">dstvar</span> <span class="o">=</span> <span class="s1">&#39;dst_sm&#39;</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">dstvar</span><span class="o">=</span><span class="s1">&#39;dst&#39;</span>
        
        <span class="k">if</span> <span class="n">dstvar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;label&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;BATS-R-US $D_</span><span class="si">{ST}</span><span class="s1">$ (Biot-Savart)&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;label&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obs_kwargs</span><span class="p">:</span>
            <span class="n">obs_kwargs</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Obs. Dst&#39;</span>
            <span class="k">if</span> <span class="n">plot_sym</span><span class="p">:</span> <span class="n">obs_kwargs</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Obs. SYM-H&#39;</span>
            
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">dstvar</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                  <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>
        <span class="n">applySmartTimeTicks</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;D$_</span><span class="si">{ST}</span><span class="s1">$ ($nT$)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time from &#39;</span><span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39; UTC&#39;</span><span class="p">)</span>

        <span class="c1"># Add observations (Dst and/or SYM-H):</span>
        <span class="k">if</span><span class="p">(</span><span class="n">plot_obs</span><span class="p">):</span>
            <span class="c1"># Attempt to fetch observations, plot if success.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_obs_dst</span><span class="p">():</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs_dst</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_dst</span><span class="p">[</span><span class="s1">&#39;dst&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">obs_kwargs</span><span class="p">)</span>
                <span class="n">applySmartTimeTicks</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>
        <span class="k">if</span><span class="p">(</span><span class="n">plot_sym</span><span class="p">):</span>
            <span class="c1"># Attempt to fetch SYM-h observations, plot if success.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_obs_sym</span><span class="p">():</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs_sym</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">obs_sym</span><span class="p">[</span><span class="s1">&#39;sym-h&#39;</span><span class="p">],</span><span class="o">**</span><span class="n">obs_kwargs</span><span class="p">)</span>
                <span class="n">applySmartTimeTicks</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>

        <span class="c1"># Place vertical line at epoch:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span> <span class="o">==</span> <span class="n">datetime</span><span class="p">:</span>
            <span class="n">yrange</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">yrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span>
                      <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">yrange</span><span class="p">)</span>
                
        <span class="c1"># Apply legend</span>
        <span class="k">if</span> <span class="n">add_legend</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div></div>
    
<span class="k">class</span> <span class="nc">Extraction</span><span class="p">(</span><span class="n">PbData</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A class for creating and visualizing extractions from other</span>
<span class="sd">    :class:`~spacepy.pybats.PbData` 2D data sets.  Bilinear interpolation is </span>
<span class="sd">    used to obtain data between points.  At present, this class only</span>
<span class="sd">    works with :class:`~spacepy.pybats.bats.Bats2d` objects, but will be</span>
<span class="sd">    generalized in the future.  Though it can be instantiated in typical </span>
<span class="sd">    fashion, It is best to create these objects via other object methods (e.g., </span>
<span class="sd">    :func:`~spacepy.pybats.bats.Bats2d.extract`)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float or sequence</span>
<span class="sd">        X value(s) for points at which to extract data values.</span>
<span class="sd">    y : float or sequence</span>
<span class="sd">        Y value(s) for points at which to extract data values.</span>
<span class="sd">    dataset : Bats</span>
<span class="sd">        :class:`~spacepy.pybats.bats.Bats2d` object from which to extract values</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    var_list : string or sequence of strings</span>
<span class="sd">         List of values to extract from *dataset*.  Defaults to &#39;all&#39;, for all</span>
<span class="sd">         values within *dataset*.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">var_list</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Initialize as a PbData object.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Extraction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Store x, y internally:</span>
        <span class="c1"># If our x, y locations are not numpy arrays, fix that.</span>
        <span class="c1"># Additionally, convert scalars to 1-element vectors.</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Default: all variables are extracted except coordinates.</span>
        <span class="k">if</span> <span class="n">var_list</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">var_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;grid&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">var_list</span><span class="p">:</span> <span class="n">var_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">var_list</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">:</span>
            <span class="n">var_list</span> <span class="o">=</span> <span class="n">var_list</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">var_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">var_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Kwarg var_list must be string, list, or None.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Stash var list, dataset internally:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_list</span> <span class="o">=</span> <span class="n">var_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span>  <span class="o">=</span> <span class="n">dataset</span>

        <span class="c1"># Extract along trace:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xpts</span><span class="p">,</span> <span class="n">ypts</span><span class="p">):</span>
        <span class="c1"># Perform actual extraction:</span>
        <span class="kn">from</span> <span class="nn">spacepy.pybats.batsmath</span> <span class="kn">import</span> <span class="n">interp_2d_reg</span>

        <span class="c1"># Some convenience variables:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xpts</span><span class="p">,</span> <span class="n">ypts</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset</span>
        
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="c1"># Create data object for holding extracted values.</span>
        <span class="c1"># One vector for each value w/ same units as parent object.</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">dmarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">attrs</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># Some helpers:</span>
        <span class="n">xAll</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">yAll</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># Navigate the MHD quad tree, interpolating as we go.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">qtree</span><span class="p">:</span>
            <span class="c1"># Only leafs, of course!</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">isLeaf</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c1"># Find all points that lie in this block.</span>
            <span class="c1"># If there are none, just keep going.</span>
            <span class="n">pts</span> <span class="o">=</span> \
                <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">data</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> \
                <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="n">data</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pts</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="k">continue</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">locs</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">pts</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp_2d_reg</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">pts</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">pts</span><span class="p">],</span> <span class="n">xAll</span><span class="p">[</span><span class="n">locs</span><span class="p">],</span> 
                                             <span class="n">yAll</span><span class="p">[</span><span class="n">locs</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">locs</span><span class="p">])</span> 

<div class="viewcode-block" id="Stream"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.Stream.html#spacepy.pybats.bats.Stream">[docs]</a><span class="k">class</span> <span class="nc">Stream</span><span class="p">(</span><span class="n">Extraction</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A class for streamlines.  Contains all of the information about</span>
<span class="sd">    the streamline, including extracted variables.</span>

<span class="sd">    Upon instantiation, the object will trace through the vector</span>
<span class="sd">    field determined by the &quot;[x/y]field&quot; values and the Bats object</span>
<span class="sd">    &quot;bats&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bats : Bats</span>
<span class="sd">        :class:`~spacepy.pybats.bats.Bats2d` object through which to trace.</span>
<span class="sd">    xstart : float</span>
<span class="sd">        X value of location to start the trace.</span>
<span class="sd">    ystart : float</span>
<span class="sd">        Y value of location to start the trace.</span>
<span class="sd">    xfield : str</span>
<span class="sd">        Name of variable in ``bats`` which contains X values of the field</span>
<span class="sd">    yfield : str</span>
<span class="sd">        Name of variable in ``bats`` which contains Y values of the field</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    style : str</span>
<span class="sd">        Sets line style, including colors. See :meth:`set_style` for details.</span>
<span class="sd">        (Default &#39;mag&#39;)</span>
<span class="sd">    type : str</span>
<span class="sd">        (Default &#39;streamline&#39;)</span>
<span class="sd">    method : str</span>
<span class="sd">        Integration method. The default is Runge-Kutta 4 (&#39;rk4&#39;) which gives</span>
<span class="sd">        a good blend of speed and accuracy. See the test functions in</span>
<span class="sd">        :mod:`~spacepy.pybats.trace2d` for more info.  The other option is</span>
<span class="sd">        a simple Euler&#39;s method approach (&#39;eul&#39;). (Default &#39;rk4&#39;)</span>
<span class="sd">    extract : bool</span>
<span class="sd">        (Default: False) Extract variables along stream trace and save within</span>
<span class="sd">        object.</span>
<span class="sd">    maxPoints : int</span>
<span class="sd">        (Default : 20000) Maximum number of integration steps to take.</span>
<span class="sd">    var_list : string or sequence of strings</span>
<span class="sd">        (Default : &#39;all&#39;) List of values to extract from *dataset*.  </span>
<span class="sd">        Defaults to &#39;all&#39;, for all values within *bats*.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. Not really &quot;notes&quot; but need to keep this section from being parsed </span>
<span class="sd">       as parameters</span>

<span class="sd">    .. rubric:: Methods</span>

<span class="sd">    .. autosummary::</span>

<span class="sd">        ~Stream.set_style</span>
<span class="sd">        ~Stream.treetrace</span>
<span class="sd">        ~Stream.trace</span>
<span class="sd">        ~Stream.plot</span>

<span class="sd">    .. automethod:: set_style</span>
<span class="sd">    .. automethod:: treetrace</span>
<span class="sd">    .. automethod:: trace</span>
<span class="sd">    .. automethod:: plot</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bats</span><span class="p">,</span> <span class="n">xstart</span><span class="p">,</span> <span class="n">ystart</span><span class="p">,</span> <span class="n">xfield</span><span class="p">,</span> <span class="n">yfield</span><span class="p">,</span> <span class="n">style</span> <span class="o">=</span> <span class="s1">&#39;mag&#39;</span><span class="p">,</span>
                 <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;streamline&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rk4&#39;</span><span class="p">,</span> <span class="n">var_list</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                 <span class="n">extract</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxPoints</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="c1"># Key values:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xstart</span> <span class="o">=</span> <span class="n">xstart</span> <span class="c1">#X and Y starting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span> <span class="o">=</span> <span class="n">ystart</span> <span class="c1">#points in the field.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xvar</span>   <span class="o">=</span> <span class="n">xfield</span> <span class="c1">#Strings that list the variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yvar</span>   <span class="o">=</span> <span class="n">yfield</span> <span class="c1">#that will be used for tracing.</span>

        <span class="c1"># Descriptors:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open</span>   <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;open&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>

        <span class="c1"># Do tracing if a tracing method has been set.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">treetrace</span><span class="p">(</span><span class="n">bats</span><span class="p">,</span> <span class="n">maxPoints</span><span class="o">=</span><span class="n">maxPoints</span><span class="p">)</span>

        <span class="c1"># Now, initialize as Extraction using self.x, self.y.</span>
        <span class="c1"># This handles the extraction as well as converting self.x, y into</span>
        <span class="c1"># dmarrays with the correct names.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Stream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">bats</span><span class="p">,</span>
                                     <span class="n">var_list</span><span class="o">=</span><span class="n">var_list</span><span class="o">*</span><span class="n">extract</span><span class="p">)</span>
        
        <span class="c1"># Place parameters into attributes:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>     <span class="o">=</span> <span class="p">[</span><span class="n">xstart</span><span class="p">,</span> <span class="n">ystart</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;trace_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xfield</span><span class="p">,</span> <span class="n">yfield</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="n">method</span>

        <span class="c1"># Set style</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="n">style</span><span class="p">)</span>

    <span class="c1">#def __repr__(self):</span>
    <span class="c1">#    pass</span>
    <span class="c1">#</span>
    <span class="c1">#def __str__(self):</span>
    <span class="c1">#    pass</span>

<div class="viewcode-block" id="Stream.set_style"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.Stream.html#spacepy.pybats.bats.Stream.set_style">[docs]</a>    <span class="k">def</span> <span class="nf">set_style</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">style</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set the line style either using a simple matplotlib-type style</span>
<span class="sd">        string or using a preset style type.  Current types include:</span>
<span class="sd">        </span>
<span class="sd">        &#39;mag&#39; : treat line as a magnetic field line.  Closed lines are</span>
<span class="sd">                white, other lines are black.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">re</span>
        
        <span class="c1"># Here, we can set line color and style based on</span>
        <span class="c1"># line characteristics.  Right now, only one preset is</span>
        <span class="c1"># available.</span>
        <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="s1">&#39;k-&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="s1">&#39;w-&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">style</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;([bgrcmykw])&#39;</span><span class="p">,</span> <span class="n">style</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="o">=</span><span class="n">col</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span></div>
                
<div class="viewcode-block" id="Stream.treetrace"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.Stream.html#spacepy.pybats.bats.Stream.treetrace">[docs]</a>    <span class="k">def</span> <span class="nf">treetrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bats</span><span class="p">,</span> <span class="n">maxPoints</span><span class="o">=</span><span class="mi">20000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Trace through the vector field using the quad tree.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">append</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;euler&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;eul&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">spacepy.pybats.trace2d</span> <span class="kn">import</span> <span class="n">trace2d_eul</span> <span class="k">as</span> <span class="n">trc</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;rk4&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">spacepy.pybats.trace2d</span> <span class="kn">import</span> <span class="n">trace2d_rk4</span> <span class="k">as</span> <span class="n">trc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Tracing method </span><span class="si">{}</span><span class="s1"> not recognized!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">))</span>

        <span class="c1"># Get name of dimensions in order.</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">bats</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]</span>

        <span class="c1"># Find starting block and set starting locations.</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">bats</span><span class="o">.</span><span class="n">find_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span><span class="p">)</span>
        <span class="n">xfwd</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="p">];</span> <span class="n">yfwd</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ystart</span><span class="p">]</span>
        <span class="n">xnow</span><span class="p">,</span> <span class="n">ynow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span>

        <span class="c1"># Trace forwards.</span>
        <span class="k">while</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
            <span class="c1"># Grab indices of all values inside current block.</span>
            <span class="c1"># Ghost cell check is for experimental testing:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bats</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">block</span><span class="p">],</span> <span class="s1">&#39;ghost&#39;</span><span class="p">):</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">bats</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">block</span><span class="p">]</span><span class="o">.</span><span class="n">ghost</span>
            <span class="c1"># Typical approach is no ghost cell info:</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">bats</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">block</span><span class="p">]</span><span class="o">.</span><span class="n">locs</span>
            <span class="c1"># Trace through this block.</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">trc</span><span class="p">(</span><span class="n">bats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xvar</span><span class="p">][</span><span class="n">loc</span><span class="p">],</span> <span class="n">bats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yvar</span><span class="p">][</span><span class="n">loc</span><span class="p">],</span> 
                       <span class="n">xnow</span><span class="p">,</span> <span class="n">ynow</span><span class="p">,</span> <span class="n">bats</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">loc</span><span class="p">][</span><span class="mi">0</span><span class="p">,:],</span> 
                       <span class="n">bats</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">loc</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">ds</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="c1"># Update location and block:</span>
            <span class="n">xnow</span><span class="p">,</span> <span class="n">ynow</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">newblock</span> <span class="o">=</span> <span class="n">bats</span><span class="o">.</span><span class="n">find_block</span><span class="p">(</span><span class="n">xnow</span><span class="p">,</span><span class="n">ynow</span><span class="p">)</span>
            <span class="c1"># If we didn&#39;t leave the block, stop tracing.</span>
            <span class="c1"># Additionally, if inside rBody, stop.</span>
            <span class="k">if</span><span class="p">(</span><span class="n">block</span><span class="o">==</span><span class="n">newblock</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xnow</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">ynow</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;</span><span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span><span class="o">*.</span><span class="mi">8</span> <span class="p">:</span>
                <span class="n">block</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">elif</span> <span class="n">newblock</span><span class="p">:</span>
                <span class="n">block</span><span class="o">=</span><span class="n">newblock</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">block</span><span class="o">=</span><span class="kc">False</span>
            <span class="c1"># Append to full trace vectors.</span>
            <span class="n">xfwd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xfwd</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">yfwd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yfwd</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">del</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="k">del</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="c1"># It&#39;s possible to get stuck swirling around across</span>
            <span class="c1"># a few blocks.  If we spend a lot of time tracing,</span>
            <span class="c1"># call it quits.</span>
            <span class="k">if</span> <span class="n">xfwd</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="n">maxPoints</span><span class="p">:</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span>

        <span class="c1"># Trace backwards.  Same Procedure as above.</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">bats</span><span class="o">.</span><span class="n">find_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span><span class="p">)</span>
        <span class="n">xbwd</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="p">];</span> <span class="n">ybwd</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ystart</span><span class="p">]</span>
        <span class="n">xnow</span><span class="p">,</span> <span class="n">ynow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span>
        <span class="k">while</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bats</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">block</span><span class="p">],</span> <span class="s1">&#39;ghost&#39;</span><span class="p">):</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">bats</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">block</span><span class="p">]</span><span class="o">.</span><span class="n">ghost</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">bats</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">block</span><span class="p">]</span><span class="o">.</span><span class="n">locs</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">trc</span><span class="p">(</span><span class="n">bats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xvar</span><span class="p">][</span><span class="n">loc</span><span class="p">],</span> <span class="n">bats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yvar</span><span class="p">][</span><span class="n">loc</span><span class="p">],</span> 
                       <span class="n">xnow</span><span class="p">,</span> <span class="n">ynow</span><span class="p">,</span> <span class="n">bats</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">loc</span><span class="p">][</span><span class="mi">0</span><span class="p">,:],</span> 
                       <span class="n">bats</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">loc</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">ds</span><span class="o">=-</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="n">xnow</span><span class="p">,</span> <span class="n">ynow</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">newblock</span> <span class="o">=</span> <span class="n">bats</span><span class="o">.</span><span class="n">find_block</span><span class="p">(</span><span class="n">xnow</span><span class="p">,</span><span class="n">ynow</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">block</span><span class="o">==</span><span class="n">newblock</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xnow</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">ynow</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;</span><span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span><span class="o">*.</span><span class="mi">8</span> <span class="p">:</span>
                <span class="n">block</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">elif</span> <span class="n">newblock</span><span class="p">:</span>
                <span class="n">block</span><span class="o">=</span><span class="n">newblock</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">block</span><span class="o">=</span><span class="kc">False</span>
            <span class="c1"># Append to full trace vectors.</span>
            <span class="n">xbwd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xbwd</span><span class="p">)</span>
            <span class="n">ybwd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ybwd</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xbwd</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="n">maxPoints</span><span class="p">:</span> 
                <span class="n">block</span><span class="o">=</span><span class="kc">False</span>

        <span class="c1"># Trim duplicate points created when backwards tracing.</span>
        <span class="c1"># There&#39;s always at least 1 duplicate.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">xbwd</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xbwd</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">-</span><span class="n">xfwd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
        
        <span class="c1"># Combine foward and backward traces.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xbwd</span><span class="p">[:</span><span class="o">-</span><span class="n">i</span><span class="p">],</span><span class="n">xfwd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ybwd</span><span class="p">[:</span><span class="o">-</span><span class="n">i</span><span class="p">],</span><span class="n">yfwd</span><span class="p">)</span>

        <span class="c1"># If planetary run w/ body:</span>
        <span class="c1"># 1) Check if line is closed to body.</span>
        <span class="c1"># 2) Trim points within body.</span>
        <span class="k">if</span> <span class="s1">&#39;rbody&#39;</span> <span class="ow">in</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="c1"># Radial distance:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mf">2.0</span>  <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="c1"># Closed field line?  Lobe line?  Set status:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">open</span>   <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;closed&#39;</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">open</span>   <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;north lobe&#39;</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">open</span>   <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;south lobe&#39;</span>
            <span class="c1"># Trim the fat!</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span><span class="o">*.</span><span class="mi">8</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">r</span><span class="o">&gt;</span><span class="n">limit</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">r</span><span class="o">&gt;</span><span class="n">limit</span><span class="p">]</span></div>

<div class="viewcode-block" id="Stream.trace"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.Stream.html#spacepy.pybats.bats.Stream.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bats</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Trace through the vector field.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">sqrt</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;euler&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">spacepy.pybats.trace2d</span> <span class="kn">import</span> <span class="n">trace2d_eul</span> <span class="k">as</span> <span class="n">trc</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;rk4&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">spacepy.pybats.trace2d</span> <span class="kn">import</span> <span class="n">trace2d_rk4</span> <span class="k">as</span> <span class="n">trc</span>
        
        <span class="c1"># Get name of dimensions in order.</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">bats</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]</span>

        <span class="c1"># Trace forward</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">trc</span><span class="p">(</span><span class="n">bats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xvar</span><span class="p">],</span> <span class="n">bats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yvar</span><span class="p">],</span> 
                     <span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span><span class="p">,</span>
                     <span class="n">bats</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">bats</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="c1"># Trace backward</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">trc</span><span class="p">(</span><span class="n">bats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xvar</span><span class="p">],</span> <span class="n">bats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yvar</span><span class="p">],</span> 
                     <span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span><span class="p">,</span>
                     <span class="n">bats</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">bats</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ds</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="c1"># Join lines together such that point 0 is beginning of line</span>
        <span class="c1"># and point -1 is the end (when moving parallel to line.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">x2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">y2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">y1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="c1"># Check if line is closed to body.</span>
        <span class="k">if</span> <span class="s1">&#39;rbody&#39;</span> <span class="ow">in</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span>  <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r1</span> <span class="o">&lt;</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">r2</span> <span class="o">&lt;</span> <span class="n">bats</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">open</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Stream.plot"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.Stream.html#spacepy.pybats.bats.Stream.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add streamline to axes object &quot;ax&quot;. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">style</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="Bats2d"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.Bats2d.html#spacepy.pybats.bats.Bats2d">[docs]</a><span class="k">class</span> <span class="nc">Bats2d</span><span class="p">(</span><span class="n">IdlFile</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A child class of :class:`~pybats.IdlFile` taylored to BATS-R-US output.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Init by calling IdlFile init and then building qotree, etc.</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">):</span>

        <span class="kn">from</span> <span class="nn">spacepy.pybats</span> <span class="kn">import</span> <span class="n">parse_filename_time</span>
        
        <span class="c1"># Read file.</span>
        <span class="n">IdlFile</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">keep_case</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_qtree</span><span class="o">=</span><span class="kc">None</span>

        <span class="c1"># Extract time from file name:</span>
        <span class="n">i_iter</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">parse_filename_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="k">if</span> <span class="s1">&#39;iter&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_iter</span>

        <span class="c1"># Behavior of output files changed Jan. 2017:</span>
        <span class="c1"># Check for &#39;r&#39; instead of &#39;rbody&#39; in attrs.</span>
        <span class="k">if</span> <span class="s1">&#39;r&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="ow">and</span> <span class="s1">&#39;rbody&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qtree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>

            <span class="kn">import</span> <span class="nn">spacepy.pybats.qotree</span> <span class="k">as</span> <span class="nn">qo</span>

            <span class="c1"># Parse grid into quad tree.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;gtype&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;Regular&#39;</span><span class="p">:</span>
                <span class="n">xdim</span><span class="p">,</span> <span class="n">ydim</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_qtree</span><span class="o">=</span><span class="n">qo</span><span class="o">.</span><span class="n">QTree</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">xdim</span><span class="p">],</span><span class="bp">self</span><span class="p">[</span><span class="n">ydim</span><span class="p">]]))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">traceback</span> <span class="kn">import</span> <span class="n">print_exc</span>
                    <span class="n">print_exc</span><span class="p">()</span>
                    <span class="c1">#print &#39;On dataset:&#39;,self.filename</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_qtree</span><span class="o">=</span><span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">find_block</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qtree</span><span class="o">=</span><span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">find_block</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qtree</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">find_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qtree</span><span class="o">.</span><span class="n">find_leaf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">False</span>

    <span class="c1">####################</span>
    <span class="c1"># CALCULATIONS</span>
    <span class="c1">####################</span>

    <span class="k">def</span> <span class="nf">calc_temp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate plasma temperature for each fluid.  Number density is</span>
<span class="sd">        calculated using *calc_ndens* if it hasn&#39;t been done so already.</span>
<span class="sd">        </span>
<span class="sd">        Temperature is obtained via density and pressure through the simple</span>
<span class="sd">        relationship P=nkT.</span>

<span class="sd">        Use the units kwarg to set output units.  Current choices are</span>
<span class="sd">        KeV, eV, and K.  Default is eV.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">spacepy.datamodel</span> <span class="kn">import</span> <span class="n">dmarray</span>

        <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># Create dictionary of unit conversions.</span>
        <span class="n">conv</span>  <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ev&#39;</span> <span class="p">:</span> <span class="mf">6241.50935</span><span class="p">,</span>  <span class="c1"># nPa/cm^3 --&gt; eV.</span>
                 <span class="s1">&#39;kev&#39;</span><span class="p">:</span> <span class="mf">6.24150935</span><span class="p">,</span>  <span class="c1"># nPa/cm^3 --&gt; KeV.</span>
                 <span class="s1">&#39;k&#39;</span>  <span class="p">:</span> <span class="mf">72429626.47</span><span class="p">}</span> <span class="c1"># nPa/cm^3 --&gt; K.</span>

        <span class="c1"># Calculate number density if not done already.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;N&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_ndens</span><span class="p">()</span>
        
        <span class="c1"># Find all number density variables.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="c1"># Next variable if not number density:</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Next variable if no matching pressure:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;p&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span>
                <span class="n">conv</span><span class="p">[</span><span class="n">units</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="n">units</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">calc_b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates total B-field strength using all three B components.</span>
<span class="sd">        Retains units of components.  Additionally, the unit vector</span>
<span class="sd">        b-hat is calculated as well.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bx&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;by&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bz&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]}</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bx_hat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bx&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;by_hat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;by&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bz_hat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bz&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bx_hat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;unitless&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;by_hat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;unitless&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bz_hat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;unitless&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">calc_j</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates total current density strength using all three J components.</span>
<span class="sd">        Retains units of components, stores in self[&#39;j&#39;]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jx&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jy&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jz&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]}</span>
        
    <span class="k">def</span> <span class="nf">calc_E</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates the MHD electric field, -UxB.  Works for default</span>
<span class="sd">        MHD units of nT and km/s; if these units are not correct, an </span>
<span class="sd">        exception will be raised.  Stores E in mV/m.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>

        <span class="c1"># Some quick declarations for more readable code.</span>
        <span class="n">ux</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">];</span> <span class="n">uy</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;uy&#39;</span><span class="p">];</span> <span class="n">uz</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;uz&#39;</span><span class="p">]</span>
        <span class="n">bx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bx&#39;</span><span class="p">];</span> <span class="n">by</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;by&#39;</span><span class="p">];</span> <span class="n">bz</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bz&#39;</span><span class="p">]</span>

        <span class="c1"># Check units.  Should be nT(=Volt*s/m^2) and km/s.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bx</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;nT&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ux</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;km/s&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Incorrect units!  Should be km/s and nT.&#39;</span><span class="p">)</span>

        <span class="c1"># Calculate; return in millivolts per meter</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="p">(</span><span class="n">uy</span><span class="o">*</span><span class="n">bz</span> <span class="o">-</span> <span class="n">uz</span><span class="o">*</span><span class="n">by</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ey&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="p">(</span><span class="n">uz</span><span class="o">*</span><span class="n">bx</span> <span class="o">-</span> <span class="n">ux</span><span class="o">*</span><span class="n">bz</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ez&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="p">(</span><span class="n">ux</span><span class="o">*</span><span class="n">by</span> <span class="o">-</span> <span class="n">uy</span><span class="o">*</span><span class="n">bx</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ex&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;mV/m&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ey&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;mV/m&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ez&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;mV/m&#39;</span><span class="p">}</span>

        <span class="c1"># Total magnitude.</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ex&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ey&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Ez&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">calc_ndens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate number densities for each fluid.  Species mass is ascertained </span>
<span class="sd">        via recognition of fluid name (e.g. OpRho is clearly oxygen).  A full</span>
<span class="sd">        list of recognized fluids/species can be found by exploring the </span>
<span class="sd">        dictionary *mass* found in :mod:`~spacepy.pybats.bats`.  Composition is</span>
<span class="sd">        also calculated as percent of total number density.</span>

<span class="sd">        New values are saved using the keys *speciesN* (e.g. *opN*) and</span>
<span class="sd">        *speciesFrac* (e.g. *opFrac*).</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Use shared function.</span>
        <span class="n">_calc_ndens</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                                
    <span class="k">def</span> <span class="nf">calc_beta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates plasma beta (ratio of plasma to magnetic pressure, </span>
<span class="sd">        indicative of who - plasma or B-field - is &quot;in charge&quot; with regards</span>
<span class="sd">        to flow.</span>
<span class="sd">        Assumes:</span>
<span class="sd">        -pressure in units of nPa</span>
<span class="sd">        -B in units of nT.</span>
<span class="sd">        Resulting value is unitless.</span>
<span class="sd">        Values where b_total = zero are set to -1.0 in the final array.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_b</span><span class="p">()</span>
        <span class="n">mu_naught</span> <span class="o">=</span> <span class="mf">4.0E2</span> <span class="o">*</span> <span class="n">pi</span> <span class="c1"># Mu_0 x unit conversion (nPa-&gt;Pa, nT-&gt;T)</span>
        <span class="n">temp_b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span>
        <span class="n">temp_b</span><span class="p">[</span><span class="n">temp_b</span><span class="o">&lt;</span><span class="mf">1E-8</span><span class="p">]</span> <span class="o">=</span>  <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">mu_naught</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">][</span><span class="n">temp_b</span><span class="o">==</span><span class="mf">0.0</span><span class="p">]</span>
        <span class="n">temp_beta</span><span class="o">=</span><span class="n">mu_naught</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">temp_b</span>
        <span class="c1">#temp_beta[self[&#39;b&#39;]&lt;1E-9] = -1.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;beta&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">temp_beta</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;beta&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;unitless&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">calc_jxb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates the JxB force assuming:</span>
<span class="sd">        -Units of J are uA/m2, units of B are nT.</span>
<span class="sd">        Under these assumptions, the value returned is force density (nN/m^3).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span>
        <span class="kn">from</span> <span class="nn">spacepy.datamodel</span> <span class="kn">import</span> <span class="n">dmarray</span>

        <span class="c1"># Unit conversion (nT, uA, cm^-3 -&gt; nT, A, m^-3) to nN/m^3.</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="mf">1E-6</span>
        <span class="c1"># Calculate cross product, convert units.</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jbx&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dmarray</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jy&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bz&#39;</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jz&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;by&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">conv</span><span class="p">,</span>
                             <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nN/m^3&#39;</span><span class="p">})</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jby&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dmarray</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jz&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bx&#39;</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jx&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bz&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">conv</span><span class="p">,</span>
                             <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nN/m^3&#39;</span><span class="p">})</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jbz&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dmarray</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jx&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;by&#39;</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jy&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bx&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">conv</span><span class="p">,</span>
                             <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nN/m^3&#39;</span><span class="p">})</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jb&#39;</span><span class="p">]</span> <span class="o">=</span><span class="n">dmarray</span><span class="p">(</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jbx&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                  <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jby&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                  <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;jbz&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nN/m^3&#39;</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">calc_alfven</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the Alfven speed, B/(mu*rho)^(1/2) in km/s.  This is performed</span>
<span class="sd">        for each species and the total fluid.</span>
<span class="sd">        The variable is saved under key &quot;alfven&quot; in self.data.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">pi</span>
        <span class="kn">from</span> <span class="nn">spacepy.datamodel</span> <span class="kn">import</span> <span class="n">dmarray</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_b</span><span class="p">()</span>
        <span class="c1">#M_naught * conversion from #/cm^3 to kg/m^3</span>
        <span class="n">mu_naught</span> <span class="o">=</span> <span class="mf">4.0E-7</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mf">1.6726E-27</span> <span class="o">*</span> <span class="mf">1.0E6</span>

        <span class="c1"># Get all rho-like variables.  Save in new list.</span>
        <span class="n">rho_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span> <span class="o">==</span> <span class="s1">&#39;rho&#39;</span><span class="p">:</span>
                <span class="n">rho_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                
        <span class="c1"># Calculate Alfven speed in km/s.  Separate step to avoid</span>
        <span class="c1"># changing dictionary while looping over keys.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rho_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;alfven&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">1E-12</span> <span class="o">/</span> 
                                            <span class="n">sqrt</span><span class="p">(</span><span class="n">mu_naught</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
                                            <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;km/s&#39;</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_calc_divmomen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the divergence of momentum, i.e. </span>
<span class="sd">        $\rho(u \dot \nabla)u$.</span>
<span class="sd">        This is currently exploratory.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">spacepy.datamodel</span> <span class="kn">import</span> <span class="n">dmarray</span>
        <span class="kn">from</span> <span class="nn">spacepy.pybats.batsmath</span> <span class="kn">import</span> <span class="n">d_dx</span><span class="p">,</span> <span class="n">d_dy</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;calc_divmomen requires a valid qtree&#39;</span><span class="p">)</span>
        
        <span class="c1"># Create empty arrays to hold new values.</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;divmomx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nN/m3&#39;</span><span class="p">})</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;divmomz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nN/m3&#39;</span><span class="p">})</span>

        <span class="c1"># Units!</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="mf">1000.</span><span class="o">/</span><span class="mf">6371.0</span> <span class="c1"># km2/Re/s2 -&gt; m/s2</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="mf">1.6726E-21</span>   <span class="c1"># AMU/cm3 -&gt; kg/m3</span>
        <span class="n">c3</span> <span class="o">=</span> <span class="mf">1E9</span>          <span class="c1"># N/m3 -&gt; nN/m3.</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">:</span>
            <span class="c1"># Calculate only on leafs of quadtree.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">isLeaf</span><span class="p">:</span> <span class="k">continue</span>
            
            <span class="c1"># Extract values from current leaf.</span>
            <span class="n">leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">ux</span>   <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">][</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span>
            <span class="n">uz</span>   <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;uz&#39;</span><span class="p">][</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span>

            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;divmomx&#39;</span><span class="p">][</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span><span class="o">=</span><span class="n">ux</span><span class="o">*</span><span class="n">d_dx</span><span class="p">(</span><span class="n">ux</span><span class="p">,</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span><span class="o">+</span><span class="n">uz</span><span class="o">*</span><span class="n">d_dy</span><span class="p">(</span><span class="n">ux</span><span class="p">,</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;divmomz&#39;</span><span class="p">][</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span><span class="o">=</span><span class="n">ux</span><span class="o">*</span><span class="n">d_dx</span><span class="p">(</span><span class="n">uz</span><span class="p">,</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span><span class="o">+</span><span class="n">uz</span><span class="o">*</span><span class="n">d_dy</span><span class="p">(</span><span class="n">uz</span><span class="p">,</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>

        <span class="c1"># Unit conversion.</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;divmomx&#39;</span><span class="p">]</span><span class="o">*=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">c1</span><span class="o">*</span><span class="n">c2</span><span class="o">*</span><span class="n">c3</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;divmomz&#39;</span><span class="p">]</span><span class="o">*=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">c1</span><span class="o">*</span><span class="n">c2</span><span class="o">*</span><span class="n">c3</span>

    <span class="k">def</span> <span class="nf">calc_vort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv</span><span class="o">=</span><span class="mf">1000.</span><span class="o">/</span><span class="n">RE</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the vorticity (curl of bulk velocity) for the direction</span>
<span class="sd">        orthogonal to the cut plane.  For example, if output file is </span>
<span class="sd">        a cut in the equatorial plane (GSM X-Y plane), only the z-component</span>
<span class="sd">        of the curl is calculated.</span>

<span class="sd">        Output is saved as self[&#39;wD&#39;], where D is the resulting dimension</span>
<span class="sd">        (e.g., &#39;wz&#39; for the z-component of vorticity in the X-Y plane).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        None</span>
<span class="sd">        </span>
<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        conv : float</span>
<span class="sd">           Required unit conversion such that output units are 1/s.  </span>
<span class="sd">           Defaults to 1/RE (in km), which assumes grid is in RE and </span>
<span class="sd">           velocity is in km/s.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">spacepy.pybats.batsmath</span> <span class="kn">import</span> <span class="n">d_dx</span><span class="p">,</span> <span class="n">d_dy</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;calc_vort requires a valid qtree&#39;</span><span class="p">)</span>


        <span class="c1"># Determine which direction to calculate based on what direction</span>
        <span class="c1"># is not present.  Save appropriate derivative operators, order</span>
        <span class="c1"># useful directions, create new variable name.</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;x&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="s1">&#39;wx&#39;</span>
            <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span> <span class="o">=</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span>
            <span class="n">dx1</span><span class="p">,</span>  <span class="n">dx2</span>  <span class="o">=</span> <span class="n">d_dy</span><span class="p">,</span> <span class="n">d_dx</span>
        <span class="k">elif</span> <span class="s1">&#39;y&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="s1">&#39;wy&#39;</span>
            <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span>
            <span class="n">dx1</span><span class="p">,</span>  <span class="n">dx2</span>  <span class="o">=</span> <span class="n">d_dy</span><span class="p">,</span> <span class="n">d_dx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="s1">&#39;wz&#39;</span>
            <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span>
            <span class="n">dx1</span><span class="p">,</span>  <span class="n">dx2</span>  <span class="o">=</span> <span class="n">d_dy</span><span class="p">,</span> <span class="n">d_dx</span>

        
        <span class="c1"># Create new arrays to hold curl.</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;1/s&#39;</span><span class="p">})</span>

        <span class="c1"># Navigate quad tree, calculate curl at every leaf.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">:</span>
            <span class="c1"># Plot only leafs of the tree.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">isLeaf</span><span class="p">:</span> <span class="k">continue</span>

            <span class="c1"># Get location of points and extract velocity:</span>
            <span class="n">leaf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">u1</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="o">+</span><span class="n">dim1</span><span class="p">][</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span>
            <span class="n">u2</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="o">+</span><span class="n">dim2</span><span class="p">][</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span>

            <span class="c1"># Calculate curl</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span> <span class="o">=</span> <span class="n">conv</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span> <span class="o">-</span> <span class="n">dx2</span><span class="p">(</span><span class="n">u2</span><span class="p">,</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dx</span><span class="p">))</span>
        
        
    <span class="k">def</span> <span class="nf">calc_gradP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the pressure gradient force.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">spacepy.datamodel</span> <span class="kn">import</span> <span class="n">dmarray</span>
        <span class="kn">from</span> <span class="nn">spacepy.pybats.batsmath</span> <span class="kn">import</span> <span class="n">d_dx</span><span class="p">,</span> <span class="n">d_dy</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;calc_gradP requires a valid qtree&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;p&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Pressure not found in object&#39;</span><span class="p">)</span>

        <span class="c1"># Create new arrays to hold pressure.</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;gradP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nN/cm^3&#39;</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;gradP_&#39;</span><span class="o">+</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nN/m^3&#39;</span><span class="p">})</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">:</span>
            <span class="c1"># Plot only leafs of the tree.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">isLeaf</span><span class="p">:</span> <span class="k">continue</span>

            <span class="c1"># Extract leaf; place pressure into 2D array.</span>
            <span class="n">leaf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">z</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">][</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span>
            
            <span class="c1"># Calculate derivatives; place into new dmarrays.</span>
            <span class="c1"># Unit conversion: P in nPa =&gt; gradP in nN/m3, dx=Re</span>
            <span class="c1"># Convert to nN/m3 by multiplying by 6378000m**-1.</span>
            <span class="c1"># Clever indexing maps values back to &quot;unordered&quot; array so that</span>
            <span class="c1"># values can be plotted like all others.</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/-</span><span class="mf">6378000.0</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;gradP_&#39;</span><span class="o">+</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_dx</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="n">conv</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;gradP_&#39;</span><span class="o">+</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_dy</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span><span class="o">*</span><span class="n">conv</span>

        
        <span class="c1"># Scalar magnitude:</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;gradP&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;gradP_&#39;</span><span class="o">+</span><span class="n">d</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;gradP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;gradP&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">calc_utotal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate bulk velocity magnitude: $u^2 = u_X^2 + u_Y^2 + u_Z^2$.</span>
<span class="sd">        This is done on a per-fluid basis.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span>
        <span class="kn">from</span> <span class="nn">spacepy.datamodel</span> <span class="kn">import</span> <span class="n">dmarray</span>

        <span class="n">species</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Find all species, the variable names end in &quot;ux&quot;.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;ux&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;u&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
                <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">species</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;u&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;ux&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>
                                        <span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;uy&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>
                                        <span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;uz&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> 
                                  <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="n">units</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_calc_Ekin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate average kinetic energy per particle using </span>
<span class="sd">        $E=\frac{1}{2}mv^2$.  Note that this is not the same as energy</span>
<span class="sd">        density.  Units are $eV$.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span>
        <span class="kn">from</span> <span class="nn">spacepy.datamodel</span> <span class="kn">import</span> <span class="n">dmarray</span>

        <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s2">&quot;This calculation is unverified.&quot;</span><span class="p">)</span>
        
        <span class="n">conv</span> <span class="o">=</span>  <span class="mf">0.5</span> <span class="o">*</span> <span class="mf">0.0103783625</span> <span class="c1"># km^2--&gt;m^2, amu--&gt;kg, J--&gt;eV.</span>
        <span class="k">if</span> <span class="n">units</span><span class="o">.</span><span class="n">lower</span> <span class="o">==</span> <span class="s1">&#39;kev&#39;</span><span class="p">:</span>
            <span class="n">conv</span><span class="o">=</span><span class="n">conv</span><span class="o">/</span><span class="mf">1000.0</span>

        <span class="n">species</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Find all species, the variable names end in &quot;rho&quot;.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1">#and (k!=&#39;rho&#39;) \</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;rho&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;Ekin&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
                <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">species</span><span class="p">:</span>
            <span class="c1">#THIS IS WRONG HERE: 1/2mV**2?  Notsomuch.</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;Ekin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;ux&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>
                                           <span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;uy&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>
                                           <span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;uz&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                                     <span class="o">*</span> <span class="n">conv</span> <span class="o">*</span> <span class="n">mass</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()],</span>
                                     <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="n">units</span><span class="p">})</span>


    <span class="k">def</span> <span class="nf">calc_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Perform all variable calculations (e.g. calculations that</span>
<span class="sd">        begin with &#39;calc_&#39;).  Any exceptions raised by functions that</span>
<span class="sd">        could not be peformed (typicaly from missing variables) are</span>
<span class="sd">        discarded.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;calc_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">command</span> <span class="o">!=</span> <span class="s1">&#39;calc_all&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">command</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;self.&#39;</span><span class="o">+</span><span class="n">command</span><span class="o">+</span><span class="s1">&#39;()&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s1">&#39;Did not perform </span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">command</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1">#####################</span>
    <span class="c1"># Other calculations</span>
    <span class="c1">#####################</span>
    <span class="k">def</span> <span class="nf">gradP_regular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dim1range</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2range</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate pressure gradient on a regular grid.</span>
<span class="sd">        Note that if the Bats2d object is not on a regular grid, one of </span>
<span class="sd">        two things will happen.  If kwarg cellsize is set, the value of </span>
<span class="sd">        cellsize will be used to call self.regrid and the object will</span>
<span class="sd">        be regridded using a cellsize of cellsize.  Kwargs dim1range and</span>
<span class="sd">        dim2range can be used in the same way they are used in self.regrid</span>
<span class="sd">        to restrict the regridding to a smaller domain.  If cellsize is</span>
<span class="sd">        not set and the object is on an irregular grid, an exception is</span>
<span class="sd">        raised.</span>

<span class="sd">        The gradient is calculated using numpy.gradient.  The output units</span>
<span class="sd">        are force density (N/m^3).  Three variables are added to self.data:</span>
<span class="sd">        gradp(dim1), gradp(dim2), gradp.  For example, if the object is an</span>
<span class="sd">        equatorial cut, the variables gradpx, gradpy, and gradp would be</span>
<span class="sd">        added representing the gradient in each direction and then the </span>
<span class="sd">        magnitude of the vector.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">gradient</span><span class="p">,</span> <span class="n">sqrt</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridtype</span> <span class="o">!=</span> <span class="s1">&#39;Regular&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cellsize</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Grid must be regular or &#39;</span> <span class="o">+</span>
                                  <span class="s1">&#39;cellsize must be given.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">cellsize</span><span class="p">,</span> <span class="n">dim1range</span><span class="o">=</span><span class="n">dim1range</span><span class="p">,</span> <span class="n">dim2range</span><span class="o">=</span><span class="n">dim2range</span><span class="p">)</span>

        <span class="c1"># Order our dimensions alphabetically.</span>
        <span class="n">newvars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">newvars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;gradp&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span>

        <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="o">*</span><span class="mf">6378000.0</span> <span class="c1"># RE to meters</span>
        <span class="n">p</span> <span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">10E-9</span>        <span class="c1"># nPa to Pa</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">newvars</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="p">[</span><span class="n">newvars</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">gradient</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;gradp&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">newvars</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">newvars</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cfl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">xcoord</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">ycoord</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the CFL number in each cell given time step dt.</span>

<span class="sd">        Result is stored in self[&#39;cfl&#39;].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">U</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_utotal</span><span class="p">()</span>

        <span class="n">cfl</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">child</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">isLeaf</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">pts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="n">xcoord</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">child</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="p">[</span><span class="n">xcoord</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">child</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="p">[</span><span class="n">ycoord</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">child</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="p">[</span><span class="n">ycoord</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">child</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="p">)</span>

            <span class="n">cfl</span><span class="p">[</span><span class="n">pts</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="p">][</span><span class="n">pts</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">child</span><span class="o">.</span><span class="n">dx</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;cfl&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dmarray</span><span class="p">(</span><span class="n">cfl</span><span class="p">,</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;&#39;</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">vth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">m_avg</span><span class="o">=</span><span class="mf">3.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the thermal velocity. m_avg denotes the average ion </span>
<span class="sd">        mass in AMU.</span>

<span class="sd">        Result is stored in self[&#39;vth&#39;].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m_avg_kg</span><span class="o">=</span><span class="n">m_avg</span><span class="o">*</span><span class="mf">1.6276e-27</span>
        <span class="n">ndensity</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">m_avg</span><span class="o">*</span><span class="mf">1e6</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;vth&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dmarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">1e-9</span><span class="o">/</span><span class="n">ndensity</span><span class="o">/</span><span class="p">(</span><span class="n">m_avg_kg</span><span class="p">))</span>
                            <span class="o">/</span><span class="mi">1000</span><span class="p">,</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;km/s&#39;</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">gyroradius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">velocities</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span><span class="s1">&#39;vth&#39;</span><span class="p">),</span><span class="n">m_avg</span><span class="o">=</span><span class="mf">3.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the ion gyroradius in each cell.</span>

<span class="sd">        velocities to use in calculating the gyroradius are listed by name in </span>
<span class="sd">        the sequence argument velocities. If more than one variable is given, </span>
<span class="sd">        they are summed in quadrature.</span>

<span class="sd">        m_avg denotes the average ion mass in AMU.</span>

<span class="sd">        Result is stored in self[&#39;gyroradius&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;vth&#39;</span> <span class="ow">in</span> <span class="n">velocities</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;vth&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vth</span><span class="p">()</span>

        <span class="k">if</span> <span class="s1">&#39;u&#39;</span> <span class="ow">in</span> <span class="n">velocities</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">U</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calc_utotal</span><span class="p">()</span>

        <span class="n">velocities_squared_sum</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">velocities</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">for</span> <span class="n">vname</span> <span class="ow">in</span> <span class="n">velocities</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">velocities_squared_sum</span><span class="o">+=</span><span class="bp">self</span><span class="p">[</span><span class="n">vname</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

        <span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">velocities_squared_sum</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span>

        <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_b</span><span class="p">()</span>

        <span class="n">B</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">1e-9</span>

        <span class="n">m_avg_kg</span><span class="o">=</span><span class="n">m_avg</span><span class="o">*</span><span class="mf">1.6276e-27</span>

        <span class="n">q</span><span class="o">=</span><span class="mf">1.6022e-19</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;gyroradius&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dmarray</span><span class="p">(</span><span class="n">m_avg_kg</span><span class="o">*</span><span class="n">v</span><span class="o">/</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">B</span><span class="p">)</span><span class="o">/</span><span class="mi">6378000</span><span class="p">,</span>
                                   <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;Re&#39;</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">plasma_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">m_avg</span><span class="o">=</span><span class="mf">3.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the ion plasma frequency.</span>

<span class="sd">        m_avg denotes the average ion mass in AMU.</span>

<span class="sd">        Result is stored in self[&#39;plasm_freq&#39;].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">pi</span>
        <span class="n">m_avg_kg</span><span class="o">=</span><span class="n">m_avg</span><span class="o">*</span><span class="mf">1.6276e-27</span>
        <span class="n">ndensity</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">m_avg</span><span class="o">*</span><span class="mf">1e6</span>
        <span class="n">q</span><span class="o">=</span><span class="mf">1.6022e-19</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;plasma_freq&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dmarray</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">ndensity</span><span class="o">*</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">m_avg_kg</span><span class="p">),</span>
                                    <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;rad/s&#39;</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">inertial_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">m_avg</span><span class="o">=</span><span class="mf">3.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the ion inertial length.</span>

<span class="sd">        m_avg denotes the average ion mass in AMU.</span>

<span class="sd">        Result is stored in self[&#39;inertial_length&#39;].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;plasma_freq&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plasma_freq</span><span class="p">(</span><span class="n">m_avg</span><span class="o">=</span><span class="n">m_avg</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;alfven&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_alfven</span><span class="p">()</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;inertial_length&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dmarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;alfven&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;plasma_freq&#39;</span><span class="p">]</span>
                                        <span class="o">/</span><span class="mi">6378000</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;Re&#39;</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellsize</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">dim1range</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2range</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Re-bin data to regular grid of spacing cellsize.  Action is </span>
<span class="sd">        performed on all data entries in the bats2d object.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">matplotlib.mlab</span> <span class="kn">import</span> <span class="n">griddata</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;gtype&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Regular&#39;</span><span class="p">:</span> <span class="k">return</span>
        
        <span class="c1"># Order our dimensions alphabetically.</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ordered dimensions: &quot;</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>

        <span class="c1"># Check to see if dimranges are 2-element lists.</span>
        <span class="c1"># If not, either set defaults or raise exceptions.</span>
        <span class="k">if</span> <span class="n">dim1range</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">dim1range</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim1range</span><span class="p">,</span> <span class="p">(</span> <span class="nb">type</span><span class="p">(()),</span> <span class="nb">type</span><span class="p">([])</span> <span class="p">)</span> <span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim1range</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dim1range must have two elements!&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;dim1range must be a tuple or list!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim2range</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">dim2range</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim2range</span><span class="p">,</span> <span class="p">(</span> <span class="nb">type</span><span class="p">(()),</span> <span class="nb">type</span><span class="p">([])</span> <span class="p">)</span> <span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim2range</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dim2range must have two elements!&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;dim2range must be a tuple or list!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> range = </span><span class="si">%f</span><span class="s1">, </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim1range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim1range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> range = </span><span class="si">%f</span><span class="s1">, </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim2range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim2range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Now, Regrid.</span>
        <span class="n">grid1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim1range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim1range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">cellsize</span><span class="p">,</span> <span class="n">cellsize</span><span class="p">)</span>
        <span class="n">grid2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim2range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim2range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">cellsize</span><span class="p">,</span> <span class="n">cellsize</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Skip grid-type entries.</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]):</span> <span class="k">continue</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                 <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">grid1</span><span class="p">,</span> <span class="n">grid2</span><span class="p">)</span>

        <span class="c1"># Change grid, gridtype, gridsize, and npoints to match new layout.</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;gtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Regular&#39;</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;npoints&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid2</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cellsize</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">grid1</span><span class="p">;</span> <span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">grid2</span>



    <span class="c1">#############################</span>
    <span class="c1"># EXTRACTION/INTERPOLATION</span>
    <span class="c1">#############################</span>
    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For x, y of a 1D curve, extract values along that curve</span>
<span class="sd">        and return slice as a new :class:`~spacepy.pybats.bats.Extraction` </span>
<span class="sd">        object.  Valid keyword arguments are the same as for </span>
<span class="sd">        :class:`~spacepy.pybats.bats.Extraction`.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="n">Extraction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1">######################</span>
    <span class="c1"># TRACING TOOLS</span>
    <span class="c1">######################</span>
    <span class="k">def</span> <span class="nf">get_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">yvar</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rk4&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">,</span>
                   <span class="n">maxPoints</span><span class="o">=</span><span class="mi">40000</span><span class="p">,</span> <span class="n">extract</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Trace a 2D streamline through the domain, returning a Stream</span>
<span class="sd">        object to the caller.</span>

<span class="sd">        x and y set the starting point for the tracing.</span>

<span class="sd">        xvar and yvar are string keys to self.data that define the</span>
<span class="sd">        vector field through which this function traces.  </span>

<span class="sd">        The method kwarg sets the numerical method to use for the</span>
<span class="sd">        tracing.  Default is Runge-Kutta 4 (rk4).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">startvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">startvals</span><span class="p">,</span> <span class="n">dims</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="ow">or</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Start value </span><span class="si">{}</span><span class="s1"> out of range for variable </span><span class="si">{}</span><span class="s1">.&#39;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">yvar</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span> 
                        <span class="n">maxPoints</span><span class="o">=</span><span class="n">maxPoints</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">extract</span><span class="o">=</span><span class="n">extract</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stream</span>

    <span class="c1">######################</span>
    <span class="c1"># VISUALIZATION TOOLS</span>
    <span class="c1">######################</span>
    <span class="k">def</span> <span class="nf">add_grid_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> <span class="n">do_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">show_nums</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_borders</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet_r&#39;</span><span class="p">,</span>
                      <span class="n">title</span><span class="o">=</span><span class="s1">&#39;BATS-R-US Grid Layout&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a plot of the grid resolution by coloring regions of constant</span>
<span class="sd">        resolution.  Kwarg &quot;target&quot; specifies where to place the plot and can</span>
<span class="sd">        be a figure, an axis, or None.  If target is a figure, a new subplot</span>
<span class="sd">        is created.  The subplot location is set by the kwarg &quot;loc&quot;, which</span>
<span class="sd">        defaults to 111.  If target is an axis, the plot is placed into that</span>
<span class="sd">        axis object.  If target is None, a new figure and axis are created</span>
<span class="sd">        and used to display the plot. </span>

<span class="sd">        Resolution labels can be disabled by setting kwarg do_label to False.</span>

<span class="sd">        Plot title is set using the &#39;title&#39; kwarg, defaults to &#39;BATS-R-US</span>
<span class="sd">        Grid Layout&#39;.</span>

<span class="sd">        Note that if target is not an axis object, the axis will automatically</span>
<span class="sd">        flip the direction of positive X GSM and turn on equal aspect ratio.</span>
<span class="sd">        In other words, if you want a customized axis, it&#39;s best to create</span>
<span class="sd">        one yourself.</span>

<span class="sd">        Figure and axis, even if none given, are returned.</span>

<span class="sd">         Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : Matplotlib Figure or Axes object</span>
<span class="sd">           Set plot destination.  Defaults to new figure.</span>
<span class="sd">        loc : 3-digit integer</span>
<span class="sd">           Set subplot location.  Defaults to 111.</span>
<span class="sd">        do_label : boolean</span>
<span class="sd">           Adds resolution legend to righthand margin.  Defaults to True.</span>
<span class="sd">        show_nums : boolean</span>
<span class="sd">           Adds quadtree values to each region.  Useful for debugging.</span>
<span class="sd">           Defaults to False.</span>
<span class="sd">        show_borders : True</span>
<span class="sd">           Show black borders around each quadtree leaf.  Defaults to True.</span>
<span class="sd">        cmap : string</span>
<span class="sd">           Sets the color map used to color each region.  Must be a Matplotlib</span>
<span class="sd">           named colormap.  Defaults to &#39;jet_r&#39;.</span>
<span class="sd">        title : string</span>
<span class="sd">           Sets the title at the top of the plot.  Defaults to </span>
<span class="sd">           &#39;BATS-R-US Grid Layout&#39;.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">Normalize</span>
        <span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">MultipleLocator</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;gtype&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Regular&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Function not compatable with regular grids&#39;</span><span class="p">)</span>

        <span class="c1"># Get dimensions over which we shall plot.</span>
        <span class="n">xdim</span><span class="p">,</span> <span class="n">ydim</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Set ax and fig based on given target.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="c1"># Set plot range based on quadtree.</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lim</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        <span class="c1"># Plot.</span>

        <span class="k">if</span><span class="p">(</span><span class="n">show_borders</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">plotbox</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="o">.</span><span class="n">plot_res</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tag_leafs</span><span class="o">=</span><span class="n">show_nums</span><span class="p">,</span> <span class="n">do_label</span><span class="o">=</span><span class="n">do_label</span><span class="p">,</span>
                            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>

        <span class="c1"># Customize plot.</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;GSM </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">xdim</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;GSM </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">ydim</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="c1">#if xdim==&#39;x&#39;:</span>
        <span class="c1">#    ax.invert_xaxis()</span>
        <span class="c1">#if ydim==&#39;y&#39;:</span>
        <span class="c1">#    ax.invert_yaxis()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_body</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">add_stream_scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xcomp</span><span class="p">,</span> <span class="n">ycomp</span><span class="p">,</span> <span class="n">nlines</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span>
                           <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rk4&#39;</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">narrow</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">arrsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">arrstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="n">start_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add a set of stream traces to a figure or axes that are distributed</span>
<span class="sd">        evenly but randomly throughout the plot domain.</span>

<span class="sd">        Lines will be seeded randomly over a given spatial range given by</span>
<span class="sd">        *xlim* and *ylim* **OR** the range of the axes (if *target* is set to</span>
<span class="sd">        a non-empty axes object) **OR** over the entire object domain (in that</span>
<span class="sd">        order).  </span>

<span class="sd">        Extra keyword args are handed to matplotlib&#39;s LineCollection object:</span>
<span class="sd">        :class:`matplotlib.collections.LineCollection`.  </span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        xcomp : string</span>
<span class="sd">             The first component of the vector field to trace (e.g., &#39;bx&#39;).</span>
<span class="sd">        ycomp : string</span>
<span class="sd">             The second component of the vector field to trace (e.g., &#39;bz&#39;).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        target : Matplotlib Figure or Axes object</span>
<span class="sd">            Set plot destination.  Defaults to new figure.</span>
<span class="sd">        loc : 3-digit integer</span>
<span class="sd">            Set subplot location.  Defaults to 111.</span>
<span class="sd">        xlim : Two-element list/tuple</span>
<span class="sd">            Set the range in 1st dimension over which lines will be seeded.</span>
<span class="sd">        ylim : Two-element list/tuple</span>
<span class="sd">            Set the range in 2nd dimension over which lines will be seeded.</span>
<span class="sd">        nlines : int</span>
<span class="sd">            Number of stream lines to create; default is 100.</span>
<span class="sd">        start_points : nlinesx2 array</span>
<span class="sd">            Set start_points to define starting location of traces instead of</span>
<span class="sd">            using random points.  This is useful for creating timeseries of</span>
<span class="sd">            plots.</span>
<span class="sd">        narrow : int</span>
<span class="sd">            Add &quot;n&quot; arrows to each line to indicate direction.  Default is </span>
<span class="sd">            zero, or no lines.  If narrow=1, arrows will be placed at </span>
<span class="sd">            *start_points*.</span>
<span class="sd">        arrstyle : string</span>
<span class="sd">            Set the arrow style in the same manner as Matplotlib&#39;s </span>
<span class="sd">            annotate function.  Default is &#39;-&gt;&#39;.</span>
<span class="sd">        arrsize : int</span>
<span class="sd">            Set the size, in points, of each directional arrow.  Default is 12.</span>

<span class="sd">        Returns:</span>
<span class="sd">        ========</span>
<span class="sd">        fig : matplotlib Figure object</span>
<span class="sd">        ax  : matplotlib Axes object</span>
<span class="sd">        collect : matplotlib Collection object of trace results</span>
<span class="sd">        start_points : nlines x 2 array of line starting points</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
        <span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">sample</span>
        <span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>
        <span class="kn">from</span> <span class="nn">spacepy.plot</span> <span class="kn">import</span> <span class="n">add_arrows</span>
        
        <span class="c1"># Set ax and fig based on given target.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

        <span class="c1"># Try to determine the order of the dimensions used:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]</span> <span class="c1"># Default to standard order.</span>
        <span class="n">flip</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">for</span> <span class="n">letters</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xcomp</span><span class="p">,</span> <span class="n">ycomp</span><span class="p">):</span> <span class="c1"># Check for reverse order.</span>
            <span class="k">if</span> <span class="n">letters</span> <span class="o">==</span> <span class="n">dims</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="n">flip</span><span class="o">=</span><span class="kc">True</span>  <span class="c1"># flip it!</span>

        <span class="c1"># Set if using the axes limits is a viable option for setting limits</span>
        <span class="c1"># of region over which to seed lines:</span>
        <span class="n">use_ax_lims</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax</span><span class="p">):</span>
            <span class="n">use_ax_lims</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">artists</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="ow">not</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span> <span class="o">==</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Set range over which to place lines.  Use keyword values if provided</span>
        <span class="c1"># OR subset of axes ranges that fit in domain (if axes are reasonable)</span>
        <span class="k">if</span> <span class="n">xlim</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xlim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
            <span class="k">if</span> <span class="n">use_ax_lims</span><span class="p">:</span>
                <span class="n">axlim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
                <span class="n">xlim</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axlim</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">if</span> <span class="n">ylim</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
            <span class="k">if</span> <span class="n">use_ax_lims</span><span class="p">:</span>
                <span class="n">axlim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
                <span class="n">ylim</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axlim</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="c1"># If initial source points not given, create a random set:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">start_points</span><span class="p">:</span>
            <span class="c1"># Get random points.</span>
            <span class="n">start_points</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span> <span class="p">[</span><span class="n">nlines</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="p">)</span>
            <span class="c1"># Scale to limits:</span>
            <span class="n">start_points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">start_points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">start_points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">start_points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nlines</span> <span class="o">=</span> <span class="n">start_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Extract stream traces, organize x and y coords:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xstart</span><span class="p">,</span> <span class="n">ystart</span> <span class="ow">in</span> <span class="n">start_points</span><span class="p">:</span>
            <span class="c1"># Some index errors crop up from time to time.</span>
            <span class="c1"># While a better solution is dug up, we use a try</span>
            <span class="c1"># block for the time being.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">xstart</span><span class="p">,</span> <span class="n">ystart</span><span class="p">,</span> <span class="n">xcomp</span><span class="p">,</span> <span class="n">ycomp</span><span class="p">,</span>
                                         <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">][::</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">flip</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

        <span class="c1"># Create line collection &amp; plot.</span>
        <span class="n">collect</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collect</span><span class="p">)</span>

        <span class="c1"># Set the plot limits to match</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>

        <span class="c1"># Add arrows if requested.  If one point per line, use starting points.</span>
        <span class="c1"># Otherwise, distribute arrows along lines.</span>
        <span class="k">if</span> <span class="n">narrow</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">add_arrows</span><span class="p">(</span><span class="n">collect</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">narrow</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">arrsize</span><span class="p">,</span>
                       <span class="n">positions</span><span class="o">=</span><span class="n">start_points</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">arrstyle</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">narrow</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">add_arrows</span><span class="p">(</span><span class="n">collect</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">narrow</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">arrsize</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">arrstyle</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">collect</span><span class="p">,</span> <span class="n">start_points</span>
                         
    <span class="k">def</span> <span class="nf">find_earth_lastclosed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">360.</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rk4&#39;</span><span class="p">,</span>
                              <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For Y=0 cuts, attempt to locate the last-closed magnetic field line</span>
<span class="sd">        for both day- and night-sides.  This is done using a bisection </span>
<span class="sd">        approach to precisely locate the transition between open and closed</span>
<span class="sd">        geometries.  The method stops once this transition is found within</span>
<span class="sd">        a latitudinal tolerance of *tol*, which defaults to $\pi/360.$, or</span>
<span class="sd">        one-half degree.  The tracing *method* can be set via keyword and</span>
<span class="sd">        defaults to &#39;rk4&#39; (4th order Runge Kutta, see </span>
<span class="sd">        :class:`~spacepy.pybats.bats.Stream` for more information).</span>
<span class="sd">        The maximum number of iterations the algorithm will take is set</span>
<span class="sd">        by *max_iter*, which defaults to 100.  Latitudinal footprints of the</span>
<span class="sd">        last closed field lines at the inner boundary (not the ionosphere!)</span>
<span class="sd">        are also returned.</span>

<span class="sd">        This method returns 5 objects: </span>
<span class="sd">        </span>
<span class="sd">        * The dipole tilt in radians</span>
<span class="sd">        * A tuple of the northern/southern hemisphere polar angle of </span>
<span class="sd">          footpoints for the dayside last-closed field line.</span>
<span class="sd">        * A tuple of the northern/southern hemisphere polar angle of</span>
<span class="sd">          footpoints for the nightside last-closed field line.</span>
<span class="sd">        * The dayside last-closed field line as a </span>
<span class="sd">          :class:`~spacepy.pybats.bats.Stream` object.</span>
<span class="sd">        * The nightside last-closed field line as a </span>
<span class="sd">          :class:`~spacepy.pybats.bats.Stream` object.</span>

<span class="sd">        In each case, the angle is defined as elevation from the positive</span>
<span class="sd">        x-axis, in radians.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">arctan</span><span class="p">,</span> <span class="n">arctan2</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">)</span>

        <span class="c1"># Get the dipole tilt by tracing a field line near the inner</span>
        <span class="c1"># boundary.  Find the max radial distance; tilt angle == angle off</span>
        <span class="c1"># equator of point of min R (~=max |B|).</span>
        <span class="n">x_small</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span><span class="o">*-</span><span class="mf">1.2</span>  <span class="c1"># check nightside.</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x_small</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> <span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">r</span><span class="o">==</span><span class="n">r</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">tilt</span> <span class="o">=</span> <span class="n">arctan</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">/</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">loc</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dipole is tilted </span><span class="si">{}</span><span class="s1"> degress above the z=0 plane.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">tilt</span><span class="o">*</span><span class="mf">180.</span><span class="o">/</span><span class="n">pi</span><span class="p">))</span>
        
        <span class="c1"># Dayside- start by tracing from plane of min |B| and perp. to that: </span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">1.15</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">tilt</span><span class="p">),</span> <span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">tilt</span><span class="p">),</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span><span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

        <span class="c1"># Get initial angle and step.</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">tilt</span>
        <span class="n">dTheta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span> <span class="c1"># Initially, search 90 degrees.</span>
        <span class="n">nIter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">dTheta</span><span class="o">&gt;</span><span class="n">tol</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">open</span><span class="p">):</span>
            <span class="n">nIter</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Are we closed or open?  Day or nightside?</span>
            <span class="n">closed</span> <span class="o">=</span> <span class="ow">not</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">open</span><span class="p">)</span>  <span class="c1"># open or closed?</span>
            <span class="n">isNig</span>  <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">&lt;</span><span class="mi">0</span> <span class="c1"># line on day or night side?</span>
            <span class="n">isDay</span>  <span class="o">=</span> <span class="ow">not</span> <span class="n">isNig</span>
            
            <span class="c1"># Adjust the angle towards the open-closed boundary.</span>
            <span class="n">theta</span> <span class="o">+=</span> <span class="p">(</span><span class="n">closed</span>  <span class="ow">and</span> <span class="n">isDay</span><span class="p">)</span><span class="o">*</span><span class="n">dTheta</span> <span class="c1"># adjust nightwards.</span>
            <span class="n">theta</span> <span class="o">-=</span> <span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">open</span> <span class="ow">or</span>  <span class="n">isNig</span><span class="p">)</span><span class="o">*</span><span class="n">dTheta</span> <span class="c1"># adjust daywards.</span>
            <span class="c1"># Trace at the new theta to further restrict angular range:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> <span class="s1">&#39;bz&#39;</span><span class="p">,</span> 
                                 <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="c1"># Reduce angular step:</span>
            <span class="n">dTheta</span> <span class="o">/=</span> <span class="mf">2.</span>
            <span class="k">if</span> <span class="n">nIter</span><span class="o">&gt;</span><span class="n">max_iter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Did not converge before reaching max_iter&#39;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="c1"># Possible to land on open or nightside line.</span>
        <span class="c1"># If this happens, inch back to dayside.</span>
        <span class="n">isNig</span>  <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">&lt;</span><span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">open</span> <span class="ow">or</span> <span class="n">isNig</span><span class="p">):</span>
            <span class="n">theta</span><span class="o">-=</span><span class="n">tol</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># inch daywards.</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> <span class="s1">&#39;bz&#39;</span><span class="p">,</span> 
                                 <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="n">isNig</span>  <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">&lt;</span><span class="mi">0</span>
            
        <span class="c1"># Use last line to get southern hemisphere theta:</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">s1</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Distance from origin.</span>
        <span class="c1"># This loc finds the point(s) nearest to Rbody.</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">])</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">r</span><span class="p">[:</span><span class="n">npts</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]))</span> <span class="c1">#point closest to IB.</span>
        <span class="n">xSouth</span><span class="p">,</span> <span class="n">ySouth</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">loc</span><span class="p">],</span> <span class="n">s1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
        <span class="c1"># &quot;+ 0&quot; syntax is to quick-copy object.</span>
        <span class="n">theta_day</span> <span class="o">=</span> <span class="p">[</span><span class="n">theta</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">arctan</span><span class="p">(</span><span class="n">ySouth</span><span class="o">/</span><span class="n">xSouth</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">day</span> <span class="o">=</span> <span class="n">s1</span>

        <span class="c1"># Nightside: Use more points in tracing (lines are long!)</span>
        <span class="n">theta</span><span class="o">+=</span><span class="n">tol</span><span class="o">/</span><span class="mf">2.0</span>  <span class="c1"># Nudge nightwards.</span>
        
        <span class="c1"># Set dTheta to half way between equator and dayside last-closed:</span>
        <span class="n">dTheta</span><span class="o">=</span><span class="p">(</span><span class="n">pi</span><span class="o">+</span><span class="n">tilt</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>

        <span class="n">nIter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">dTheta</span><span class="o">&gt;</span><span class="n">tol</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">open</span><span class="p">):</span>
            <span class="n">nIter</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span><span class="s1">&#39;bz&#39;</span><span class="p">,</span> 
                                 <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxPoints</span><span class="o">=</span><span class="mf">1E6</span><span class="p">)</span>
            <span class="c1"># Closed?  Nightside?</span>
            <span class="n">closed</span> <span class="o">=</span> <span class="ow">not</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">open</span><span class="p">)</span>
            <span class="n">isNig</span>  <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">&lt;</span><span class="mi">0</span>
            <span class="n">isDay</span>  <span class="o">=</span> <span class="ow">not</span> <span class="n">isNig</span>

            <span class="n">theta</span> <span class="o">-=</span> <span class="p">(</span><span class="n">closed</span> <span class="ow">and</span> <span class="n">isNig</span><span class="p">)</span> <span class="o">*</span><span class="n">dTheta</span> <span class="c1"># closed? move poleward.</span>
            <span class="n">theta</span> <span class="o">+=</span> <span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">open</span> <span class="ow">or</span> <span class="n">isDay</span><span class="p">)</span> <span class="o">*</span><span class="n">dTheta</span> <span class="c1"># open?   move equatorward.</span>

            <span class="c1"># Don&#39;t cross over into dayside territory.</span>
            <span class="k">if</span> <span class="n">theta</span> <span class="o">&lt;</span> <span class="n">theta_day</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta_day</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">tol</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span><span class="s1">&#39;bz&#39;</span><span class="p">,</span> 
                                     <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxPoints</span><span class="o">=</span><span class="mf">1E6</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No open flux over polar cap.&#39;</span><span class="p">)</span>
                <span class="k">break</span>
            
            <span class="n">dTheta</span> <span class="o">/=</span> <span class="mf">2.</span>
            <span class="k">if</span> <span class="n">nIter</span><span class="o">&gt;</span><span class="n">max_iter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Did not converge before reaching max_iter&#39;</span><span class="p">)</span>
                <span class="k">break</span>
            
        <span class="c1"># Use last line to get southern hemisphere theta:</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Similar to above for dayside.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">s1</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">])</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">r</span><span class="p">[:</span><span class="n">npts</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]))</span>
        <span class="n">xSouth</span><span class="p">,</span> <span class="n">ySouth</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">loc</span><span class="p">],</span> <span class="n">s1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
        <span class="n">theta_night</span> <span class="o">=</span> <span class="p">[</span><span class="n">theta</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">arctan2</span><span class="p">(</span><span class="n">ySouth</span><span class="p">,</span><span class="n">xSouth</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">night</span> <span class="o">=</span> <span class="n">s1</span>
        <span class="c1">#plt.plot(s1.x, s1.y, &#39;r-&#39;)</span>

        <span class="k">return</span> <span class="n">tilt</span><span class="p">,</span> <span class="n">theta_day</span><span class="p">,</span> <span class="n">theta_night</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">night</span>

    
    <span class="k">def</span> <span class="nf">add_b_magsphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span>  <span class="n">style</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">,</span> 
                        <span class="n">DoLast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">DoOpen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">compX</span><span class="o">=</span><span class="s1">&#39;bx&#39;</span><span class="p">,</span><span class="n">compY</span><span class="o">=</span><span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">narrow</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">arrsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rk4&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">720.</span><span class="p">,</span> <span class="n">DoClosed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">nOpen</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nClosed</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">arrstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create an array of field lines closed to the central body in the</span>
<span class="sd">        domain.  Add these lines to Matplotlib target object *target*.</span>
<span class="sd">        If no *target* is specified, a new figure and axis are created.</span>

<span class="sd">        Note that this should currently only be used for GSM y=0 cuts</span>
<span class="sd">        of the magnetosphere.</span>

<span class="sd">        A tuple containing the figure, axes, and LineCollection object</span>
<span class="sd">        is returned.  </span>

<span class="sd">        Basic styling (color and linestyle) can be handled with the</span>
<span class="sd">        *style*, *colors*, and *linestyles* kwargs.  *style* can accept </span>
<span class="sd">        style names as defined in :class:`~spacepy.pybats.bats.Stream`, which</span>
<span class="sd">        colors and styles lines based on characteristics (e.g., open, closed).</span>
<span class="sd">        The default is &#39;mag&#39;, which colors open lines black and closed lines</span>
<span class="sd">        white.  Alternatively, this kwarg works in a similar manner as </span>
<span class="sd">        it does in :function:`~matplotlib.pyplot.plot`,</span>
<span class="sd">        i.e., a string code such as &quot;b-&quot; (a solid blue line) or &#39;r:&#39; (a</span>
<span class="sd">        dotted red line), etc.  Both *colors* and *linestyles* work much</span>
<span class="sd">        as they do for :class:`~matplotlib.collections.LineCollection`, but</span>
<span class="sd">        only a single value (not a list or tuple) should be provided.</span>
<span class="sd">        *colors* can be a CSS4 color name, an RGB tuple, or a string hex code.</span>
<span class="sd">        *linestyles* can be the name of the style (e.g., &quot;dashed&quot;) or a</span>
<span class="sd">        shortcut compatable with the *style* kwarg (e.g., &quot;--&quot;).  See the</span>
<span class="sd">        documentation for the associated Matplotlib classes &amp; functions to </span>
<span class="sd">        see all options.  Note that *linestyles* and *colors* override</span>
<span class="sd">        *style*.</span>

<span class="sd">        If the styling kwargs are used, they will set the colors for all</span>
<span class="sd">        lines except last-closed boundaries.  Users may control groups </span>
<span class="sd">        individually using multiple calls and plotting one group at a time.</span>
<span class="sd">        Note that *colors* and *linestyles* kwargs will override *style*;</span>
<span class="sd">        *colors* allows for more flexibility concerning color choice.</span>

<span class="sd">        Algorithm:  This method, unlike its predecessor, starts by finding</span>
<span class="sd">        the last closed field lines via </span>
<span class="sd">        :func:`~spacepy.pybats.bats.Bats2d.find_earth_lastclosed`.  It then</span>
<span class="sd">        fills the regions between the open and closed regions.  Currently, it</span>
<span class="sd">        does not treat purely IMF field lines.</span>

<span class="sd">        ========== ===========================================================</span>
<span class="sd">        Kwarg      Description</span>
<span class="sd">        ========== ===========================================================</span>
<span class="sd">        target     The figure or axes to place the resulting lines.</span>
<span class="sd">        style      The color coding system for field lines.  Defaults to &#39;mag&#39;.</span>
<span class="sd">                   See :class:`spacepy.pybats.bats.Stream`.  Because lines are </span>
<span class="sd">                   added as a :class:`~matplotlib.collections.LineCollection`,</span>
<span class="sd">                   only certain styles are allowed (i.e., line styles only,</span>
<span class="sd">                   no marker styles).</span>
<span class="sd">        loc        The location of the subplot on which to place the lines.</span>
<span class="sd">        DoLast     Plot last-closed lines as red lines.  Defaults to **True**.</span>
<span class="sd">        DoOpen     Plot open field lines.  Defaults to **True**.</span>
<span class="sd">        DoClosed   Plot closed field lines.  Defaults to **True**.</span>
<span class="sd">        nOpen      Number of closed field lines to trace per hemisphere.  </span>
<span class="sd">                   Defaults to 5.</span>
<span class="sd">        nClosed    Number of open field lines to trace per hemisphere.</span>
<span class="sd">                   Defaults to 15.</span>
<span class="sd">        narrow     Add &quot;n&quot; arrows to each line to indicate direction.</span>
<span class="sd">                   Default is zero, or no arrows.</span>
<span class="sd">        arrstyle   Set the arrow style in the same manner as Matplotlib&#39;s </span>
<span class="sd">                   annotate function.  Default is &#39;-&gt;&#39;.</span>
<span class="sd">        arrsize    Set the size, in points, of each directional arrow.</span>
<span class="sd">                   Default is 12.</span>
<span class="sd">        method     The tracing method; defaults to &#39;rk4&#39;.   See </span>
<span class="sd">                   :class:`spacepy.pybats.bats.Stream`.</span>
<span class="sd">        tol        Tolerance for finding open-closed boundary; see</span>
<span class="sd">                   :func:`~spacepy.pybats.bats.Bats2d.find_earth_lastclosed`.</span>
<span class="sd">        compX      Name of x-variable through which to trace, defaults to &#39;bx&#39;.</span>
<span class="sd">        compY      Name of y-variable through which to trace, defaults to &#39;bz&#39;.</span>
<span class="sd">        colors     Matplotlib-compatable color name (single) to apply to lines.</span>
<span class="sd">        linestyles A single line style indicator, defaults to &#39;-&#39;; </span>
<span class="sd">                   see :class:`~matplotlib.collections.LineCollection` for </span>
<span class="sd">                   possible options.</span>
<span class="sd">        ========== ===========================================================</span>
<span class="sd">        </span>
<span class="sd">        Extra kwargs are passed to Matplotlib&#39;s LineCollection class as</span>
<span class="sd">        described above.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        fig : matplotlib Figure object</span>
<span class="sd">        ax  : matplotlib Axes object</span>
<span class="sd">        collect : matplotlib Collection object of trace results</span>

<span class="sd">        Examples</span>
<span class="sd">        ========   </span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; from spacepy.pybats import bats</span>
<span class="sd">        &gt;&gt;&gt; # Open a 2D slice, add a pressure contour.</span>
<span class="sd">        &gt;&gt;&gt; # Example file in spacepy/tests/data/pybats_test/:</span>
<span class="sd">        &gt;&gt;&gt; mhd = bats.Bats2d(&#39;./y0_binary.out&#39;)</span>
<span class="sd">        &gt;&gt;&gt; mhd.add_contour(&#39;x&#39;,&#39;z&#39;,&#39;p&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Add field lines using default styling:</span>
<span class="sd">        &gt;&gt;&gt; mhd.add_b_magsphere(target=plt.gca())</span>
<span class="sd">        &gt;&gt;&gt; # Add a subset of lines using custom styling:</span>
<span class="sd">        &gt;&gt;&gt; mhd.add_b_magsphere(target=plt.gca(), DoLast=False, DoOpen=False, style=&#39;g--&#39;)</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">re</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">arctan</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> 
                           <span class="n">arange</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">spacepy.plot</span> <span class="kn">import</span> <span class="n">add_arrows</span>
        
        <span class="c1"># Set ax and fig based on given target.</span>
        <span class="n">adj_lims</span> <span class="o">=</span> <span class="ow">not</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="c1"># If no target set, adjust axes limits.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_body</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="c1"># Lines, colors, and styles:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span>  <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Try to get line style from &quot;style&quot; string.</span>
        <span class="c1"># Default to regular line if not successful.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">linestyles</span><span class="p">:</span>
            <span class="n">lstyle</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;\w&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">style</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lstyle</span><span class="p">:</span>
                <span class="n">linestyles</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linestyles</span><span class="o">=</span><span class="n">lstyle</span>

        <span class="c1"># Start by finding open/closed boundary.</span>
        <span class="n">tilt</span><span class="p">,</span> <span class="n">thetaD</span><span class="p">,</span> <span class="n">thetaN</span><span class="p">,</span> <span class="n">last1</span><span class="p">,</span> <span class="n">last2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_earth_lastclosed</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

        <span class="c1"># Useful parameters for the following traces:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span>
        <span class="n">dTheta</span>  <span class="o">=</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span>
        <span class="n">dThetaN</span> <span class="o">=</span> <span class="o">.</span><span class="mi">05</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thetaN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">thetaD</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dThetaS</span> <span class="o">=</span> <span class="o">.</span><span class="mi">05</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thetaN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">thetaD</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1">## Do closed field lines ##</span>
        <span class="k">if</span> <span class="n">DoClosed</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tDay</span><span class="p">,</span> <span class="n">tNit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>     <span class="n">thetaD</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dTheta</span><span class="p">,</span> <span class="n">nClosed</span><span class="p">),</span>
                    <span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">thetaN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dTheta</span><span class="p">,</span> <span class="n">nClosed</span><span class="p">)):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">tDay</span><span class="p">),</span> <span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">tDay</span><span class="p">)</span>
                <span class="n">sD</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">compX</span><span class="p">,</span><span class="n">compY</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                       <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">)</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">tNit</span><span class="p">),</span> <span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">tNit</span><span class="p">)</span>
                <span class="n">sN</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">compX</span><span class="p">,</span><span class="n">compY</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                       <span class="n">maxPoints</span><span class="o">=</span><span class="mf">1E6</span><span class="p">,</span><span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">)</span>
                <span class="c1"># Append to lines, colors.</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">sD</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sD</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">sN</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sN</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sD</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sN</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                
        <span class="c1">## Do open field lines ##</span>
        <span class="k">if</span> <span class="n">DoOpen</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tNorth</span><span class="p">,</span> <span class="n">tSouth</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">linspace</span><span class="p">(</span><span class="n">thetaD</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dThetaN</span><span class="p">,</span> <span class="n">thetaN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dThetaN</span><span class="p">,</span> <span class="n">nOpen</span><span class="p">),</span>
                    <span class="n">linspace</span><span class="p">(</span><span class="n">thetaN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dThetaS</span><span class="p">,</span> <span class="n">thetaD</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dThetaS</span><span class="p">,</span> <span class="n">nOpen</span><span class="p">)):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">tNorth</span><span class="p">),</span> <span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">tNorth</span><span class="p">)</span>
                <span class="n">sD</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">compX</span><span class="p">,</span><span class="n">compY</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                       <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">)</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">tSouth</span><span class="p">),</span> <span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">tSouth</span><span class="p">)</span>
                <span class="n">sN</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">compX</span><span class="p">,</span><span class="n">compY</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                       <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">)</span>
                <span class="c1"># Append to lines, colors.</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">sD</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sD</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">sN</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sN</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sD</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sN</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>  

        <span class="c1">## Finalize Collection ##</span>
        <span class="c1"># If colors is given, replace what is given from</span>
        <span class="c1"># individual lines.  Keep the list-approach, however.</span>
        <span class="k">if</span> <span class="n">colors</span><span class="p">:</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
                
        <span class="c1"># Add last-closed field lines at end so they are plotted &quot;on top&quot;.</span>
        <span class="k">if</span> <span class="n">DoLast</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">+=</span><span class="p">[</span><span class="n">array</span><span class="p">([</span><span class="n">last1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">last1</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span>
                    <span class="n">array</span><span class="p">([</span><span class="n">last2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">last2</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()]</span>
            <span class="n">cols</span><span class="o">+=</span><span class="mi">2</span><span class="o">*</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span>
            
        <span class="c1"># Create line collection &amp; plot.</span>
        <span class="n">collect</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collect</span><span class="p">)</span>

        <span class="c1"># Add lines if required:</span>
        <span class="k">if</span> <span class="n">narrow</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">add_arrows</span><span class="p">(</span><span class="n">collect</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">narrow</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">arrsize</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">arrstyle</span><span class="p">)</span>
        
        <span class="c1"># On fresh axes, adjust limits from default ([0,1]):</span>
        <span class="k">if</span> <span class="n">adj_lims</span><span class="p">:</span>
            <span class="c1"># Set defaults:</span>
            <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Get x,y locations along each line:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">vertices</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">collect</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()]</span>
            
            <span class="c1"># Get max/min from each line, update lims:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                <span class="n">xlim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ylim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Convert to arrays for element arithmatic:</span>
            <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xlim</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
            
            <span class="c1"># Add a buffer:</span>
            <span class="n">dX</span><span class="p">,</span> <span class="n">dY</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">xlim</span><span class="o">+=</span><span class="p">(</span><span class="o">-</span><span class="n">dX</span><span class="p">,</span> <span class="n">dX</span><span class="p">)</span>
            <span class="n">ylim</span><span class="o">+=</span><span class="p">(</span><span class="o">-</span><span class="n">dY</span><span class="p">,</span> <span class="n">dY</span><span class="p">)</span>

            <span class="c1"># Set new axes limits:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">collect</span>

    <span class="k">def</span> <span class="nf">add_b_magsphere_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This method is included to ease the transistion from the legacy</span>
<span class="sd">        version of *add_b_magsphere* to *add_b_magsphere_new*, whose suffix</span>
<span class="sd">        has been dropped now that it is the standard method.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">warnings</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ATTENTION: add_b_magsphere_new is now simply add_b_magsphere&#39;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;add_b_magsphere_new is a candidate for removal&#39;</span><span class="p">,</span>
                      <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">add_b_magsphere</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">add_b_magsphere_legacy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">,</span> 
                               <span class="n">DoImf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">DoOpen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">DoTail</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                               <span class="n">DoDay</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rk4&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This object method is considered LEGACY and is a candidate for</span>
<span class="sd">        removal.  An updated algorithm using the same name (add_b_magsphere)</span>
<span class="sd">        is the replacement.</span>

<span class="sd">        Create an array of field lines closed to the central body in the</span>
<span class="sd">        domain.  Add these lines to Matplotlib target object *target*.</span>
<span class="sd">        If no *target* is specified, a new figure and axis are created.</span>

<span class="sd">        A tuple containing the figure, axes, and LineCollection object</span>
<span class="sd">        is returned.  Any additional kwargs are handed to the LineCollection</span>
<span class="sd">        object.</span>

<span class="sd">        Note that this should currently only be used for GSM y=0 cuts</span>
<span class="sd">        of the magnetosphere.</span>

<span class="sd">        Method:</span>
<span class="sd">        First, the title angle is approximated by tracing a dipole-like</span>
<span class="sd">        field line and finding the point of maximum radial distance on</span>
<span class="sd">        that line.  This is used as the magnetic equator.  From this </span>
<span class="sd">        equator, many lines are traced starting at the central body</span>
<span class="sd">        radius.  More lines are grouped together at higher magnetic</span>
<span class="sd">        latitude to give good coverage at larger L-shells.  Once an</span>
<span class="sd">        open field line is detected, no more lines are traced.  This</span>
<span class="sd">        is done on the day and night side of the central body.</span>

<span class="sd">        Because this method rarely captures the position of the night</span>
<span class="sd">        side x-line, more field lines are traced by marching radially</span>
<span class="sd">        outwards away from the furthest point from the last traced and</span>
<span class="sd">        closed field line.  This is repeated until open lines are found.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">arctan</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> 
                           <span class="n">arange</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>
        
        <span class="c1"># Set ax and fig based on given target.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">colors</span><span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Approximate the dipole tilt of the central body.</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> <span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">loc</span><span class="p">,</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">r</span><span class="o">==</span><span class="n">r</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">tilt</span> <span class="o">=</span> <span class="n">arctan</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        
        <span class="c1"># Initial values:</span>
        <span class="n">daymax</span>   <span class="o">=</span> <span class="n">tilt</span> <span class="o">+</span> <span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">nightmax</span> <span class="o">=</span> <span class="n">tilt</span> <span class="o">+</span> <span class="mf">3.0</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span>

        <span class="c1"># Day side:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">+</span><span class="mf">1.0</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">tilt</span> <span class="o">+</span> <span class="mf">5.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">12.0</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">angle</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s1">&#39;bx&#39;</span><span class="p">,</span><span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">style</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;k&#39;</span><span class="p">):</span>
                <span class="n">daymax</span> <span class="o">=</span> <span class="n">theta</span>
                <span class="k">break</span>
            <span class="n">savestream</span> <span class="o">=</span> <span class="n">stream</span>
            <span class="k">if</span> <span class="n">DoDay</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">style</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Add IMF field lines.</span>
        <span class="k">if</span> <span class="n">DoImf</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">savestream</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">loc</span><span class="p">,</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">r</span><span class="o">==</span><span class="n">r</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">x_mp</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="mf">0.15</span>
            <span class="n">y_mp</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">delx</span> <span class="o">=</span> <span class="mf">2.0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">x_mp</span><span class="p">,</span> <span class="mf">15.0</span><span class="p">,</span> <span class="n">delx</span><span class="p">)):</span>
                <span class="c1"># From dayside x-line out and up:</span>
                <span class="n">y</span> <span class="o">=</span><span class="n">y_mp</span><span class="o">-</span><span class="n">x_mp</span><span class="o">+</span><span class="n">x</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> <span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span> 
                                         <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">style</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># From top of magnetosphere down:</span>
                <span class="n">y</span> <span class="o">=</span><span class="n">x_mp</span><span class="o">+</span><span class="mf">15.0</span><span class="o">-</span><span class="n">x</span><span class="o">+</span><span class="n">delx</span><span class="o">/</span><span class="mf">3.0</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">delx</span><span class="o">/</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> <span class="s1">&#39;bz&#39;</span><span class="p">,</span> 
                                         <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">style</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># From bottom of mag&#39;sphere down:</span>
                <span class="n">y</span> <span class="o">=</span><span class="n">x_mp</span><span class="o">-</span><span class="mf">10.0</span><span class="o">-</span><span class="n">x</span><span class="o">+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">delx</span><span class="o">/</span><span class="mf">3.0</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">2.0</span><span class="o">*</span><span class="n">delx</span><span class="o">/</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> 
                                         <span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">style</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Night side:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">+</span> <span class="n">tilt</span> <span class="o">+</span> <span class="n">pi</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.5</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">angle</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s1">&#39;bx&#39;</span><span class="p">,</span><span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stream</span><span class="o">.</span><span class="n">open</span><span class="p">:</span>
                <span class="n">nightmax</span> <span class="o">=</span> <span class="n">theta</span>
                <span class="k">break</span>
            <span class="n">savestream</span> <span class="o">=</span> <span class="n">stream</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">style</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        
        <span class="c1"># March down tail.</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">savestream</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">loc</span><span class="p">,</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">r</span><span class="o">==</span><span class="n">r</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x1</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y1</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">():</span>
            <span class="c1">#print &quot;Closed extension at &quot;, x-1.5, y</span>
            <span class="c1">#ax.plot(x-1.5, y, &#39;g^&#39;, ms=10)</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> <span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span> 
                                     <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stream</span><span class="o">.</span><span class="n">open</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">style</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">loc</span><span class="p">,</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">r</span><span class="o">==</span><span class="n">r</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x1</span><span class="o">+</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> <span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">loc</span><span class="p">,</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">r</span><span class="o">==</span><span class="n">r</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1">## Add more along neutral sheet.</span>
        <span class="k">if</span> <span class="n">DoTail</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span>
        <span class="c1">#print &quot;Slope = &quot;, m</span>
        <span class="c1">#print &quot;From y, y1 = &quot;, y, y1</span>
        <span class="c1">#print &quot;and x, x1 = &quot;, x, x1</span>
        <span class="c1">#ax.plot([x,x1],[y,y1], &#39;wo&#39;, ms=10)</span>
            <span class="n">xmore</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">)</span>
            <span class="n">ymore</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="n">xmore</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">y</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>  <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xmore</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">ymore</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> <span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span> 
                                         <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">style</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1">#ax.plot(xmore, ymore, &#39;r+&#39;)</span>

        <span class="c1"># Add open field lines.</span>
        <span class="k">if</span> <span class="n">DoOpen</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">linspace</span><span class="p">(</span><span class="n">daymax</span><span class="p">,</span><span class="mf">0.99</span><span class="o">*</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">pi</span><span class="o">+</span><span class="n">tilt</span><span class="p">))</span><span class="o">-</span><span class="n">nightmax</span><span class="p">,</span> <span class="mi">15</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s1">&#39;bx&#39;</span><span class="p">,</span><span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stream</span><span class="o">.</span><span class="n">open</span><span class="p">:</span> 
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                    <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">style</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="o">+</span><span class="n">pi</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="o">+</span><span class="n">pi</span><span class="p">)</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s1">&#39;bx&#39;</span><span class="p">,</span><span class="s1">&#39;bz&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stream</span><span class="o">.</span><span class="n">open</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">stream</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                    <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">style</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="s1">&#39;colors&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">colors</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;colors&#39;</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;colors&#39;</span><span class="p">)</span>
        <span class="n">collect</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collect</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">collect</span>

    <span class="k">def</span> <span class="nf">add_planet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ang</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Creates a circle of radius=self.attrs[&#39;rbody&#39;] and returns the</span>
<span class="sd">        MatPlotLib Ellipse patch object for plotting.  If an axis is specified</span>
<span class="sd">        using the &quot;ax&quot; keyword, the patch is added to the plot.</span>

<span class="sd">        Unlike the add_body method, the circle is colored half white (dayside)</span>
<span class="sd">        and half black (nightside) to coincide with the direction of the </span>
<span class="sd">        sun. Additionally, because the size of the planet is not intrinsically</span>
<span class="sd">        known to the MHD file, the kwarg &quot;rad&quot;, defaulting to 1.0, sets the</span>
<span class="sd">        size of the planet.</span>

<span class="sd">        Extra keywords are handed to the Ellipse generator function.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Circle</span><span class="p">,</span> <span class="n">Wedge</span>

        <span class="k">if</span> <span class="s1">&#39;rbody&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;rbody not found in self.attrs!&#39;</span><span class="p">)</span>

        <span class="n">body</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">rad</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_kwargs</span><span class="p">)</span>
        <span class="n">arch</span> <span class="o">=</span> <span class="n">Wedge</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">rad</span><span class="p">,</span> <span class="mf">90.</span><span class="o">+</span><span class="n">ang</span><span class="p">,</span> <span class="o">-</span><span class="mf">90.</span><span class="o">+</span><span class="n">ang</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> 
                     <span class="n">zorder</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_kwargs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">arch</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">body</span><span class="p">,</span> <span class="n">arch</span>

    <span class="k">def</span> <span class="nf">add_body</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;lightgrey&#39;</span><span class="p">,</span> <span class="n">DoPlanet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ang</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
                 <span class="o">**</span><span class="n">extra_kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Creates a circle of radius=self.attrs[&#39;rbody&#39;] and returns the</span>
<span class="sd">        MatPlotLib Ellipse patch object for plotting.  If an axis is specified</span>
<span class="sd">        using the &quot;ax&quot; keyword, the patch is added to the plot.</span>
<span class="sd">        Default color is light grey; extra keywords are handed to the Ellipse</span>
<span class="sd">        generator function.</span>

<span class="sd">        Because the body is rarely the size of the planet at the center of </span>
<span class="sd">        the modeling domain, add_planet is automatically called.  This can</span>
<span class="sd">        be negated by using the DoPlanet kwarg.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Ellipse</span>

        <span class="k">if</span> <span class="s1">&#39;rbody&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;rbody not found in self.attrs!&#39;</span><span class="p">)</span>

        <span class="n">dbody</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;rbody&#39;</span><span class="p">]</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">Ellipse</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">dbody</span><span class="p">,</span><span class="n">dbody</span><span class="p">,</span><span class="n">facecolor</span><span class="o">=</span><span class="n">facecolor</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">extra_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">DoPlanet</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_planet</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ang</span><span class="o">=</span><span class="n">ang</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_pcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">zlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> 
                   <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add_cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">add_body</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dolog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;        </span>
<span class="sd">        Create a pcolor plot of variable **value** against **dim1** on the </span>
<span class="sd">        x-axis and **dim2** on the y-axis.  Pcolor plots shade each</span>
<span class="sd">        computational cell with the value at the cell center.  Because no </span>
<span class="sd">        interpolation or smoothing is used in the visualization, pcolor plots</span>
<span class="sd">        are excellent for examining the raw output.</span>
<span class="sd">        </span>
<span class="sd">        Simple example:</span>

<span class="sd">        &gt;&gt;&gt; self.add_pcolor(&#39;x&#39;, &#39;y&#39;, &#39;rho&#39;)</span>

<span class="sd">        If kwarg **target** is None (default), a new figure is </span>
<span class="sd">        generated from scratch.  If target is a matplotlib Figure</span>
<span class="sd">        object, a new axis is created to fill that figure at subplot</span>
<span class="sd">        location **loc**.  If **target** is a matplotlib Axes object, </span>
<span class="sd">        the plot is placed into that axis.</span>

<span class="sd">        Four values are returned: the matplotlib Figure and Axes objects,</span>
<span class="sd">        the matplotlib contour object, and the matplotlib colorbar object</span>
<span class="sd">        (defaults to *False* if not used.)</span>

<span class="sd">        =========== ==========================================================</span>
<span class="sd">        Kwarg       Description</span>
<span class="sd">        =========== ==========================================================</span>
<span class="sd">        target      Set plot destination.  Defaults to new figure.</span>
<span class="sd">        loc         Set subplot location.  Defaults to 111.</span>
<span class="sd">        title       Sets title of axes.  Default is no title.</span>
<span class="sd">        xlabel      Sets x label of axes.  Defaults to **dim1** and units.</span>
<span class="sd">        ylabel      Sets y label of axes.  Defaults to **dim2** and units.</span>
<span class="sd">        xlim        Sets limits of x-axes.  Defaults to whole domain.</span>
<span class="sd">        ylim        Sets limits of y-axes.  Defaults to whole domain.</span>
<span class="sd">        zlim        Sets color bar range.  Defaults to variable max/min.</span>
<span class="sd">        add_cbar    Adds colorbar to plot.  Defaults to *False*.</span>
<span class="sd">        clabel      Sets colorbar label.  Defaults to **var** and units.</span>
<span class="sd">        add_body    Places planetary body in plot.  Defaults to **True**.</span>
<span class="sd">        dolog       Sets use of logarithmic scale.  Defaults to **False**.</span>
<span class="sd">        =========== ==========================================================</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">numbers</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">LogNorm</span>

        <span class="c1"># Set ax and fig based on given target.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

        <span class="c1"># Get max/min if none given.</span>
        <span class="k">if</span> <span class="n">zlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zlim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">();</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dolog</span> <span class="ow">and</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">1000.0</span><span class="p">]</span> <span class="p">)</span>

        <span class="c1"># Logarithmic scale?</span>
        <span class="k">if</span> <span class="n">dolog</span><span class="p">:</span>
            <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">&gt;</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">],</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">LogNorm</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;gtype&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;Regular&#39;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Indices corresponding to QTree dimensions:</span>
            <span class="n">ix</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim1</span><span class="p">)</span>
            <span class="n">iy</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">:</span>
                <span class="c1"># Plot only leafs of the tree.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">isLeaf</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">leaf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qtree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">x</span><span class="o">=</span><span class="n">leaf</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
                <span class="n">y</span><span class="o">=</span><span class="n">leaf</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">iy</span><span class="p">]</span>
                <span class="n">z_local</span><span class="o">=</span><span class="n">z</span><span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">locs</span><span class="p">]</span>
                <span class="n">pcol</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z_local</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">vmax</span><span class="o">=</span><span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Add cbar if necessary.</span>
        <span class="k">if</span> <span class="n">add_cbar</span><span class="p">:</span>
            <span class="n">cbar</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">pcol</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clabel</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> 
                <span class="n">clabel</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">])</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">clabel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cbar</span><span class="o">=</span><span class="kc">None</span> <span class="c1"># Need to return something, even if none.</span>
 
        <span class="c1"># Set title, labels, axis ranges (use defaults where applicable.)</span>
        <span class="k">if</span> <span class="n">title</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylabel</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> ($R_</span><span class="si">{E}</span><span class="s1">$)&#39;</span><span class="o">%</span><span class="n">dim2</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">xlabel</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> ($R_</span><span class="si">{E}</span><span class="s1">$)&#39;</span><span class="o">%</span><span class="n">dim1</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">);</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xlim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;add_pcolor: xlim must be list- or array-like and have 2 elements&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ylim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;add_pcolor: ylim must be list- or array-like and have 2 elements&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>

        <span class="c1"># Add body/planet.  Determine where the sun is first.</span>
        <span class="k">if</span> <span class="n">dim1</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">ang</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">dim2</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">ang</span><span class="o">=</span><span class="mf">90.0</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">ang</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">add_body</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_body</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ang</span><span class="o">=</span><span class="n">ang</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">pcol</span><span class="p">,</span> <span class="n">cbar</span>                              

    <span class="k">def</span> <span class="nf">add_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">nlev</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> 
                    <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add_cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">filled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add_body</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dolog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a contour plot of variable **value** against **dim1** on the </span>
<span class="sd">        x-axis and **dim2** on the y-axis.</span>
<span class="sd">        </span>
<span class="sd">        Simple example:</span>

<span class="sd">        &gt;&gt;&gt; self.add_contour(&#39;x&#39;, &#39;y&#39;, &#39;rho&#39;)</span>

<span class="sd">        If kwarg **target** is None (default), a new figure is </span>
<span class="sd">        generated from scratch.  If target is a matplotlib Figure</span>
<span class="sd">        object, a new axis is created to fill that figure at subplot</span>
<span class="sd">        location **loc**.  If **target** is a matplotlib Axes object, </span>
<span class="sd">        the plot is placed into that axis.</span>

<span class="sd">        Four values are returned: the matplotlib Figure and Axes objects,</span>
<span class="sd">        the matplotlib contour object, and the matplotlib colorbar object</span>
<span class="sd">        (defaults to *False* if not used.)</span>

<span class="sd">        =========== ==========================================================</span>
<span class="sd">        Kwarg       Description</span>
<span class="sd">        =========== ==========================================================</span>
<span class="sd">        target      Set plot destination.  Defaults to new figure.</span>
<span class="sd">        loc         Set subplot location.  Defaults to 111.</span>
<span class="sd">        nlev        Number of contour levels.  Defaults to 30.</span>
<span class="sd">        title       Sets title of axes.  Default is no title.</span>
<span class="sd">        xlabel      Sets x label of axes.  Defaults to **dim1** and units.</span>
<span class="sd">        ylabel      Sets y label of axes.  Defaults to **dim2** and units.</span>
<span class="sd">        xlim        Sets limits of x-axes.  Defaults to whole domain.</span>
<span class="sd">        ylim        Sets limits of y-axes.  Defaults to whole domain.</span>
<span class="sd">        zlim        Sets contour range.  Defaults to variable max/min.</span>
<span class="sd">        add_cbar    Adds colorbar to plot.  Defaults to *False*.</span>
<span class="sd">        clabel      Sets colorbar label.  Defaults to **var** and units.</span>
<span class="sd">        add_body    Places planetary body in plot.  Defaults to **True**.</span>
<span class="sd">        dolog       Sets use of logarithmic scale.  Defaults to **False**.</span>
<span class="sd">        =========== ==========================================================</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">numbers</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="p">(</span><span class="n">LogNorm</span><span class="p">,</span> <span class="n">Normalize</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="p">(</span><span class="n">LogLocator</span><span class="p">,</span> <span class="n">LogFormatter</span><span class="p">,</span> 
                                       <span class="n">LogFormatterMathtext</span><span class="p">,</span> <span class="n">MultipleLocator</span><span class="p">)</span>

        <span class="c1"># Set ax and fig based on given target.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

        <span class="c1"># Get max/min if none given.</span>
        <span class="k">if</span> <span class="n">zlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zlim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">();</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dolog</span> <span class="ow">and</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">1000.0</span><span class="p">]</span> <span class="p">)</span>

        <span class="c1"># Set contour command based on grid type.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;gtype&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;Regular&#39;</span><span class="p">:</span>  <span class="c1"># Non-uniform grids.</span>
            <span class="k">if</span> <span class="n">filled</span><span class="p">:</span>
                <span class="n">contour</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">tricontourf</span>   
            <span class="k">else</span><span class="p">:</span>
                <span class="n">contour</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">tricontour</span>   
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># Uniform grids.</span>
            <span class="k">if</span> <span class="n">filled</span><span class="p">:</span>
                <span class="n">contour</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">contourf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">contour</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">contour</span>

        <span class="c1"># Create levels and set norm based on dolog.</span>
        <span class="k">if</span> <span class="n">dolog</span><span class="p">:</span>
            <span class="n">levs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                                            <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">nlev</span><span class="p">))</span>
            <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">&gt;</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">],</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">LogNorm</span><span class="p">()</span>
            <span class="n">ticks</span><span class="o">=</span><span class="n">LogLocator</span><span class="p">()</span>
            <span class="n">fmt</span><span class="o">=</span><span class="n">LogFormatterMathtext</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">levs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nlev</span><span class="p">)</span>
            <span class="n">z</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span>
            <span class="n">ticks</span><span class="o">=</span><span class="kc">None</span>
            <span class="n">fmt</span><span class="o">=</span><span class="kc">None</span>

        <span class="c1"># Plot contour.</span>
        <span class="n">cont</span><span class="o">=</span><span class="n">contour</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">dim1</span><span class="p">],</span><span class="bp">self</span><span class="p">[</span><span class="n">dim2</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">),</span>
                     <span class="n">levs</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Add cbar if necessary.</span>
        <span class="k">if</span> <span class="n">add_cbar</span><span class="p">:</span>
            <span class="n">cbar</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">ticks</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clabel</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> 
                <span class="n">clabel</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">])</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">clabel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cbar</span><span class="o">=</span><span class="kc">None</span> <span class="c1"># Need to return something, even if none.</span>
 
        <span class="c1"># Set title, labels, axis ranges (use defaults where applicable.)</span>
        <span class="k">if</span> <span class="n">title</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylabel</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> ($R_</span><span class="si">{E}</span><span class="s1">$)&#39;</span><span class="o">%</span><span class="n">dim2</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">xlabel</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> ($R_</span><span class="si">{E}</span><span class="s1">$)&#39;</span><span class="o">%</span><span class="n">dim1</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">);</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xlim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;add_contour: xlim must be list- or array-like and have 2 elements&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ylim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;add_contour: ylim must be list- or array-like and have 2 elements&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>

        <span class="c1"># Add body/planet.  Determine where the sun is first.</span>
        <span class="k">if</span> <span class="n">dim1</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">ang</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">dim2</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">ang</span><span class="o">=</span><span class="mf">90.0</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">ang</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">add_body</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_body</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ang</span><span class="o">=</span><span class="n">ang</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">cont</span><span class="p">,</span> <span class="n">cbar</span></div>


<span class="k">class</span> <span class="nc">ShellSlice</span><span class="p">(</span><span class="n">IdlFile</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Shell slices are special MHD outputs where the domain is interpolated</span>
<span class="sd">    onto a spherical slice in 1, 2, or 3 dimensions.  Some examples</span>
<span class="sd">    include radial or azimuthal lines, spherical shells, or 3D wedges.</span>

<span class="sd">    The *Shell* class reads and handles these output types.  </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="kn">from</span> <span class="nn">spacepy.pybats</span> <span class="kn">import</span> <span class="n">parse_filename_time</span>

        <span class="n">IdlFile</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">keep_case</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Extract time from file name:</span>
        <span class="n">i_iter</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">parse_filename_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="k">if</span> <span class="s1">&#39;iter&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_iter</span>

        <span class="c1">### Create some helper variables for plotting and calculations</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span> <span class="c1"># Convert degrees to radians.</span>
        
        <span class="c1"># Get grid spacing.  If npoints ==1, set to 1 to avoid math errors.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drad</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">][</span>  <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">][</span>  <span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dlon</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dlat</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dphi</span>   <span class="o">=</span> <span class="n">d2r</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dlon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtheta</span> <span class="o">=</span> <span class="n">d2r</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dlat</span>

        <span class="c1"># Get spherical, uniform grid in units of r_body/radians:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span>   <span class="o">=</span> <span class="n">d2r</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">d2r</span><span class="o">*</span><span class="p">(</span><span class="mi">90</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

        
    <span class="k">def</span> <span class="nf">calc_urad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate radial velocity.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">ur</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> \
             <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;uy&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> \
             <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;uz&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">ur</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ux&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]})</span>

    <span class="k">def</span> <span class="nf">calc_radflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">conv</span><span class="o">=</span><span class="mf">1000.</span> <span class="o">*</span> <span class="p">(</span><span class="mf">100.0</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For variable *var*, calculate the radial flux of *var* through each</span>
<span class="sd">        grid point in the slice as self[var]*self[&#39;ur&#39;].</span>
<span class="sd">        Resulting value stored as &quot;var_rflx&quot;.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">var</span><span class="o">+</span><span class="s1">&#39;_rflx&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="k">return</span>
        
        <span class="c1"># Make sure we have radial velocity.</span>
        <span class="k">if</span> <span class="s1">&#39;ur&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_urad</span><span class="p">()</span>

        <span class="c1"># Calc flux:</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">var</span><span class="o">+</span><span class="s1">&#39;_rflx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">conv</span>

    <span class="k">def</span> <span class="nf">calc_radflu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For variable *var*, calculate the radial fluence, or the </span>
<span class="sd">        spatially integrated radial flux through 2D surfaces of </span>
<span class="sd">        constant radius.</span>

<span class="sd">        Resulting variable stored as &quot;var_rflu&quot;.  Result will be an array</span>
<span class="sd">        with one value for each radial distance within the object.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Need at least 2D in angle space:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dphi</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtheta</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Fluence can only be calculated for 2D+ surfaces.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Trim flux off of val name:</span>
        <span class="k">if</span> <span class="s1">&#39;_rflx&#39;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span> <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
        
        <span class="c1"># Convenience:</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">var</span> <span class="o">+</span> <span class="s1">&#39;_rflx&#39;</span>
        <span class="n">flu</span>  <span class="o">=</span> <span class="n">var</span> <span class="o">+</span> <span class="s1">&#39;_rflu&#39;</span>
        
        <span class="c1"># Make sure flux exists:</span>
        <span class="k">if</span> <span class="n">flux</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_radflux</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flu</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="k">return</span>

        <span class="c1"># Create output container, one point per radial distance:</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">flu</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> 

        <span class="c1"># Integrate over all radii.</span>
        <span class="c1"># Units: convert R to km and cm-3 to km.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">R</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">flu</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="p">(</span><span class="n">R</span><span class="o">*</span> <span class="mf">6371.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="n">flux</span><span class="p">][</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">*</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:])</span>  <span class="o">*</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">dtheta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dphi</span> <span class="o">*</span> <span class="mf">1000.</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>


    <span class="k">def</span> <span class="nf">add_cont_shell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">irad</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span>
                       <span class="n">zlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dolabel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add_cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">dofill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nlev</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span> <span class="n">colat_max</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span>
                       <span class="n">rotate</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">dolog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">latticks</span><span class="o">=</span><span class="mf">15.</span><span class="p">,</span> <span class="n">yticksize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For slices that cover a full hemisphere or more, create a polar</span>
<span class="sd">        plot of variable *value*.</span>

<span class="sd">        Extra keywords are sent to the matplotlib contour command.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Circle</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="p">(</span><span class="n">LogNorm</span><span class="p">,</span> <span class="n">Normalize</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="p">(</span><span class="n">LogLocator</span><span class="p">,</span> <span class="n">LogFormatter</span><span class="p">,</span> 
                                       <span class="n">LogFormatterMathtext</span><span class="p">,</span> <span class="n">MultipleLocator</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get max/min if none given.</span>
        <span class="k">if</span> <span class="n">zlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zlim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">][</span><span class="n">irad</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">][</span><span class="n">irad</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="c1"># For log space, no negative zlimits.</span>
            <span class="k">if</span> <span class="n">dolog</span> <span class="ow">and</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">1000.0</span><span class="p">]</span> <span class="p">)</span>

        <span class="c1"># Create levels and set norm based on dolog.</span>
        <span class="k">if</span> <span class="n">dolog</span><span class="p">:</span>  <span class="c1"># Log space!</span>
            <span class="n">levs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                                            <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">nlev</span><span class="p">))</span>
            <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">&gt;</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">],</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">LogNorm</span><span class="p">()</span>
            <span class="n">ticks</span><span class="o">=</span><span class="n">LogLocator</span><span class="p">()</span>
            <span class="n">fmt</span><span class="o">=</span><span class="n">LogFormatterMathtext</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">levs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nlev</span><span class="p">)</span>
            <span class="n">z</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span>
            <span class="n">ticks</span><span class="o">=</span><span class="kc">None</span>
            <span class="n">fmt</span><span class="o">=</span><span class="kc">None</span>

        <span class="c1"># Select proper contour function based on fill/don&#39;t fill.</span>
        <span class="k">if</span> <span class="n">dofill</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contour</span>

        <span class="c1"># Plot result.  Rotate &quot;rotate&quot; radians to get sun in right spot.</span>
        <span class="c1"># Plot against colatitude to arrange results correctly.</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">irad</span><span class="p">,:,:]</span><span class="o">+</span><span class="n">rotate</span><span class="p">,</span> <span class="mi">90</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">irad</span><span class="p">,:,:],</span>
                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">][</span><span class="n">irad</span><span class="p">,:,:]),</span> <span class="n">levs</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                   <span class="n">extend</span><span class="o">=</span><span class="n">extend</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Add cbar if necessary.</span>
        <span class="k">if</span> <span class="n">add_cbar</span><span class="p">:</span>
            <span class="n">cbar</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">ticks</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=.</span><span class="mi">85</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clabel</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> 
                <span class="n">clabel</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">])</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">clabel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cbar</span><span class="o">=</span><span class="kc">None</span> <span class="c1"># Need to return something, even if none.</span>

        <span class="c1"># Adjust latitude</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">colat_max</span><span class="p">]</span> <span class="p">)</span>

        <span class="c1"># Adjust atitude and add better labels:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MultipleLocator</span><span class="p">(</span><span class="n">latticks</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">colat_max</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;size&#39;</span><span class="p">:</span><span class="n">yticksize</span><span class="p">,</span> <span class="s1">&#39;rotation&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">45</span><span class="p">,</span> <span class="s1">&#39;ha&#39;</span><span class="p">:</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;va&#39;</span><span class="p">:</span><span class="s1">&#39;center&#39;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">90</span><span class="o">-</span><span class="n">latticks</span><span class="p">,</span> <span class="mi">90</span><span class="o">-</span><span class="n">colat_max</span><span class="p">,</span> <span class="o">-</span><span class="n">latticks</span><span class="p">):</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:02.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;$^{\circ}$&#39;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">90.</span><span class="o">-</span><span class="n">theta</span><span class="p">,</span> <span class="n">txt</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;extra bold&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">opts</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">90.</span><span class="o">-</span><span class="n">theta</span><span class="p">,</span> <span class="n">txt</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;light&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
        
        <span class="c1"># Use MLT-type labels. </span>
        <span class="n">lt_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Noon&#39;</span><span class="p">,</span> <span class="s1">&#39;18&#39;</span><span class="p">,</span> <span class="s1">&#39;00&#39;</span><span class="p">,</span>   <span class="s1">&#39;06&#39;</span><span class="p">]</span>
        <span class="n">xticks</span>    <span class="o">=</span> <span class="p">[</span>     <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>   <span class="n">pi</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">xticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xticks</span><span class="p">)</span> <span class="o">+</span> <span class="n">rotate</span>

        <span class="c1"># Apply x-labels:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">xticks</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">lt_labels</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">cbar</span>

        
<div class="viewcode-block" id="Mag"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.Mag.html#spacepy.pybats.bats.Mag">[docs]</a><span class="k">class</span> <span class="nc">Mag</span><span class="p">(</span><span class="n">PbData</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A container for data from a single BATS-R-US virtual magnetometer.  These</span>
<span class="sd">    work just like a typical :class:`spacepy.pybats.PbData` object.  Beyond</span>
<span class="sd">    raw magnetometer data, additional values are calculated and stored,</span>
<span class="sd">    including total pertubations (the sum of all global and ionospheric </span>
<span class="sd">    pertubations as measured by the magnetometer).  Users will be interested</span>
<span class="sd">    in methods :meth:`~spacepy.pybats.bats.Mag.add_comp_plot` and </span>
<span class="sd">    :meth:`~spacepy.pybats.bats.Mag.calc_dbdt`.</span>

<span class="sd">    Instantiation is best done through :class: `spacepy.pybats.MagFile`</span>
<span class="sd">    objects, which load and parse organize many virtual magnetometers from a </span>
<span class="sd">    single output file into a single object.  However, they can be created</span>
<span class="sd">    manually, though painfully.  Users must instantiate by handing the </span>
<span class="sd">    new object the number of lines that will be parsed (rather, the number</span>
<span class="sd">    of data points that will be needed), a time vector, and (optionally) </span>
<span class="sd">    the list of variables coming from the GM and IE module.  While the </span>
<span class="sd">    latter two are keyword arguments, at least one should be provided.</span>
<span class="sd">    Next, the arrays whose keys were given by the *gmvars* and *ievars*</span>
<span class="sd">    keyword arguments in the instantiation step can either be filled manually</span>
<span class="sd">    or by using the :meth:`~spacepy.pybats.bats.Mag.parse_gmline` and</span>
<span class="sd">    :meth:`~spacepy.pybats.bats.Mag.parse_ieline` methods to parse lines of </span>
<span class="sd">    ascii data from a magnetometer output file.  Finally, the</span>
<span class="sd">    :meth:`~spacepy.pybats.bats.Mag.recalc` method should be called to </span>
<span class="sd">    calculate total perturbation.</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nlines</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">gmvars</span><span class="o">=</span><span class="p">(),</span> <span class="n">ievars</span><span class="o">=</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Mag</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># Init as PbData.</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;nlines&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">nlines</span>
        
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nlines</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nlines</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nlines</span><span class="p">)</span>

        <span class="c1"># Create IE and GM specific containers.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">gmvars</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nlines</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ievars</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ie_&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nlines</span><span class="p">)</span>
            
    <span class="k">def</span> <span class="nf">parse_gmline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">namevar</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parse a single line from a GM_mag*.out file and put into</span>
<span class="sd">        the proper place in the magnetometer arrays.  The line should </span>
<span class="sd">        have the same number of variables as was initially given to the</span>
<span class="sd">        :class:`~spacepy.pybats.bats.Mag` object.  This method is best</span>
<span class="sd">        used through the :class:`~spacepy.pybats.bats.MagFile` class interface.</span>

<span class="sd">        Usage: </span>

<span class="sd">        &gt;&gt;&gt; self.parse_gmline(i, line, namevar)</span>

<span class="sd">        where i is the entry number, line is the raw ascii line, and</span>
<span class="sd">        namevar is the list of variable names.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">parts</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">namevar</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">12</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">parse_ieline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">namevar</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parse a single line from a IE_mag*.out file and put into</span>
<span class="sd">        the proper place in the magnetometer arrays.  The line should </span>
<span class="sd">        have the same number of variables as was initially given to the</span>
<span class="sd">        :class:`~spacepy.pybats.bats.Mag` object.  This method is best</span>
<span class="sd">        used through the :class:`~spacepy.pybats.bats.MagFile` class interface.</span>


<span class="sd">        Usage: </span>

<span class="sd">        &gt;&gt;&gt; self.parse_gmline(i, line, namevar)</span>

<span class="sd">        where i is the entry number, line is the raw ascii line, and</span>
<span class="sd">        namevar is the list of variable names.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">parts</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">namevar</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ie_&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">11</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_recalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate total :math:`\Delta B` from GM and IE; store under object keys</span>
<span class="sd">        *totaln*, *totale*, and *totald* (one for each component of the HEZ </span>
<span class="sd">        coordinate system).</span>

<span class="sd">        This function should only be called to correct legacy versions of </span>
<span class="sd">        magnetometer files.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">zeros</span>

        <span class="c1"># If values already exist, do not overwrite.</span>
        <span class="k">if</span> <span class="s1">&#39;dBn&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="k">return</span>
        
        <span class="c1"># New containers:</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;totaln&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;nlines&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;totale&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;nlines&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;totald&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;nlines&#39;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span><span class="o">==</span><span class="s1">&#39;Bn&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;totaln&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;totaln&#39;</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span><span class="o">==</span><span class="s1">&#39;Be&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;totale&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;totale&#39;</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span><span class="o">==</span><span class="s1">&#39;Bd&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;totald&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;totald&#39;</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Old names -&gt; new names:</span>
        <span class="n">varmap</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;totaln&#39;</span><span class="p">:</span><span class="s1">&#39;dBn&#39;</span><span class="p">,</span>       <span class="s1">&#39;totale&#39;</span><span class="p">:</span><span class="s1">&#39;dBe&#39;</span><span class="p">,</span>      <span class="s1">&#39;totald&#39;</span><span class="p">:</span><span class="s1">&#39;dBd&#39;</span><span class="p">,</span>
                <span class="s1">&#39;gm_dBn&#39;</span><span class="p">:</span><span class="s1">&#39;dBnMhd&#39;</span><span class="p">,</span>    <span class="s1">&#39;gm_dBe&#39;</span><span class="p">:</span><span class="s1">&#39;dBeMhd&#39;</span><span class="p">,</span>   <span class="s1">&#39;gm_dBd&#39;</span><span class="p">:</span><span class="s1">&#39;dBdMhd&#39;</span><span class="p">,</span>
                <span class="s1">&#39;gm_facdBn&#39;</span><span class="p">:</span><span class="s1">&#39;dBnFac&#39;</span><span class="p">,</span> <span class="s1">&#39;gm_facdBe&#39;</span><span class="p">:</span><span class="s1">&#39;dBeFac&#39;</span><span class="p">,</span><span class="s1">&#39;gm_facdBd&#39;</span><span class="p">:</span><span class="s1">&#39;dBdFac&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ie_JhdBn&#39;</span><span class="p">:</span><span class="s1">&#39;dBnHal&#39;</span><span class="p">,</span>  <span class="s1">&#39;ie_JhdBe&#39;</span><span class="p">:</span><span class="s1">&#39;dBeHal&#39;</span><span class="p">,</span> <span class="s1">&#39;ie_JhdBd&#39;</span><span class="p">:</span><span class="s1">&#39;dBdHal&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ie_JpBn&#39;</span><span class="p">:</span><span class="s1">&#39;dBnPed&#39;</span><span class="p">,</span>   <span class="s1">&#39;ie_JpBe&#39;</span><span class="p">:</span><span class="s1">&#39;dBePed&#39;</span><span class="p">,</span>  <span class="s1">&#39;ie_JpBd&#39;</span><span class="p">:</span><span class="s1">&#39;dBdPed&#39;</span><span class="p">}</span>

        <span class="c1"># Replace variable names.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">varmap</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span> <span class="n">varmap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            
    <span class="k">def</span> <span class="nf">calc_h</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the total horizontal perturbation, &#39;H&#39;, using the pythagorean</span>
<span class="sd">        sum of the two horizontal components (north-south and east-west</span>
<span class="sd">        components):</span>

<span class="sd">        $\Delta B_H = \sqrt{\Delta B_N^2 + \Delta B_E^2}$</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">allvars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">allvars</span><span class="p">:</span>
            <span class="c1"># Find all dB-north variables:</span>
            <span class="k">if</span> <span class="n">v</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;dBn&#39;</span><span class="p">:</span>
                <span class="n">v_east</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;dBn&#39;</span><span class="p">,</span> <span class="s1">&#39;dBe&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;dBn&#39;</span><span class="p">,</span> <span class="s1">&#39;dBh&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="n">v_east</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nT&#39;</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">calc_dbdt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the time derivative of all dB-like variables and save as </span>
<span class="sd">        &#39;dBdt[direction][component].  For example, the time derivative of </span>
<span class="sd">        dBeMhd will be saved as dBdteMhd.</span>

<span class="sd">        |dB/dt|_h is also calculated following the convention of </span>
<span class="sd">        Pulkkinen et al, 2013:</span>
<span class="sd">        $|dB/dt|_H = \sqrt{(\dB_N/dt)^2 + (dB_E/dt)^2}$</span>

<span class="sd">        A 2nd-order accurate centeral difference method is used to</span>
<span class="sd">        calculate the time derivative.  For the first and last points, </span>
<span class="sd">        2nd-order accurate forward and backward differences are taken, </span>
<span class="sd">        respectively.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Do not calculate twice.</span>
        <span class="k">if</span> <span class="s1">&#39;dBdtn&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="k">return</span>
        
        <span class="c1"># Get dt values:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])])</span>

        <span class="c1"># Loop through variables:</span>
        <span class="n">oldvars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">oldvars</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;dB&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span> <span class="k">continue</span>

            <span class="c1"># Create new variable name and container:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;dB&#39;</span><span class="p">,</span><span class="s1">&#39;dBdt&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">new</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;nlines&#39;</span><span class="p">]),{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nT/s&#39;</span><span class="p">})</span>

            <span class="c1"># Central diff:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">new</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">dt</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Forward diff:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">new</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> \
                           <span class="o">/</span> <span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Backward diff:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">new</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> \
                            <span class="o">/</span> <span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>


        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;dBdth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;dBdtn&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;dBdte&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
    <span class="k">def</span> <span class="nf">add_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plot **value**, which should be a key corresponding to a data vector</span>
<span class="sd">        stored in the :class:`~spacepy.pybats.bats.Mag` object,</span>
<span class="sd">        against the object&#39;s *time*.  The **target** kwarg specifies the</span>
<span class="sd">        destination of the plot.  If not set, **target** defaults to None and</span>
<span class="sd">        a new figure and axis will be created.  If target is a matplotlib</span>
<span class="sd">        figure, a new axis is created at subplot location 111 (which can be </span>
<span class="sd">        changed</span>
<span class="sd">        using kwarg **loc**).  If target is a matplotlib Axes object, the line</span>
<span class="sd">        is added to the plot as if ``Axes.plot()`` was used.  The line label,</span>
<span class="sd">        which is used for setting labels on figure legends,</span>
<span class="sd">        defaults to the value key but can be customized with the &quot;label&quot;</span>
<span class="sd">        kwarg.  The **style** keyword accepts basic Matplotlib line style</span>
<span class="sd">        strings such as &#39;--r&#39; or &#39;+g&#39;.  This string will be passed on to the</span>
<span class="sd">        plot command to customize the line.</span>

<span class="sd">        All extra kwargs are handed to ``Axes.plot``, allowing the user to set</span>
<span class="sd">        any additional options (e.g., line color and style, etc.).</span>

<span class="sd">        Three values are returned: the Figure object, Axis object, and </span>
<span class="sd">        newly created line object.  These can be used to further customize</span>
<span class="sd">        the figure, axis, and line as necessary.</span>

<span class="sd">        Example: Plot total :math:`\Delta B_N` onto an existing axis with line </span>
<span class="sd">        color blue, line style dashed, and line label &quot;Wow!&quot;:</span>

<span class="sd">        &gt;&gt;&gt; self.plot(&#39;dBn&#39;, target=&#39;ax&#39;, label=&#39;Wow!&#39;, lc=&#39;b&#39;, ls=&#39;--&#39;)</span>

<span class="sd">        Example: Plot total :math:`\Delta B_N` on a new figure, save returned</span>
<span class="sd">        values and overplot additional values on the returned axis.  Default </span>
<span class="sd">        labels and line styles are used in this example.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; fig, ax, line = self.plot(&#39;n&#39;)</span>
<span class="sd">        &gt;&gt;&gt; self.plot(&#39;dBe&#39;, target = ax)</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="p">:</span>
            <span class="n">label</span><span class="o">=</span><span class="n">value</span>

        <span class="c1"># Set figure and axes based on target:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

        <span class="n">line</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">],</span> <span class="n">style</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">applySmartTimeTicks</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">dolabel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">add_comp_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direc</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add_legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a plot with,  or add to an existing plot, an illustration of </span>
<span class="sd">        how the</span>
<span class="sd">        separate components sum together to make the total disturbance in a</span>
<span class="sd">        given orthongal direction (arg **direc**).  The three possible </span>
<span class="sd">        components are &#39;n&#39; (northwards, towards the magnetic pole), &#39;e&#39;</span>
<span class="sd">        (eastwards), or &#39;d&#39; (downwards towards the center of the Earth.)  The</span>
<span class="sd">        components of the total disturbance in any on direction are </span>
<span class="sd">        magnetospheric currents (&#39;gm_dB&#39;), gap-region field-aligned currents</span>
<span class="sd">        (&#39;gm_facdB&#39;), and ionospheric Hall and Pederson currents (&#39;ie_Jp&#39; and</span>
<span class="sd">        &#39;ie_Jh&#39;).  </span>

<span class="sd">        Example usage:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; self.add_comp_plot(&#39;n&#39;)</span>

<span class="sd">        This will create a new plot with the total disturbance in the &#39;n&#39; </span>
<span class="sd">        direction along with line plots of each component that builds this</span>
<span class="sd">        total.  This method uses the familiar PyBats **target** kwarg system</span>
<span class="sd">        to allow users to add these plots to existing figures or axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        direc : string</span>
<span class="sd">           Indicate the direction to plot: either &#39;n&#39;, &#39;e&#39;, &#39;d&#39;, or </span>
<span class="sd">           &#39;h&#39; if calculated.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        target : Matplotlib Figure or Axes object</span>
<span class="sd">           Set plot destination.  Defaults to new figure.</span>
<span class="sd">        loc : 3-digit integer</span>
<span class="sd">           Set subplot location.  Defaults to 111.</span>
<span class="sd">        add_legend : bool</span>
<span class="sd">           Add legend to plot.  Defaults to True.</span>
<span class="sd">        lw : float</span>
<span class="sd">           Set the width of the lines.  Defaults to 2.0  Total field</span>
<span class="sd">           is always 1.5 times thicker.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="c1"># Set plot targets.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

        <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;dB&#39;</span><span class="o">+</span><span class="n">direc</span>

        <span class="c1"># Use a dictionary to assign line styles, widths.</span>
        <span class="n">styles</span><span class="o">=</span><span class="p">{</span><span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Mhd&#39;</span><span class="p">:</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Fac&#39;</span><span class="p">:</span><span class="s1">&#39;--&#39;</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Hal&#39;</span><span class="p">:</span><span class="s1">&#39;-.&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Ped&#39;</span><span class="p">:</span><span class="s1">&#39;-.&#39;</span><span class="p">,</span>
                <span class="n">prefix</span><span class="p">:</span><span class="s1">&#39;-&#39;</span><span class="p">}</span>
        <span class="n">widths</span><span class="o">=</span><span class="p">{</span><span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Mhd&#39;</span><span class="p">:</span><span class="n">lw</span><span class="p">,</span> <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Fac&#39;</span><span class="p">:</span><span class="n">lw</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Hal&#39;</span><span class="p">:</span><span class="n">lw</span><span class="p">,</span> <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Ped&#39;</span><span class="p">:</span><span class="n">lw</span><span class="p">,</span>
                <span class="n">prefix</span><span class="p">:</span><span class="mf">1.5</span><span class="o">*</span><span class="n">lw</span><span class="p">}</span>
        <span class="n">colors</span><span class="o">=</span><span class="p">{</span><span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Mhd&#39;</span><span class="p">:</span><span class="s1">&#39;#FF6600&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Fac&#39;</span><span class="p">:</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Hal&#39;</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>       <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Ped&#39;</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">,</span>
                <span class="n">prefix</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
        
        <span class="c1"># Labels:</span>
        <span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Mhd&#39;</span><span class="p">:</span><span class="sa">r</span><span class="s1">&#39;$J_</span><span class="si">{Mag}</span><span class="s1">$&#39;</span><span class="p">,</span>  <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Fac&#39;</span><span class="p">:</span><span class="sa">r</span><span class="s1">&#39;$J_</span><span class="si">{Gap}</span><span class="s1">$&#39;</span><span class="p">,</span> 
                <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Hal&#39;</span><span class="p">:</span><span class="sa">r</span><span class="s1">&#39;$J_</span><span class="si">{Hall}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">+</span><span class="s1">&#39;Ped&#39;</span><span class="p">:</span><span class="sa">r</span><span class="s1">&#39;$J_</span><span class="si">{Peder}</span><span class="s1">$&#39;</span><span class="p">,</span>
                <span class="n">prefix</span><span class="p">:</span><span class="sa">r</span><span class="s1">&#39;Total $\Delta B&#39;</span><span class="o">+</span><span class="s1">&#39;_</span><span class="si">{}</span><span class="s1">$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">direc</span><span class="p">)}</span>

        <span class="c1"># Plot.</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;dB&#39;</span><span class="o">+</span><span class="n">direc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;dBdt&#39;</span><span class="p">):</span><span class="k">continue</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                    <span class="n">lw</span><span class="o">=</span><span class="n">widths</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="c1">#,ls=styles[k]</span>

        <span class="c1"># Ticks, zero-line, and legend:</span>
        <span class="n">applySmartTimeTicks</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                  <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_legend</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">ncol</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
    
        <span class="c1"># Axis labels:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\Delta B_{</span><span class="si">%s</span><span class="s1">}$ ($nT$)&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">direc</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">target</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="MagFile"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.MagFile.html#spacepy.pybats.bats.MagFile">[docs]</a><span class="k">class</span> <span class="nc">MagFile</span><span class="p">(</span><span class="n">PbData</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    BATS-R-US magnetometer files are powerful tools for both research and</span>
<span class="sd">    operations.  :class:`~spacepy.pybats.bats.MagFile` objects open, parse, </span>
<span class="sd">    and visualize such output.</span>

<span class="sd">    The $\delta B$ calculated by the SWMF requires two components: GM (BATSRUS)</span>
<span class="sd">    and IE (Ridley_serial).  The data is spread across two files: GM_mag*.dat</span>
<span class="sd">    and IE_mag*.dat.  The former contains $\delta B$ caused by gap-region </span>
<span class="sd">    (i.e., inside the inner boundary) FACs and the changing global field.  </span>
<span class="sd">    The latter contains the $\delta B$ caused by Pederson and Hall </span>
<span class="sd">    currents in the ionosphere.  :class:`~spacepy.pybats.bats.MagFile` objects</span>
<span class="sd">    can open one or both of these files at a time; when both are opened, the</span>
<span class="sd">    total $\delta B$ is calculated and made available to the user.</span>

<span class="sd">    Usage: </span>

<span class="sd">    &gt;&gt;&gt; # Open up the GM magnetometer file only.</span>
<span class="sd">    &gt;&gt;&gt; obj = spacepy.pybats.bats.MagFile(&#39;GM_file.mag&#39;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Open up both the GM and IE file [LEGACY SWMF ONLY]</span>
<span class="sd">    &gt;&gt;&gt; obj = spacepy.pybats.bats.MagFile(&#39;GM_file.mag&#39;, &#39;IE_file.mag&#39;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Open up the GM magnetometer file; search for the IE file.</span>
<span class="sd">    &gt;&gt;&gt; obj = spacepy.pybats.bats.MagFile(&#39;GM_file.mag&#39;, find_ie=True)</span>

<span class="sd">    Note that the **find_ie** kwarg uses a simple search assuming the data </span>
<span class="sd">    remain in a typical SWMF-output organizational tree (i.e., if the results</span>
<span class="sd">    of a simulation are in folder *results*, the GM magnetometer file can be </span>
<span class="sd">    found in *results/GM/* or *results/GM/IO2/* while the IE file can be found</span>
<span class="sd">    in *results/IE/* or *results/IE/ionosphere/*).  It will also search the</span>
<span class="sd">    present working directory.  This method is not robust; the user must take</span>
<span class="sd">    care to ensure that the two files correspond to each other.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ie_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">find_ie</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">MagFile</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># Init as PbData.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;gmfile&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">filename</span>

        <span class="c1"># Try to find the IE file based on our current location.</span>
        <span class="k">if</span><span class="p">(</span><span class="n">find_ie</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ie_name</span><span class="p">):</span>
            <span class="n">basedir</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">filename</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">glob</span><span class="p">(</span><span class="n">basedir</span> <span class="o">+</span> <span class="s1">&#39;../IE/IE_mag_*.mag&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iefile&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">glob</span><span class="p">(</span><span class="n">basedir</span> <span class="o">+</span> <span class="s1">&#39;../IE/IE_mag_*.mag&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">glob</span><span class="p">(</span><span class="n">basedir</span> <span class="o">+</span> <span class="s1">&#39;../../IE/ionosphere/IE_mag_*.mag&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iefile&#39;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">glob</span><span class="p">(</span><span class="n">basedir</span> <span class="o">+</span> <span class="s1">&#39;../../IE/ionosphere/IE_mag_*.mag&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">glob</span><span class="p">(</span><span class="n">basedir</span> <span class="o">+</span> <span class="s1">&#39;/IE_mag_*.mag&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iefile&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">basedir</span> <span class="o">+</span> <span class="s1">&#39;/IE_mag_*.mag&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iefile&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iefile&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ie_name</span>

        <span class="c1"># Set legacy mode to handle old variable names:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legacy</span> <span class="o">=</span> <span class="n">find_ie</span> <span class="ow">or</span> <span class="nb">bool</span><span class="p">(</span><span class="n">ie_name</span><span class="p">)</span>
            
            
        <span class="bp">self</span><span class="o">.</span><span class="n">readfiles</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">readfiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Read and parse GM file and IE file (if name given.)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span>

        <span class="c1"># Slurp lines.</span>
        <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;gmfile&#39;</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">=</span><span class="n">infile</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">infile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Parse header.</span>

        <span class="c1"># Get number of stations.</span>
        <span class="n">nmags</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Get station names.</span>
        <span class="n">names</span><span class="o">=</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">namemag</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;namemag&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">namemag</span>

        <span class="c1"># Check nmags vs number of mags in header.</span>
        <span class="k">if</span> <span class="n">nmags</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">namemag</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">BaseException</span><span class="p">(</span>
                <span class="s1">&#39;ERROR: GM file claims </span><span class="si">%i</span><span class="s1"> magnetomers, lists </span><span class="si">%i</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">nmags</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">namemag</span><span class="p">)))</span>

        <span class="c1"># Grab variable names.  Use legacy mode if necessary:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;gm_&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">legacy</span>
        <span class="c1"># skip time, iter, and loc; add prefix to var names:</span>
        <span class="n">gm_namevar</span> <span class="o">=</span> <span class="p">[</span><span class="n">prefix</span><span class="o">+</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">12</span><span class="p">:]]</span>

        <span class="c1"># Set number of mags and records.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;nmag&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">namemag</span><span class="p">)</span>
        <span class="n">nrecords</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">//</span><span class="n">nmags</span>

        <span class="c1"># If there is an IE file, Parse that header, too.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iefile&#39;</span><span class="p">]:</span>
            <span class="n">infile</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iefile&#39;</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">ielns</span> <span class="o">=</span><span class="n">infile</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="n">infile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">nmags</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">ielns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">iestats</span><span class="o">=</span><span class="p">(</span><span class="n">ielns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="c1"># Check nmags vs number of mags in header.</span>
            <span class="k">if</span> <span class="n">nmags</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iestats</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">BaseException</span><span class="p">(</span>
                    <span class="s1">&#39;ERROR: IE file claims </span><span class="si">%i</span><span class="s1"> magnetomers, lists </span><span class="si">%i</span><span class="s1">&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">nmags</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">namemag</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">iestats</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;namemag&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Files do not have matching stations.&quot;</span><span class="p">)</span>
            <span class="n">ie_namevar</span><span class="o">=</span><span class="n">ielns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">11</span><span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;ie_namevar&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ie_namevar</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ielns</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;nmag&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nrecords</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of lines do not match: GM=</span><span class="si">%d</span><span class="s1">, IE=</span><span class="si">%d</span><span class="s1">!&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">nrecords</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ielns</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;nmag&#39;</span><span class="p">]))</span>
                <span class="n">nrecords</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">ielns</span><span class="p">,</span> <span class="n">nrecords</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ie_namevar</span><span class="o">=</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;ie_namevar&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">()</span>

        <span class="c1"># Build containers.</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrecords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;iter&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrecords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">namemag</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">Mag</span><span class="p">(</span><span class="n">nrecords</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">gm_namevar</span><span class="p">,</span> <span class="n">ie_namevar</span><span class="p">)</span>

        <span class="n">data_buffer</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrecords</span><span class="p">,</span><span class="n">nmags</span><span class="p">,(</span><span class="nb">len</span><span class="p">(</span><span class="n">gm_namevar</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">)))</span>

        <span class="c1"># Read file data.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrecords</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">nmags</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">parts</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;iter&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="c1">#year</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="c1">#month</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="c1">#day</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="c1">#hour</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span> <span class="c1">#minute</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">6</span><span class="p">]),</span> <span class="c1">#second</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span><span class="o">*</span><span class="mi">1000</span> <span class="c1">#microsec</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmags</span><span class="p">):</span>
                <span class="n">line</span><span class="o">=</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">nmags</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">9</span><span class="p">:]]</span>
                <span class="n">data_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">values</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iefile&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">line</span><span class="o">=</span><span class="n">ielns</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">nmags</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">namemag</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">parse_ieline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">ie_namevar</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmags</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">namemag</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">parse_ieline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ielns</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">nmags</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span>
                                                  <span class="n">ie_namevar</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmags</span><span class="p">):</span>
            <span class="n">mag</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">namemag</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">data_buffer</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">data_buffer</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">data_buffer</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gm_namevar</span><span class="p">):</span>
                <span class="n">mag</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">data_buffer</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># Sum up IE/GM components if necessary (legacy only):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">legacy</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recalc</span><span class="p">()</span>
        
        <span class="c1"># Get time res.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">seconds</span><span class="o">/</span><span class="mf">60.0</span>
        
    <span class="k">def</span> <span class="nf">_recalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Old magnetometer files had different variable names and did not</span>
<span class="sd">        contain the total perturbation.  This function updates variable names</span>
<span class="sd">        and sums all contributions from all models/regions to get total </span>
<span class="sd">        :math:`\Delta B`.</span>

<span class="sd">        This function is only required for legacy results.  New versions of</span>
<span class="sd">        the SWMF include both GM, IE, and total perturbations in a single</span>
<span class="sd">        file.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">mag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;namemag&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">mag</span><span class="p">]</span><span class="o">.</span><span class="n">_recalc</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">calc_h</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For each magnetometer object, calculate the horizontal component of</span>
<span class="sd">        the perturbations using the pythagorean sum of the two horizontal </span>
<span class="sd">        components (north-south and east-west components):</span>

<span class="sd">        $\Delta B_H = \sqrt{\Delta B_N^2 + \Delta B_E^2}$</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="s1">&#39;time&#39;</span> <span class="ow">or</span> <span class="n">k</span><span class="o">==</span><span class="s1">&#39;iter&#39;</span><span class="p">:</span> <span class="k">continue</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">calc_h</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">calc_dbdt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For each magnetometer object, calculate the horizontal component of</span>
<span class="sd">        the perturbations.</span>

<span class="sd">        |dB/dt|_h is also calculated following the convention of </span>
<span class="sd">        Pulkkinen et al, 2013:</span>
<span class="sd">        $|dB/dt|_H = \sqrt{(\dB_N/dt)^2 + (dB_E/dt)^2}$</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="s1">&#39;time&#39;</span> <span class="ow">or</span> <span class="n">k</span><span class="o">==</span><span class="s1">&#39;iter&#39;</span><span class="p">:</span> <span class="k">continue</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">calc_dbdt</span><span class="p">()</span></div>
            
<span class="k">class</span> <span class="nc">MagGridFile</span><span class="p">(</span><span class="n">IdlFile</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Magnetometer grids are a recent addition to BATS-R-US: instead of </span>
<span class="sd">    specifying a small set of individual stations, the user can specify a </span>
<span class="sd">    grid of many stations spanning a latitude/longitude range.  The files</span>
<span class="sd">    are output in the usual :class:`spacepy.pybats.IdlFile` format.  This </span>
<span class="sd">    class handles the reading, manipulating, and visualization of these files.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">re</span>
        <span class="kn">from</span> <span class="nn">spacepy.pybats</span> <span class="kn">import</span> <span class="n">parse_filename_time</span>
        <span class="kn">from</span> <span class="nn">spacepy.coordinates</span> <span class="kn">import</span> <span class="n">Coords</span>
        
        <span class="c1"># Initialize as an IdlFile.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MagGridFile</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Additional header parsing:</span>
        <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">]</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;\((\w+)\).*\[(\w+)\].*\[(\w+)\]&#39;</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
        <span class="n">coord</span><span class="p">,</span> <span class="n">unit1</span><span class="p">,</span> <span class="n">unit2</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;coord&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">coord</span>

        <span class="c1"># Extract time from file name:</span>
        <span class="n">i_iter</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">parse_filename_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="k">if</span> <span class="s1">&#39;iter&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;iter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_iter</span>

        <span class="c1"># Set units based on header parsing:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dims&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">unit1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">unit2</span>

        <span class="c1"># Get cooridnates in both SM and GEO.</span>
        <span class="c1">#if coord == &#39;GEO&#39;:</span>
        <span class="c1">#    self[&#39;Lat_geo&#39;]=self[&#39;Lat&#39;]</span>
        <span class="c1">#    self[&#39;Lon_geo&#39;]=self[&#39;Lon&#39;]</span>
                
    <span class="k">def</span> <span class="nf">calc_h</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the total horizontal perturbation, &#39;h&#39;, using the pythagorean</span>
<span class="sd">        sum of the two horizontal components (east and west components).</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">allvars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">allvars</span><span class="p">:</span>
            <span class="c1"># Find all dB-north variables:</span>
            <span class="k">if</span> <span class="n">v</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;dBn&#39;</span><span class="p">:</span>
                <span class="n">v_east</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;dBn&#39;</span><span class="p">,</span> <span class="s1">&#39;dBe&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;dBn&#39;</span><span class="p">,</span> <span class="s1">&#39;dBh&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="n">v_east</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;nT&#39;</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">add_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">nlev</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> 
                    <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add_cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">filled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dolog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add_conts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add a lat-lon contour plot of variable *value*.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">spacepy.pybats</span> <span class="kn">import</span> <span class="n">mhdname_to_tex</span>
        
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="p">(</span><span class="n">LogNorm</span><span class="p">,</span> <span class="n">Normalize</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="p">(</span><span class="n">LogLocator</span><span class="p">,</span> <span class="n">LogFormatter</span><span class="p">,</span> <span class="n">FuncFormatter</span><span class="p">,</span>
                                       <span class="n">LogFormatterMathtext</span><span class="p">,</span> <span class="n">MultipleLocator</span><span class="p">)</span>

        <span class="c1"># Set ax and fig based on given target.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

        <span class="c1"># Get max/min if none given.</span>
        <span class="k">if</span> <span class="n">zlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zlim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
            <span class="k">if</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">zlim</span><span class="p">):</span>
                <span class="n">maxval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">zlim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">maxval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">]</span>

        <span class="c1"># No zero-level for log scales:</span>
        <span class="k">if</span> <span class="n">dolog</span> <span class="ow">and</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">1000.0</span><span class="p">]</span> <span class="p">)</span>

        <span class="c1"># Better default color maps:</span>
        <span class="k">if</span> <span class="s1">&#39;cmap&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># If zlim spans positive and negative:</span>
            <span class="k">if</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">zlim</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cmap&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;bwr&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cmap&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;Reds&#39;</span>

        <span class="c1"># Set contour command based on filled/unfilled contours:</span>
        <span class="k">if</span> <span class="n">filled</span><span class="p">:</span>
            <span class="n">contour</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">contourf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">contour</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">contour</span>

                <span class="c1"># Create levels and set norm based on dolog.</span>
        <span class="k">if</span> <span class="n">dolog</span><span class="p">:</span>
            <span class="n">levs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                                            <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">nlev</span><span class="p">))</span>
            <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">&gt;</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">],</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">LogNorm</span><span class="p">()</span>
            <span class="n">ticks</span><span class="o">=</span><span class="n">LogLocator</span><span class="p">()</span>
            <span class="n">fmt</span><span class="o">=</span><span class="n">LogFormatterMathtext</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">levs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nlev</span><span class="p">)</span>
            <span class="n">z</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span>
            <span class="n">ticks</span><span class="o">=</span><span class="n">MultipleLocator</span><span class="p">((</span><span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span> <span class="c1">### fix this</span>
            <span class="n">fmt</span><span class="o">=</span><span class="kc">None</span>
                
        <span class="c1"># Add Contour to plot:</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="n">contour</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Lon&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Lat&#39;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span>
                       <span class="n">levs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Add cbar if necessary.</span>
        <span class="k">if</span> <span class="n">add_cbar</span><span class="p">:</span>
            <span class="n">cbar</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">ticks</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clabel</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="n">mhdname_to_tex</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">units</span>   <span class="o">=</span> <span class="n">mhdname_to_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">])</span>
                <span class="n">clabel</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">varname</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">clabel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cbar</span><span class="o">=</span><span class="kc">None</span> <span class="c1"># Need to return something, even if none.</span>
 
        <span class="c1"># Set title, labels, axis ranges (use defaults where applicable.)</span>
        <span class="k">if</span> <span class="n">title</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">coord_sys</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;coord&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ylabel</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Latitude (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord_sys</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xlabel</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;Longitude (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord_sys</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">);</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>

        <span class="c1"># If a brand-new axes was created, use custom ticks:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">):</span>
            <span class="n">fmttr</span> <span class="o">=</span> <span class="n">FuncFormatter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span>
                                  <span class="s1">&#39;</span><span class="si">{:4.1f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;$^{\circ}$&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">fmttr</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">fmttr</span><span class="p">)</span>
            
        <span class="c1"># If a brand-new figure was created, use tight-layout.</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">cont</span><span class="p">,</span> <span class="n">cbar</span>

    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Interpolate variable *var* to point(s) *lats*, *lons*.  *lats* and</span>
<span class="sd">        *lons* can either be scalar or a numpy-like array.  Values interpolated</span>
<span class="sd">        to these positions is returned to the caller either as a scalar or</span>
<span class="sd">        array.</span>

<span class="sd">        Simple bilinear interpolation is used.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">spacepy.pybats.batsmath</span> <span class="kn">import</span> <span class="n">interp_2d_reg</span> <span class="k">as</span> <span class="n">intp</span>

        <span class="k">return</span> <span class="n">intp</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Lat&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Lon&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>
    
    
<div class="viewcode-block" id="GeoIndexFile"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.GeoIndexFile.html#spacepy.pybats.bats.GeoIndexFile">[docs]</a><span class="k">class</span> <span class="nc">GeoIndexFile</span><span class="p">(</span><span class="n">LogFile</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Geomagnetic Index files are a specialized BATS-R-US output that contain</span>
<span class="sd">    geomagnetic indices calculated from simulated ground-based magnetometers.</span>
<span class="sd">    Currently, the only index instituted is Kp through the faKe_p setup.  </span>
<span class="sd">    Future work will expand the system to include Dst, AE, etc.</span>

<span class="sd">    GeoIndFiles are a specialized subclass of pybats.LogFile.  It includes</span>
<span class="sd">    additional methods to quickly visualize the output, perform data-model</span>
<span class="sd">    comparisons, and more.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;GeoIndexFile object at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">keep_case</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Load ascii file located at self.attrs[&#39;file&#39;].  </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Call super __init__:</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GeoIndexFile</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Re-parse the file header; look for key info.</span>
        <span class="n">head</span>  <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;descrip&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;DtOutput=&#39;</span> <span class="ow">in</span> <span class="n">head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">parts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;DtOutput=&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;SizeKpWindow&#39;</span> <span class="ow">in</span> <span class="n">head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;window&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">parts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                        <span class="s1">&#39;SizeKpWindow(Mins)&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;Lat&#39;</span> <span class="ow">in</span> <span class="n">head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">parts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;Lat&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;K9&#39;</span> <span class="ow">in</span> <span class="n">head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;k9&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">parts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;K9&#39;</span><span class="p">)</span> <span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                                         

    <span class="k">def</span> <span class="nf">fetch_obs_kp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fetch the observed Kp index for the time period covered in the </span>
<span class="sd">        logfile.  Return *True* on success.</span>

<span class="sd">        Observed Kp is automatically fetched from the Kyoto World Data Center</span>
<span class="sd">        via the :mod:`spacepy.pybats.kyoto` module.  The associated </span>
<span class="sd">        :class:`spacepy.pybats.kyoto.KyotoKp` object, which holds the observed</span>
<span class="sd">        kp, is stored as *self.obs_kp* for future use.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">spacepy.pybats.kyoto</span> <span class="k">as</span> <span class="nn">kt</span>

        <span class="c1"># Return if already obtained:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;obs_kp&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Start and end time to collect observations:</span>
        <span class="n">stime</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="n">etime</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Attempt to fetch from Kyoto website:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs_kp</span> <span class="o">=</span> <span class="n">kt</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s1">&#39;kp&#39;</span><span class="p">,</span> <span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">)</span>
        <span class="c1"># Warn on failure:</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s1">&#39;Failed to fetch Kyoto Kp: &#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">fetch_obs_ae</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fetch the observed AE index for the time period covered in the </span>
<span class="sd">        logfile.  Return *True* on success.</span>

<span class="sd">        Observed AE is automatically fetched from the Kyoto World Data Center</span>
<span class="sd">        via the :mod:`spacepy.pybats.kyoto` module.  The associated </span>
<span class="sd">        :class:`spacepy.pybats.kyoto.KyotoAe` object, which holds the observed</span>
<span class="sd">        AE, is stored as *self.obs_ae* for future use.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">spacepy.pybats.kyoto</span> <span class="k">as</span> <span class="nn">kt</span>

        <span class="c1"># Return if already obtained:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;obs_ae&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Start and end time to collect observations:</span>
        <span class="n">stime</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="n">etime</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Attempt to fetch from Kyoto website:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs_ae</span> <span class="o">=</span> <span class="n">kt</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s1">&#39;ae&#39;</span><span class="p">,</span> <span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">)</span>
        <span class="c1"># Warn on failure:</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s1">&#39;Failed to fetch Kyoto AE: &#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>   

    <span class="k">def</span> <span class="nf">add_kp_quicklook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                         <span class="n">plot_obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">add_legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                         <span class="n">obs_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;ls&#39;</span><span class="p">:</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39;lw&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Similar to &quot;dst_quicklook&quot;-type functions, this method fetches observed</span>
<span class="sd">        Kp from the web and plots it alongside the Kp read from the GeoInd file.</span>
<span class="sd">        Usage:</span>
<span class="sd">        &gt;&gt;&gt; obj.kp_quicklook(target=SomeMplTarget)</span>
<span class="sd">        The target kwarg works like in other PyBats plot functions: it can be</span>
<span class="sd">        a figure, an axes, or None, and it determines where the plot is placed.</span>

<span class="sd">        Other kwargs customize the line.  Label defaults to fa$K$e$_{P}$, extra</span>
<span class="sd">        kwargs are passed to pyplot.plot.</span>

<span class="sd">        Observed Kp can be added via the *plot_obs* kwarg.  Kp is automatically </span>
<span class="sd">        fetched from the Kyoto World Data Center via the </span>
<span class="sd">        :mod:`spacepy.pybats.kyoto` module.  The associated </span>
<span class="sd">        :class:`spacepy.pybats.kyoto.KyotoKp` object, which holds the observed</span>
<span class="sd">        Kp, is stored as *self.obs_kp* for future use.</span>
<span class="sd">        The observed line can be customized via the *obs_kwargs* kwarg, which</span>
<span class="sd">        is a dictionary of plotting keyword arguments.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="c1"># Set up plot target.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>
        
        <span class="c1"># Create label:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;fa$K$e$_</span><span class="si">{P}</span><span class="s1">$&#39;</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;lat&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;k9&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">+=</span> <span class="s1">&#39; (Lat=</span><span class="si">%04.1f</span><span class="s1">$^{\circ}$, K9=</span><span class="si">%03i</span><span class="s1">)&#39;</span> <span class="o">%</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;k9&#39;</span><span class="p">])</span>

        <span class="c1"># Sometimes, the &quot;Kp&quot; varname is caps, sometimes not.</span>
        <span class="n">kp</span> <span class="o">=</span> <span class="s1">&#39;Kp&#39;</span>
        <span class="k">if</span> <span class="n">kp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="n">kp</span><span class="o">=</span><span class="s1">&#39;kp&#39;</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Kp&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$K_</span><span class="si">{P}</span><span class="s1">$&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time from &#39;</span><span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39; UTC&#39;</span><span class="p">)</span>
        <span class="n">applySmartTimeTicks</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">target</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">plot_obs</span><span class="p">:</span>
            <span class="c1"># Attempt to fetch Kp:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_obs_kp</span><span class="p">():</span>
                <span class="c1"># If successful, add to plot:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obs_kp</span><span class="o">.</span><span class="n">add_histplot</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">obs_kwargs</span><span class="p">)</span>
                <span class="n">applySmartTimeTicks</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">add_legend</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>       
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">add_ae_quicklook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                         <span class="n">plot_obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="s1">&#39;AE&#39;</span><span class="p">,</span> <span class="n">add_legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                         <span class="n">obs_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;ls&#39;</span><span class="p">:</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39;lw&#39;</span><span class="p">:</span><span class="mf">1.5</span><span class="p">},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Similar to &quot;dst_quicklook&quot;-type functions, this method fetches observed</span>
<span class="sd">        AE indices from the web and plots it alongside the corresponding </span>
<span class="sd">        AE read from the GeoInd file.  Because there are four AE-like indices</span>
<span class="sd">        (AL, AU, AE, and AO), the kwarg *val* specifies which to plot</span>
<span class="sd">        (default is AE).</span>

<span class="sd">        Usage:</span>
<span class="sd">        &gt;&gt;&gt; obj.ae_quicklook(target=SomeMplTarget)</span>
<span class="sd">        The target kwarg works like in other PyBats plot functions: it can be</span>
<span class="sd">        a figure, an axes, or None, and it determines where the plot is placed.</span>

<span class="sd">        Other kwargs customize the line.  Extra kwargs are passed to pyplot.plot</span>

<span class="sd">        Observed AE can be added via the *plot_obs* kwarg.  AE is automatically </span>
<span class="sd">        fetched from the Kyoto World Data Center via the </span>
<span class="sd">        :mod:`spacepy.pybats.kyoto` module.  The associated </span>
<span class="sd">        :class:`spacepy.pybats.kyoto.KyotoAe` object, which holds the observed</span>
<span class="sd">        AE, is stored as *self.obs_kp* for future use.</span>
<span class="sd">        The observed line can be customized via the *obs_kwargs* kwarg, which</span>
<span class="sd">        is a dictionary of plotting keyword arguments.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="c1"># Set up plot target.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Virtual </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="n">val</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> ($nT$)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time from &#39;</span><span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39; UTC&#39;</span><span class="p">)</span>
        <span class="n">applySmartTimeTicks</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">target</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">plot_obs</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_obs_ae</span><span class="p">():</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs_ae</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_ae</span><span class="p">[</span><span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()],</span>
                        <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Obs.&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">obs_kwargs</span><span class="p">)</span>
                <span class="n">applySmartTimeTicks</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">add_legend</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>

                
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="VirtSat"><a class="viewcode-back" href="../../../autosummary/spacepy.pybats.bats.VirtSat.html#spacepy.pybats.bats.VirtSat">[docs]</a><span class="k">class</span> <span class="nc">VirtSat</span><span class="p">(</span><span class="n">LogFile</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A :class:`spacepy.pybats.LogFile` object tailored to virtual satellite</span>
<span class="sd">    output; includes special satellite-specific plotting methods.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="kn">from</span> <span class="nn">re</span> <span class="kn">import</span> <span class="n">findall</span>
        <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
        <span class="kn">from</span> <span class="nn">matplotlib.dates</span> <span class="kn">import</span> <span class="n">date2num</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">VirtSat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keep_case</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Attempt to extract the satellite&#39;s name and save it.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">findall</span><span class="p">(</span><span class="s1">&#39;sat_([\-\w]+)_\d+_n\d+\.sat|sat_(\w+)_n\d+\.sat&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">name</span>

        <span class="c1"># Create interpolation functions for position.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">tnum</span><span class="o">=</span><span class="n">date2num</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">tnum</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Satellite object </span><span class="si">{}</span><span class="s1"> at </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">calc_ndens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate number densities for each fluid.  Species mass is ascertained </span>
<span class="sd">        via recognition of fluid name (e.g. OpRho is clearly oxygen).  A full</span>
<span class="sd">        list of recognized fluids/species can be found by exploring the </span>
<span class="sd">        dictionary *mass* found in :mod:`~spacepy.pybats.bats`.  Composition is</span>
<span class="sd">        also calculated as percent of total number density.</span>

<span class="sd">        New values are saved using the keys *speciesN* (e.g. *opN*) and</span>
<span class="sd">        *speciesFrac* (e.g. *opFrac*).</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">_calc_ndens</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">calc_temp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate plasma temperature for each fluid.  Number density is</span>
<span class="sd">        calculated using *calc_ndens* if it hasn&#39;t been done so already.</span>
<span class="sd">        </span>
<span class="sd">        Temperature is obtained via density and pressure through the simple</span>
<span class="sd">        relationship P=nkT.</span>

<span class="sd">        Use the units kwarg to set output units.  Current choices are</span>
<span class="sd">        KeV, eV, and K.  Default is eV.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">spacepy.datamodel</span> <span class="kn">import</span> <span class="n">dmarray</span>

        <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># Create dictionary of unit conversions.</span>
        <span class="n">conv</span>  <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ev&#39;</span> <span class="p">:</span> <span class="mf">6241.50935</span><span class="p">,</span>  <span class="c1"># nPa/cm^3 --&gt; eV.</span>
                 <span class="s1">&#39;kev&#39;</span><span class="p">:</span> <span class="mf">6.24150935</span><span class="p">,</span>  <span class="c1"># nPa/cm^3 --&gt; KeV.</span>
                 <span class="s1">&#39;k&#39;</span>  <span class="p">:</span> <span class="mf">72429626.47</span><span class="p">}</span> <span class="c1"># nPa/cm^3 --&gt; K.</span>

        <span class="c1"># Calculate number density if not done already.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;N&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_ndens</span><span class="p">()</span>
        
        <span class="c1"># Find all number density variables.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="c1"># Next variable if not number density:</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Next variable if no matching pressure:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;p&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span>
                <span class="n">conv</span><span class="p">[</span><span class="n">units</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="n">units</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">calc_bmag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates total magnetic field magnitude via:</span>
<span class="sd">        $|B|=\sqrt{B_X^2+B_Y^2+B_Z^2}$.  Results stored as variable name *b*.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bx&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>
                              <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;by&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>
                              <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bz&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">calc_magincl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;deg&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Magnetic inclination angle (a.k.a. inclination angle) is defined:</span>
<span class="sd">        $\Theta = sin^{-1}(B_Z/B)$.  It is a crucial value when examining</span>
<span class="sd">        magnetic dynamics about geosychronous orbit, the tail, and other</span>
<span class="sd">        locations.</span>

<span class="sd">        This function calculates the magnetic inclination for the Virtual </span>
<span class="sd">        Satellite object and saves it as *b_incl*.  Units default to degrees;</span>
<span class="sd">        the keyword **units** can be changed to &#39;rad&#39; to change this.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_bmag</span><span class="p">()</span>

        <span class="n">incl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bz&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">units</span><span class="o">==</span><span class="s1">&#39;deg&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b_incl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">incl</span><span class="o">*</span><span class="mf">180.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;degrees&#39;</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">units</span><span class="o">==</span><span class="s1">&#39;rad&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;b_incl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmarray</span><span class="p">(</span><span class="n">incl</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;radians&#39;</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized units.  Use &quot;deg&quot; or &quot;rad&quot;&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>
            
    <span class="k">def</span> <span class="nf">get_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For an arbitrary time, *time*, return a tuple of coordinates for</span>
<span class="sd">        the satellite&#39;s position at that time in GSM coordinates.</span>

<span class="sd">        *time* should be type datetime.datetime, matplotlib.dates.date2num</span>
<span class="sd">        output (i.e., number of days (fraction part represents hours,</span>
<span class="sd">        minutes, seconds) since 0001-01-01 00:00:00 UTC, *plus* *one*), or</span>
<span class="sd">        a sequence of either.</span>
<span class="sd">        The satellite&#39;s position is interpolated (linearly) to *time*.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="kn">from</span> <span class="nn">matplotlib.dates</span> <span class="kn">import</span> <span class="n">date2num</span>

        <span class="c1"># Test if sequence.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">testval</span><span class="o">=</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">testval</span><span class="o">=</span><span class="n">time</span>

        <span class="c1"># Test if datetime or not.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">testval</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">time</span><span class="o">=</span><span class="n">date2num</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="c1"># Interpolate, using &quot;try&quot; as to not pass time limits and extrapolate.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">](</span><span class="n">time</span><span class="p">),</span> 
                   <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">](</span><span class="n">time</span><span class="p">),</span> 
                   <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">](</span><span class="n">time</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">add_sat_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="s1">&#39;XY&#39;</span><span class="p">,</span> <span class="n">dobox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">dolabel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For a given axes, *target*, add the location of the satellite at</span>
<span class="sd">        time *time* as a circle.  If kwarg *dolabel* is True, the satellite&#39;s </span>
<span class="sd">        name will be used to label the dot.  Optional kwargs are any accepted by</span>
<span class="sd">        matplotlib.axes.Axes.plot.  The kwarg *plane* specifies the plane</span>
<span class="sd">        of the plot, e.g., &#39;XY&#39;, &#39;YZ&#39;, etc.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># Get Axes&#39; limits:</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="n">ylim</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
            
        <span class="n">plane</span><span class="o">=</span><span class="n">plane</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_position</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">loc</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">x</span><span class="o">=</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">y</span><span class="o">=</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="c1"># Do not label satellite if outside axes bounds.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="nb">min</span><span class="p">(</span><span class="n">xlim</span><span class="p">))</span><span class="ow">or</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="nb">max</span><span class="p">(</span><span class="n">xlim</span><span class="p">))</span><span class="ow">or</span> \
           <span class="p">(</span><span class="n">y</span><span class="o">&lt;</span><span class="nb">min</span><span class="p">(</span><span class="n">ylim</span><span class="p">))</span><span class="ow">or</span><span class="p">(</span><span class="n">y</span><span class="o">&gt;</span><span class="nb">max</span><span class="p">(</span><span class="n">ylim</span><span class="p">)):</span> <span class="n">dolabel</span><span class="o">=</span><span class="kc">False</span>

        <span class="n">target</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dolabel</span><span class="p">:</span>
            <span class="n">xoff</span> <span class="o">=</span> <span class="mf">0.03</span><span class="o">*</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">dobox</span><span class="p">:</span>
                <span class="n">target</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">xoff</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> 
                            <span class="n">bbox</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fc&#39;</span><span class="p">:</span><span class="s1">&#39;w&#39;</span><span class="p">,</span><span class="s1">&#39;ec&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">},</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">xoff</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> 
                            <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
                

        <span class="c1"># Restore Axes&#39; limits.</span>
        <span class="n">target</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
        <span class="n">target</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_orbit_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="s1">&#39;XY&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">111</span><span class="p">,</span> <span class="n">rbody</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">add_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;g.&#39;</span><span class="p">,</span>
                       <span class="n">adjust_axes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add_arrow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">arrow_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">:</span><span class="o">.</span><span class="mi">05</span><span class="p">,</span> <span class="s1">&#39;ec&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">},</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a 2D orbit plot in the given plane (e.g. &#39;XY&#39; or &#39;ZY&#39;).</span>
<span class="sd">        Extra kwargs are handed to the plot function. </span>


<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        None</span>
<span class="sd">        </span>
<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        plane : string</span>
<span class="sd">           Set the plane in which to plot (XY, XZ, etc.)  Defaults to XY.</span>
<span class="sd">        target : Matplotlib Figure or Axes object</span>
<span class="sd">           Set plot destination.  Defaults to new figure.</span>
<span class="sd">        loc : 3-digit integer</span>
<span class="sd">           Set subplot location.  Defaults to 111.</span>
<span class="sd">        adjust_axes : bool</span>
<span class="sd">           If True, axes will be customized to best display orbit (equal </span>
<span class="sd">           aspect ratio, grid on, planet drawn, etc.).  Defaults to True.</span>
<span class="sd">        style: string</span>
<span class="sd">           A matplotlib line style specifier.  Defaults to &#39;g.&#39;.</span>
<span class="sd">        title : string</span>
<span class="sd">           Set title of axes.</span>
<span class="sd">        rbody : real</span>
<span class="sd">           Set radius of model inner boundary.  Defaults to 1.0</span>
<span class="sd">        trange : list of datetimes</span>
<span class="sd">           Set the time range to plot.  Defaults to None, or entire dataset.</span>
<span class="sd">        add_grid : boolean</span>
<span class="sd">           Turn on or off grid style of axes.  Default is True.</span>
<span class="sd">        add_arrow : boolean</span>
<span class="sd">           Add arrow at end of orbit path to indicate direction.</span>
<span class="sd">           Default is True.</span>
<span class="sd">        arrow_kwargs : dict</span>
<span class="sd">           Dictionary of arrow kwargs.  Defaults to match line style.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">from</span> <span class="nn">spacepy.pybats</span> <span class="kn">import</span> <span class="n">add_body</span>
        <span class="kn">from</span> <span class="nn">spacepy.pybats.ram</span> <span class="kn">import</span> <span class="n">grid_zeros</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">set_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">)</span>

        <span class="n">plane</span><span class="o">=</span><span class="n">plane</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="c1"># Set time range of plot.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trange</span><span class="p">:</span> <span class="n">trange</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
        <span class="n">tloc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">trange</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Extract orbit X, Y, or Z.</span>
        <span class="n">plane</span><span class="o">=</span><span class="n">plane</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">tloc</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad dimension specifier: &#39;</span> <span class="o">+</span> <span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">tloc</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad dimension specifier: &#39;</span> <span class="o">+</span> <span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Actually plot:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">style</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Add arrow to plot:</span>
        <span class="k">if</span> <span class="n">add_arrow</span><span class="p">:</span>
            <span class="n">x_arr</span><span class="p">,</span> <span class="n">y_arr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">y_arr</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="o">**</span><span class="n">arrow_kwargs</span><span class="p">)</span>
        
        <span class="c1"># Finish customizing axis.</span>
        <span class="k">if</span> <span class="n">adjust_axes</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;GSM </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;GSM </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">add_grid</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
            <span class="n">grid_zeros</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">add_body</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="n">rbody</span><span class="p">,</span> <span class="n">add_night</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;X&#39;</span> <span class="ow">in</span> <span class="n">plane</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="https://spacepy.github.io/"">homepage</a>|&nbsp;</li>
        <li><a href="https://github.com/spacepy/spacepy">development</a>|&nbsp;</li>
        <li><a href="../../../search.html">search</a>|&nbsp;</li>
       <li><a href="../../../index.html">documentation </a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../spacepy.html" >spacepy</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../pybats.html" >spacepy.pybats</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spacepy.pybats.bats</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2020, The SpacePy Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.0.
    </div>
  </body>
</html>